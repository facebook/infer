<!DOCTYPE html>
<html lang="en" data-theme="">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="generator" content="Docusaurus">

<script type="text/javascript">/*<![CDATA[*/window.__chunkMapping={"17896441":["/17896441.547e8cec.js"],"main":["/main.66155581.js"],"00d3276d":["/00d3276d.729c97b9.js"],"16fe8a4c":["/16fe8a4c.0986402d.js"],"1906a68b":["/1906a68b.57fabe9a.js"],"1be78505":["/1be78505.25d8be57.js"],"1dbe42a7":["/1dbe42a7.619049a1.js"],"20ac7829":["/20ac7829.512266cf.js"],"293e08e8":["/293e08e8.11fe81c8.js"],"2f54a934":["/2f54a934.2e3f5f1b.js"],"3423820d":["/3423820d.f0ef983c.js"],"3eb0a99f":["/3eb0a99f.019d4120.js"],"3f15ec67":["/3f15ec67.0e96c71d.js"],"462c3b2b":["/462c3b2b.2bbff1f2.js"],"491a3217":["/491a3217.cb4f8e7c.js"],"5125cf7b":["/5125cf7b.dea5ce18.js"],"56ebd09a":["/56ebd09a.0739518f.js"],"5a5dcc21":["/5a5dcc21.065904cd.js"],"5f403532":["/5f403532.165c0d4f.js"],"6131ac47":["/6131ac47.d8392e4b.js"],"70793eb2":["/70793eb2.398a639d.js"],"72e974ef":["/72e974ef.084a31c5.js"],"7b1f0035":["/7b1f0035.aefbb374.js"],"7dd84d75":["/7dd84d75.bf4b41f8.js"],"805f3806":["/805f3806.af888142.js"],"9702a600":["/9702a600.510f0d9d.js"],"a5a260f1":["/a5a260f1.72c8757e.js"],"a6aa9e1f":["/a6aa9e1f.8a0e20a7.js"],"aa0b35eb":["/aa0b35eb.e3c2567b.js"],"acb2d06a":["/acb2d06a.4045c830.js"],"bab022f4":["/bab022f4.73ad523f.js"],"bbb4ffb5":["/bbb4ffb5.a52641d4.js"],"c412bf64":["/c412bf64.5af62795.js"],"c4f5d8e4":["/c4f5d8e4.872e9b3a.js"],"c6aa6fbc":["/c6aa6fbc.6aadb4ea.js"],"c8131338":["/c8131338.f68e2bbb.js"],"ccc49370":["/ccc49370.85cbc3ca.js"],"d9e16301":["/d9e16301.3a26cb77.js"],"dc4834dd":["/dc4834dd.e3b3e949.js"],"dcc75ef7":["/dcc75ef7.3b76f604.js"],"dd58f8af":["/dd58f8af.c5f230ae.js"],"ec789fed":["/ec789fed.37f20a69.js"],"f06ce8fa":["/f06ce8fa.82c1ea6b.js"],"f5ff54f0":["/f5ff54f0.387a5f12.js"],"fa9ab54d":["/fa9ab54d.12e59354.js"]};/*]]>*/</script>

<title data-react-helmet="true">Separation logic and bi-abduction</title>

<meta data-react-helmet="true" http-equiv="x-ua-compatible" content="ie=edge"/><meta data-react-helmet="true" property="og:title" content="Infer · A tool to detect bugs in Java and C/C++/Objective-C code before it ships"/><meta data-react-helmet="true" name="twitter:card" content="summary"/><meta data-react-helmet="true" name="description" content="export const Math = ({ code }) =&gt; ("/><meta data-react-helmet="true" property="og:description" content="export const Math = ({ code }) =&gt; ("/><meta data-react-helmet="true" property="og:url" content="https://fbinfer.com/docs/separation-logic-and-bi-abduction"/>

<link data-react-helmet="true" rel="shortcut icon" href="/img/favicon.png"/>


<link rel="stylesheet" type="text/css" href="/styles.cd8b7453.css" />

</head>
<body >
<script type="text/javascript">(function() {
  function setDataThemeAttribute(theme) {
    document.querySelector('html').setAttribute('data-theme', theme);
  }
  
  var preferDarkQuery = '(prefers-color-scheme: dark)';
  var mql = window.matchMedia(preferDarkQuery);
  var supportsColorSchemeQuery = mql.media === preferDarkQuery;
  var localStorageTheme = null;
  try {
    localStorageTheme = localStorage.getItem('theme');
  } catch (err) {}
  var localStorageExists = localStorageTheme !== null;

  if (localStorageExists) {
    setDataThemeAttribute(localStorageTheme);
  } else if (supportsColorSchemeQuery && mql.matches) {
    setDataThemeAttribute('dark');
  }
})();</script>
<div id="__docusaurus">
<nav class="navbar navbar--light navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><div aria-label="Navigation bar toggle" class="navbar__toggle" role="button" tabindex="0"><svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></div><a aria-current="page" class="navbar__brand active" href="/"><img class="navbar__logo" src="/img/logo.png" alt="Infer Logo"/><strong class="">Infer</strong></a><a class="navbar__item navbar__link" href="/docs/getting-started">Docs</a><a class="navbar__item navbar__link" href="/docs/support">Support</a><a class="navbar__item navbar__link" href="/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a class="navbar__item navbar__link" target="_blank" rel="noopener noreferrer" href="https://twitter.com/fbinfer">Twitter</a><a class="navbar__item navbar__link" target="_blank" rel="noopener noreferrer" href="https://www.facebook.com/inferstaticanalyzer">Facebook</a><a class="navbar__item navbar__link" target="_blank" rel="noopener noreferrer" href="https://github.com/facebook/infer">GitHub</a><div class="react-toggle react-toggle--disabled displayOnlyInLargeViewport_1gtM"><div class="react-toggle-track"><div class="react-toggle-track-check"><span class="toggle_keGJ moon_1gwN"></span></div><div class="react-toggle-track-x"><span class="toggle_keGJ sun_3CPA"></span></div></div><div class="react-toggle-thumb"></div><input type="checkbox" disabled="" aria-label="Dark mode toggle" class="react-toggle-screenreader-only"/></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a aria-current="page" class="navbar__brand active" href="/"><img class="navbar__logo" src="/img/logo.png" alt="Infer Logo"/><strong>Infer</strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/docs/getting-started">Docs</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/support">Support</a></li><li class="menu__list-item"><a class="menu__link" href="/blog">Blog</a></li><li class="menu__list-item"><a class="menu__link" target="_blank" rel="noopener noreferrer" href="https://twitter.com/fbinfer">Twitter</a></li><li class="menu__list-item"><a class="menu__link" target="_blank" rel="noopener noreferrer" href="https://www.facebook.com/inferstaticanalyzer">Facebook</a></li><li class="menu__list-item"><a class="menu__link" target="_blank" rel="noopener noreferrer" href="https://github.com/facebook/infer">GitHub</a></li></ul></div></div></div></nav><div class="main-wrapper"><div class="docPage_1kjD"><div class="docSidebarContainer_1cYp"><div class="sidebar_1kLs"><div class="menu menu--responsive"><button aria-label="Open Menu" class="button button--secondary button--sm menu__button" type="button"><svg class="sidebarMenuIcon_2vk4" xmlns="http://www.w3.org/2000/svg" height="24" width="24" viewBox="0 0 32 32" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Quick Start</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/docs/getting-started">Getting started with Infer</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/hello-world">Hello, World!</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">User Guide</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/docs/infer-workflow">Infer workflow</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/analyzing-apps-or-projects">Analyzing apps or projects</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/steps-for-ci">Recommended flow for CI</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/checkers">Infer : AI</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/eradicate">Infer : Eradicate</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/linters">Infer : AL</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/racerd">Infer : RacerD</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/experimental-checkers">Infer : Experimental Checkers</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/advanced-features">Advanced usage</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/adding-models">Adding models</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/man-pages">Infer Manuals</a></li></ul></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!">Foundations</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/docs/about-Infer">About Infer</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active" href="/docs/separation-logic-and-bi-abduction">Separation logic and bi-abduction</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/limitations">Limitations, etc</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Bug Types Reference</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/docs/checkers-bug-types">Checkers bug types</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/eradicate-warnings">Eradicate warnings</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/linters-bug-types">Linters bug types</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Contribute</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/docs/absint-framework">Building checkers with the Infer.AI framework</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/adding-checkers">Simple intraprocedural checkers</a></li><li class="menu__list-item"><a class="menu__link" href="/docs/internal-API">Infer Internal OCaml Modules API</a></li></ul></li></ul></div></div></div><main class="docMainContainer_FFX1"><div class="padding-vert--lg"><div class="container"><div class="row"><div class="col"><div class="docItemContainer_2cwg"><article><header><h1 class="docTitle_1vWb">Separation logic and bi-abduction</h1></header><div class="markdown"><ul><li><a href="separation-logic-and-bi-abduction#separation-logic">Separation logic</a></li><li><a href="separation-logic-and-bi-abduction#bi-abduction">Bi-abduction</a></li><li><a href="separation-logic-and-bi-abduction#technical-papers">Technical papers</a></li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor" id="separation-logic"></a><a aria-hidden="true" tabindex="-1" class="hash-link" href="#separation-logic" title="Direct link to heading">#</a>Separation logic</h2><p>Separation logic is a novel kind of mathematical logic which facilitates reasoning about
mutations to computer memory. It enables scalability by breaking reasoning into chunks
corresponding to local operations on memory, and then composing
the reasoning chunks together.</p><p>Separation logic is based on a logical connective <img src="https://math.now.sh?from=%5C%5C(%20*%20%5C%5C)&amp;color=mediumslateblue" style="height:100%;vertical-align:middle"/> called the <em>separating conjunction</em> and pronounced &quot;and separately&quot;. Separation logic formulae are interpreted over program allocated heaps. The logical formula</p><img src="https://math.now.sh?from=%5C%5C(%20A*B%20%5C%5C)&amp;color=mediumslateblue" style="height:100%;vertical-align:middle"/> holds of a piece of program heap (a heaplet) when it can be divided into two sub-heaplets described by <img src="https://math.now.sh?from=%5C%5C(A%5C%5C)&amp;color=mediumslateblue" style="height:100%;vertical-align:middle"/> and <img src="https://math.now.sh?from=%5C%5C(B%5C%5C)&amp;color=mediumslateblue" style="height:100%;vertical-align:middle"/>. For example, the formula<hr/><img src="https://math.now.sh?from=%5C%5C(x%20%5Cmapsto%20y%20*%20y%20%5Cmapsto%20x%20%5C%5C)&amp;color=mediumslateblue" style="height:100%;vertical-align:middle"/><hr/><p>can be read &quot;<img src="https://math.now.sh?from=%5C%5C(x%5C%5C)&amp;color=mediumslateblue" style="height:100%;vertical-align:middle"/> points to <img src="https://math.now.sh?from=%5C%5C(y%5C%5C)&amp;color=mediumslateblue" style="height:100%;vertical-align:middle"/> and separately <img src="https://math.now.sh?from=%5C%5C(y%5C%5C)&amp;color=mediumslateblue" style="height:100%;vertical-align:middle"/> points to <img src="https://math.now.sh?from=%5C%5C(x%5C%5C)&amp;color=mediumslateblue" style="height:100%;vertical-align:middle"/>&quot;. This formula describes precisely two allocated memory cells. The first cell is allocated at the address denoted by the pointer <img src="https://math.now.sh?from=%5C%5C(x%5C%5C)&amp;color=mediumslateblue" style="height:100%;vertical-align:middle"/> and the content of this cell is the value of <img src="https://math.now.sh?from=%5C%5C(y%5C%5C)&amp;color=mediumslateblue" style="height:100%;vertical-align:middle"/>.
The second cell is allocated at the address denoted by the pointer <img src="https://math.now.sh?from=%5C%5C(y%5C%5C)&amp;color=mediumslateblue" style="height:100%;vertical-align:middle"/> and the content of this second cell is the value of <img src="https://math.now.sh?from=%5C%5C(x%5C%5C)&amp;color=mediumslateblue" style="height:100%;vertical-align:middle"/>. Crucially, we know that there are precisely two cells because <img src="https://math.now.sh?from=%5C%5C(%20*%20%5C%5C)&amp;color=mediumslateblue" style="height:100%;vertical-align:middle"/> stipulates that they are separated and therefore the cells are allocated in two different parts of memory. In other words, <img src="https://math.now.sh?from=%5C%5C(%20*%20%5C%5C)&amp;color=mediumslateblue" style="height:100%;vertical-align:middle"/>
says that <img src="https://math.now.sh?from=%5C%5C(x%5C%5C)&amp;color=mediumslateblue" style="height:100%;vertical-align:middle"/> and <img src="https://math.now.sh?from=%5C%5C(y%5C%5C)&amp;color=mediumslateblue" style="height:100%;vertical-align:middle"/> do not hold the same value (i.e., these pointers are not aliased).
The heaplet partitioning defined by the formula above can visualized like so:</p><p><img src="/img/SepSplit.jpg"/></p><p>The important thing about separating conjunction is
the way that it fits together with mutation to computer memory; reasoning about program commands
tends to work by updating <img src="https://math.now.sh?from=%5C%5C(*%5C%5C)&amp;color=mediumslateblue" style="height:100%;vertical-align:middle"/>-conjuncts in-place, mimicking the operational in-place update of RAM.</p><p>Separation logic uses Hoare triples of the form <img src="https://math.now.sh?from=%5C%5C(%20%5Clbrace%20pre%20%5Crbrace%20prog%20%5Clbrace%20post%20%5Crbrace%20%5C%5C)&amp;color=mediumslateblue" style="height:100%;vertical-align:middle"/> where <img src="https://math.now.sh?from=%5C%5C(pre%5C%5C)&amp;color=mediumslateblue" style="height:100%;vertical-align:middle"/> is the precondition, <img src="https://math.now.sh?from=%5C%5C(prog%5C%5C)&amp;color=mediumslateblue" style="height:100%;vertical-align:middle"/> a program part, and <img src="https://math.now.sh?from=%5C%5C(post%5C%5C)&amp;color=mediumslateblue" style="height:100%;vertical-align:middle"/>
the postcondition. Triples are abstract specifications of the behavior of the program. For example, we could take</p><hr/><img src="https://math.now.sh?from=%5C%5C(%20%5Clbrace%20r%20%5Cmapsto%20open%5Crbrace%20%5C%2C%20closeResource(r)%5C%2C%20%5Clbrace%20r%20%5Cmapsto%20closed%5Crbrace%20%20%5C%3B%5C%3B%5C%3B%20(spec)%5C%5C)&amp;color=mediumslateblue" style="height:100%;vertical-align:middle"/><hr/><p>as a specification for a method which closes a resource given to it as a parameter.</p><p>Now, suppose we have two resources <img src="https://math.now.sh?from=%5C%5C(%20r%5C_1%20%5C%5C)&amp;color=mediumslateblue" style="height:100%;vertical-align:middle"/> and <img src="https://math.now.sh?from=%5C%5C(%20r%5C_2%20%5C%5C)&amp;color=mediumslateblue" style="height:100%;vertical-align:middle"/>, described by <img src="https://math.now.sh?from=%5C%5C(r%5C_1%20%5Cmapsto%20open%20*%20r%5C_2%20%5Cmapsto%20open%5C%5C)&amp;color=mediumslateblue" style="height:100%;vertical-align:middle"/>
and we close the first of them. We think operationally in terms of updating the memory in place, leaving <!-- -->\<!-- -->(r_2 \mapsto open<!-- -->\<!-- -->) alone,
as described by this triple:</p><hr/><img src="https://math.now.sh?from=%5C%5C(%20%5Clbrace%20r%5C_1%20%5Cmapsto%20open%20*%20r%5C_2%20%5Cmapsto%20open%5Crbrace%20%20closeResource(r%5C_1)%20%5Clbrace%20r%5C_1%20%5Cmapsto%20closed%20*%20r%5C_2%20%5Cmapsto%20open%20%5Crbrace%20%5C%3B%5C%3B%5C%3B%20(use)%5C%5C)&amp;color=mediumslateblue" style="height:100%;vertical-align:middle"/><hr/><p>What we have here is the that specification (spec) described how <img src="https://math.now.sh?from=%5C%5C(closeResource()%5C%5C)&amp;color=mediumslateblue" style="height:100%;vertical-align:middle"/> works by mentioning only one
piece of state, what is sometimes called a small specification,
and in (use) we use that specification to update a larger precondition in place.</p><p>This is an instance of a general pattern.
There is a rule that lets you go from smaller to bigger specifications</p><hr/><img src="https://math.now.sh?from=%5C%5C(%20%5Cfrac%7B%5Clbrace%20pre%20%5Crbrace%20prog%20%5Clbrace%20post%20%5Crbrace%7D%7B%5Clbrace%20pre%20*%20frame%20%5Crbrace%20prog%20%5Clbrace%20post%20*%20frame%20%5Crbrace%7D%5C%5C)&amp;color=mediumslateblue" style="height:100%;vertical-align:middle"/><hr/><p>Our passage from (spec) to (use) is obtained by taking</p><ul><li><img src="https://math.now.sh?from=%5C%5C(pre%5C%5C)&amp;color=mediumslateblue" style="height:100%;vertical-align:middle"/> to be <img src="https://math.now.sh?from=%5C%5C(r%5C_1%20%5Cmapsto%20open%5C%5C)&amp;color=mediumslateblue" style="height:100%;vertical-align:middle"/></li><li><img src="https://math.now.sh?from=%5C%5C(post%5C%5C)&amp;color=mediumslateblue" style="height:100%;vertical-align:middle"/> to be <img src="https://math.now.sh?from=%5C%5C(r%5C_1%20%5Cmapsto%20closed%20%5C%5C)&amp;color=mediumslateblue" style="height:100%;vertical-align:middle"/>, and</li><li><img src="https://math.now.sh?from=%5C%5C(frame%5C%5C)&amp;color=mediumslateblue" style="height:100%;vertical-align:middle"/> to be <img src="https://math.now.sh?from=%5C%5C(r%5C_2%20%5Cmapsto%20open%20%5C%5C)&amp;color=mediumslateblue" style="height:100%;vertical-align:middle"/></li></ul><p>This rule is called the <em>frame rule</em> of separation logic. It is named after the frame problem, a classic problem in artificial intelligence.
Generally, the <img src="https://math.now.sh?from=%5C%5C(frame%5C%5C)&amp;color=mediumslateblue" style="height:100%;vertical-align:middle"/> describes state that remains unchanged; the terminology comes from the analogy of
a background scene in an animation as unchanging while the objects and characters within the scene change.</p><p>The frame rule is the key to the principle of local reasoning in separation logic: reasoning and specifications
should concentrate on the resources that a program accesses (the footprint), without mentioning what
doesn&#x27;t change.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor" id="bi-abduction"></a><a aria-hidden="true" tabindex="-1" class="hash-link" href="#bi-abduction" title="Direct link to heading">#</a>Bi-abduction</h2><p>Bi-abduction is a form of logical inference for separation logic which automates the key ideas about local
reasoning.</p><p>Usually, logic works with validity or entailment statements like</p><hr/><img src="https://math.now.sh?from=%5C%5C(A%20%5Cvdash%20B%5C%5C)&amp;color=mediumslateblue" style="height:100%;vertical-align:middle"/><hr/><p>which says that <img src="https://math.now.sh?from=%5C%5C(A%5C%5C)&amp;color=mediumslateblue" style="height:100%;vertical-align:middle"/> implies <img src="https://math.now.sh?from=%5C%5C(B%5C%5C)&amp;color=mediumslateblue" style="height:100%;vertical-align:middle"/>. Infer uses an extension of this inference question in an internal
theorem prover while it runs over program statements.
Infer&#x27;s question</p><hr/><img src="https://math.now.sh?from=%5C%5C(A%20*%20%3Fantiframe%20%5Cvdash%20B%20*%20%3Fframe%5C%5C)&amp;color=mediumslateblue" style="height:100%;vertical-align:middle"/><hr/><p>is called <em>bi-abduction</em>. The problem here is for the theorem prover to <i> discover </i> a pair of frame and antiframe formulae that make the entailment statement valid.</p><p>Global analyses of large programs are normally computational untractable. However,
bi-abduction allows to break the large analysis of a large program in small independent analyses of its procedures. This gives Infer the ability to scale independently of the size of the analyzed code. Moreover, by breaking the analysis in small
independent parts, when the full program is analyzed again because
of a code change the analysis results of the unchanged part of the
code can be reused and only the code change needs to be re-analyzed. This process is called incremental analysis and it
is very powerful when integrating a static analysis tool like infer in a development environment.</p><p>In order to be able to decompose a global analysis in small independent analyses, let&#x27;s first consider how a function
call is analyzed in separation logic. Assume we have the following spec for a function <img src="https://math.now.sh?from=%5C%5C(%20f()%20%5C%5C)&amp;color=mediumslateblue" style="height:100%;vertical-align:middle"/>:</p><hr/><img src="https://math.now.sh?from=%5C%5C(%20%5Clbrace%20pre%5C_f%20%5Crbrace%20%5C%3B%5C%3B%20f()%20%5C%3B%5C%3B%20%5Clbrace%20post%5C_f%20%5Crbrace%20%5C%5C)&amp;color=mediumslateblue" style="height:100%;vertical-align:middle"/><hr/><p>and by analyzing the caller function, we compute that before
the call of <img src="https://math.now.sh?from=%5C%5C(%20f%20%5C%5C)&amp;color=mediumslateblue" style="height:100%;vertical-align:middle"/>, the formula <img src="https://math.now.sh?from=%5C%5C(%20CallingState%20%5C%5C)&amp;color=mediumslateblue" style="height:100%;vertical-align:middle"/> hold. Then
to utilize the specification of <img src="https://math.now.sh?from=%5C%5C(%20f%20%5C%5C)&amp;color=mediumslateblue" style="height:100%;vertical-align:middle"/> the following implication must holds:</p><hr/><img src="https://math.now.sh?from=%5C%5C(%20CallingState%20%5Cvdash%20pre%5C_f%20%20%5C%3B%5C%3B%5C%3B%5C%3B%5C%3B%5C%3B%5C%3B%5C%3B%5C%3B%5C%3B%5C%3B%5C%3B%20(Function%20Call)%5C%5C)&amp;color=mediumslateblue" style="height:100%;vertical-align:middle"/><hr/><p>Given that,
bi-abduction is used at procedure call sites for two reasons: to discover missing state that is needed for the above implication to hold and allow the analysis
to proceed (the antiframe) as well as state that the procedure leaves unchanged (the frame).</p><p>To see how this works suppose we have some bare code</p><hr/><img src="https://math.now.sh?from=%5C%5C(closeResource(r1)%3B%20%5C%2C%20closeResource(r2)%5C%5C)&amp;color=mediumslateblue" style="height:100%;vertical-align:middle"/><hr/><p>but no overall specification;
we are going to describe how to discover a pre/post spec for it.
Considering the first statement and the (spec) above, the human might say: if only we had</p><img src="https://math.now.sh?from=%5C%5C(r1%20%5Cmapsto%20open%5C%5C)&amp;color=mediumslateblue" style="height:100%;vertical-align:middle"/> in the precondition then we could proceed. Technically, we ask a bi-abduction question<hr/><img src="https://math.now.sh?from=%5C%5C(emp%20*%20%3Fantiframe%20%5Cvdash%20r1%20%5Cmapsto%20open%20*%20%3Fframe%5C%5C)&amp;color=mediumslateblue" style="height:100%;vertical-align:middle"/><hr/><p>and we can fill this in easily by picking <img src="https://math.now.sh?from=%5C%5C(antiframe%20%3D%20r1%20%5Cmapsto%20open%5C%5C)&amp;color=mediumslateblue" style="height:100%;vertical-align:middle"/> and <img src="https://math.now.sh?from=%5C%5C(frame%20%3D%20emp%5C%5C)&amp;color=mediumslateblue" style="height:100%;vertical-align:middle"/>,
where emp means the empty state. The emp is recording that at the start we presume nothing. So we obtain the trivially true implication:</p><hr/><img src="https://math.now.sh?from=%5C%5C(emp%20*%20r1%20%5Cmapsto%20open%20%5Cvdash%20r1%20%5Cmapsto%20open%20*%20emp%5C%5C)&amp;color=mediumslateblue" style="height:100%;vertical-align:middle"/><hr/><p>which, by applying logical rules, can be re-written equivalently to:</p><hr/><img src="https://math.now.sh?from=%5C%5C(r1%20%5Cmapsto%20open%20%5Cvdash%20r1%20%5Cmapsto%20open%5C%5C)&amp;color=mediumslateblue" style="height:100%;vertical-align:middle"/><hr/><p>Notice that this satisfy the (Function Call) requirement to correctly make the call.
So let&#x27;s add that information in the pre, and while we are at it
record the information in the post of the first statement that comes from (spec).</p><hr/><img src="https://math.now.sh?from=%5C%5C(%20%5Clbrace%20r1%20%5Cmapsto%20open%20%20%5Crbrace%20%5C%5C)&amp;color=mediumslateblue" style="height:100%;vertical-align:middle"/><img src="https://math.now.sh?from=%5C%5C(%20closeResource(r1)%20%5C%5C)&amp;color=mediumslateblue" style="height:100%;vertical-align:middle"/><img src="https://math.now.sh?from=%5C%5C(%20%5Clbrace%20r1%20%5Cmapsto%20closed%20%5Crbrace%20%5C%5C)&amp;color=mediumslateblue" style="height:100%;vertical-align:middle"/><img src="https://math.now.sh?from=%5C%5C(%20closeResource(r2)%20%5C%5C)&amp;color=mediumslateblue" style="height:100%;vertical-align:middle"/><hr/><p>Now, let&#x27;s move to the second statement. Its precondition <img src="https://math.now.sh?from=%5C%5C(r1%20%5Cmapsto%20closed%5C%5C)&amp;color=mediumslateblue" style="height:100%;vertical-align:middle"/> in the partial symbolic execution trace just given
does not have the information needed by <img src="https://math.now.sh?from=%5C%5C(closeResource(r2)%5C%5C)&amp;color=mediumslateblue" style="height:100%;vertical-align:middle"/>, so we can fill that in and continue by
putting <img src="https://math.now.sh?from=%5C%5C(r2%20%5Cmapsto%20open%5C%5C)&amp;color=mediumslateblue" style="height:100%;vertical-align:middle"/> in the pre. While we are at it we can thread this assertion back to the beginning.</p><hr/><img src="https://math.now.sh?from=%5C%5C(%20%5Clbrace%20r1%20%5Cmapsto%20open%20*%20r2%20%5Cmapsto%20open%20%20%5Crbrace%20%5C%5C)&amp;color=mediumslateblue" style="height:100%;vertical-align:middle"/><img src="https://math.now.sh?from=%5C%5C(%20closeResource(r1)%20%5C%5C)&amp;color=mediumslateblue" style="height:100%;vertical-align:middle"/><img src="https://math.now.sh?from=%5C%5C(%20%5Clbrace%20r1%20%5Cmapsto%20closed%20*%20r2%20%5Cmapsto%20open%5Crbrace%20%5C%5C)&amp;color=mediumslateblue" style="height:100%;vertical-align:middle"/><img src="https://math.now.sh?from=%5C%5C(%20closeResource(r2)%20%5C%5C)&amp;color=mediumslateblue" style="height:100%;vertical-align:middle"/><hr/><p>This information on what to thread backwards can be obtained as the antiframe part of the bi-abduction question</p><hr/><img src="https://math.now.sh?from=%5C%5C(r1%20%5Cmapsto%20closed%20*%20%3Fantiframe%20%5Cvdash%20r2%20%5Cmapsto%20open%20*%20%3Fframe%5C%5C)&amp;color=mediumslateblue" style="height:100%;vertical-align:middle"/><hr/><p>where the solution picks</p><img src="https://math.now.sh?from=%5C%5C(antiframe%20%3D%20r2%20%5Cmapsto%20open%5C%5C)%20and%20%5C%5C(frame%20%3D%20r1%20%5Cmapsto%20closed%5C%5C)&amp;color=mediumslateblue" style="height:100%;vertical-align:middle"/>. Note that the antiframe is precisely the information missing from the precondition in order for <img src="https://math.now.sh?from=%5C%5C(closeResource(r2)%5C%5C)&amp;color=mediumslateblue" style="height:100%;vertical-align:middle"/> to proceed. On the other hand, the frame <img src="https://math.now.sh?from=%5C%5C(r1%20%5Cmapsto%20closed%5C%5C)&amp;color=mediumslateblue" style="height:100%;vertical-align:middle"/> is the portion of state not changed by <img src="https://math.now.sh?from=%5C%5C(closeResource(r2)%5C%5C)&amp;color=mediumslateblue" style="height:100%;vertical-align:middle"/>; we can thread that through to the overall postconditon (as justified by the frame rule), giving us<hr/><img src="https://math.now.sh?from=%5C%5C(%20%5Clbrace%20r1%20%5Cmapsto%20open%20*%20r2%20%5Cmapsto%20open%20%20%5Crbrace%20%5C%5C)&amp;color=mediumslateblue" style="height:100%;vertical-align:middle"/><img src="https://math.now.sh?from=%5C%5C(%20closeResource(r1)%20%5C%5C)&amp;color=mediumslateblue" style="height:100%;vertical-align:middle"/><img src="https://math.now.sh?from=%5C%5C(%20%5Clbrace%20r1%20%5Cmapsto%20closed%20*%20r2%20%5Cmapsto%20open%5Crbrace%20%5C%5C)&amp;color=mediumslateblue" style="height:100%;vertical-align:middle"/><img src="https://math.now.sh?from=%5C%5C(%20closeResource(r2)%20%5C%5C)&amp;color=mediumslateblue" style="height:100%;vertical-align:middle"/><img src="https://math.now.sh?from=%5C%5C(%20%5Clbrace%20r1%20%5Cmapsto%20closed%20*%20r2%20%5Cmapsto%20closed%20%5Crbrace%5C%5C)&amp;color=mediumslateblue" style="height:100%;vertical-align:middle"/><hr/><p>Thus, we have obtained a pre and post for this code by symbolically executing it, using bi-abduction
to discover preconditions (abduction of antiframes) as well as untouched portions of memory (frames) as we go along.</p><p>In general, bi-abduction
provides a way to infer a pre/post specs from bare code, as long as we know specs for the primitives at the base level of the code. The human does not need to write preconditions and postconditions for all the procedures,
which is the key to having a high level of automation.
This is the basis for how Infer works, why it can scale, and how it can analyze code changes incrementally.</p><p>Context: The logical terminology we have been using here comes from AI and philosophy of science.
Abductive inference was introduced by the philosopher Charles Peirce, and described as the mechanism
underpinning hypothesis formation (or, guessing what might be true about the world), the most
creative part of the scientific process.
Abduction and the frame problem have both attracted significant attention in AI.
Infer uses an automated form of abduction to generate
preconditions describing the memory that a program touches (the antiframe part above), and frame inference to
discover what isn&#x27;t touched.
Infer then uses deductive reasoning to
calculate a formula describing the effect of a program, starting from the preconditions.
In a sense, Infer approaches automated reasoning about programs by mimicking what a human might do when trying to understand a program: it abduces what the program needs, and deduces conclusions of that.
It is when the reasoning goes wrong that Infer reports a potential bug.</p><p>This description is by necessity simplified compared to what Infer actually does.
More technical information can be found in the following papers. The descriptions in the papers are
precise, but still simplified; there are many engineering decisions not recorded there. Finally, beyond the papers,
you can read the source code if you wish!</p><h2><a aria-hidden="true" tabindex="-1" class="anchor" id="technical-papers"></a><a aria-hidden="true" tabindex="-1" class="hash-link" href="#technical-papers" title="Direct link to heading">#</a>Technical papers</h2><p>The following papers contain some of the technical background on Infer and information on how it is used inside Facebook.</p><ul><li><a href="http://link.springer.com/chapter/10.1007%2F3-540-44802-0_1">Local Reasoning about Programs that Alter Data Structures.</a> An early separation logic paper which advanced ideas about local reasoning and the frame rule.</li><li><a href="http://link.springer.com/chapter/10.1007/11804192_6">Smallfoot: Modular Automatic Assertion Checking with Separation Logic.</a> First separation logic verification tool, introduced frame inference</li><li><a href="http://link.springer.com/chapter/10.1007%2F11691372_19">A Local Shape Analysis Based on Separation Logic.</a> Separation logic meets abstract interpretation; calculating loop invariants via a fixed-point computation.</li><li><a href="http://dl.acm.org/citation.cfm?id=2049700">Compositional Shape Analysis by Means of Bi-Abduction.</a>The bi-abduction paper.</li><li><a href="https://research.facebook.com/publications/moving-fast-with-software-verification/">Moving Fast with Software Verification.</a> A paper about the way we use Infer at Facebook.</li></ul></div></article><div class="margin-vert--lg"><nav class="pagination-nav"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/docs/about-Infer"><h5 class="pagination-nav__link--sublabel">Previous</h5><h4 class="pagination-nav__link--label">« <!-- -->About Infer</h4></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/docs/limitations"><h5 class="pagination-nav__link--sublabel">Next</h5><h4 class="pagination-nav__link--label">Limitations, etc<!-- --> »</h4></a></div></nav></div></div></div><div class="col col--3"><div class="tableOfContents_TbNY"><ul class="contents contents__left-border"><li><a href="#separation-logic" class="contents__link">Separation logic</a></li><li><a href="#bi-abduction" class="contents__link">Bi-abduction</a></li><li><a href="#technical-papers" class="contents__link">Technical papers</a></li></ul></div></div></div></div></div></main></div></div><footer class="footer"><div class="container"><div class="row footer__links"><div class="col footer__col"><h4 class="footer__title">Docs</h4><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/docs/getting-started">Quick Start</a></li><li class="footer__item"><a class="footer__link-item" href="/docs/infer-workflow">User Guide</a></li><li class="footer__item"><a class="footer__link-item" href="/docs/about-Infer">Foundations</a></li><li class="footer__item"><a class="footer__link-item" href="/docs/checkers-bug-types">Bug Types Reference</a></li><li class="footer__item"><a class="footer__link-item" href="/docs/absint-framework">Contribute</a></li></ul></div><div class="col footer__col"><h4 class="footer__title">Community</h4><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/docs/support">Support</a></li></ul></div><div class="col footer__col"><h4 class="footer__title">Social</h4><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a class="footer__link-item" target="_blank" rel="noopener noreferrer" href="https://github.com/facebook">GitHub</a></li><li class="footer__item"><a class="footer__link-item" target="_blank" rel="noopener noreferrer" href="https://twitter.com/fbOpenSource">Twitter</a></li></ul></div></div><div class="text--center">Copyright © 2020 Facebook, Inc. Built with Docusaurus.</div></div></footer>
</div>

<script type="text/javascript" src="/styles.36c46242.js"></script>

<script type="text/javascript" src="/runtime~main.ac9d445a.js"></script>

<script type="text/javascript" src="/main.66155581.js"></script>

<script type="text/javascript" src="/1.3a07998e.js"></script>

<script type="text/javascript" src="/2.a5fd010b.js"></script>

<script type="text/javascript" src="/1be78505.25d8be57.js"></script>

<script type="text/javascript" src="/20ac7829.512266cf.js"></script>

<script type="text/javascript" src="/17896441.547e8cec.js"></script>

<script type="text/javascript" src="/1906a68b.57fabe9a.js"></script>


</body>
</html>