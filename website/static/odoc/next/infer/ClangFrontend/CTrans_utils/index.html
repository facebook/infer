<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>CTrans_utils (infer.ClangFrontend.CTrans_utils)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">infer</a> &#x00BB; <a href="../index.html">ClangFrontend</a> &#x00BB; CTrans_utils</nav><header class="odoc-preamble"><h1>Module <code><span>ClangFrontend.CTrans_utils</span></code></h1></header><div class="odoc-content"><div class="odoc-spec"><div class="spec module" id="module-F" class="anchored"><a href="#module-F" class="anchor"></a><code><span><span class="keyword">module</span> </span><span>F</span><span> = <span class="xref-unresolved">Stdlib</span>.Format</span></code></div></div><p>Utility methods to support the translation of clang ast constructs into sil instructions.</p><div class="odoc-spec"><div class="spec type" id="type-continuation" class="anchored"><a href="#type-continuation" class="anchor"></a><code><span><span class="keyword">type</span> continuation</span><span> = </span><span>{</span></code><table><tr id="type-continuation.break" class="anchored"><td class="def record field"><a href="#type-continuation.break" class="anchor"></a><code><span>break : <span><a href="../../IR/Procdesc/Node/index.html#type-t">IR.Procdesc.Node.t</a> list</span>;</span></code></td></tr><tr id="type-continuation.continue" class="anchored"><td class="def record field"><a href="#type-continuation.continue" class="anchor"></a><code><span>continue : <span><a href="../../IR/Procdesc/Node/index.html#type-t">IR.Procdesc.Node.t</a> list</span>;</span></code></td></tr><tr id="type-continuation.return_temp" class="anchored"><td class="def record field"><a href="#type-continuation.return_temp" class="anchor"></a><code><span>return_temp : bool;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>true if temps should not be removed in the node but returned to ancestors</p><span class="comment-delim">*)</span></td></tr></table><code><span>}</span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-priority_node" class="anchored"><a href="#type-priority_node" class="anchor"></a><code><span><span class="keyword">type</span> priority_node</span><span> = </span></code><table><tr id="type-priority_node.Free" class="anchored"><td class="def variant constructor"><a href="#type-priority_node.Free" class="anchor"></a><code><span>| </span><span><span class="constructor">Free</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>no node currently being created</p><span class="comment-delim">*)</span></td></tr><tr id="type-priority_node.Busy" class="anchored"><td class="def variant constructor"><a href="#type-priority_node.Busy" class="anchor"></a><code><span>| </span><span><span class="constructor">Busy</span> <span class="keyword">of</span> <a href="../../ATDGenerated/Clang_ast_t/index.html#type-pointer">ATDGenerated.Clang_ast_t.pointer</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>the translation of the clang expression or statement at <code>pointer</code> will create a node with the collected instructions from the sub-expressions (see <a href="#type-control.instrs"><code>control.instrs</code></a></p><span class="comment-delim">*)</span></td></tr></table></div><div class="spec-doc"><p>Whether we are collecting instructions for a new block in the CFG (<code>Busy</code>) or there are no blocks being created from enclosing translations (<code>Free</code>)</p></div></div><div class="odoc-spec"><div class="spec type" id="type-trans_state" class="anchored"><a href="#type-trans_state" class="anchor"></a><code><span><span class="keyword">type</span> trans_state</span><span> = </span><span>{</span></code><table><tr id="type-trans_state.context" class="anchored"><td class="def record field"><a href="#type-trans_state.context" class="anchor"></a><code><span>context : <a href="../CContext/index.html#type-t">CContext.t</a>;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>global context of the translation</p><span class="comment-delim">*)</span></td></tr><tr id="type-trans_state.succ_nodes" class="anchored"><td class="def record field"><a href="#type-trans_state.succ_nodes" class="anchor"></a><code><span>succ_nodes : <span><a href="../../IR/Procdesc/Node/index.html#type-t">IR.Procdesc.Node.t</a> list</span>;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>successor nodes in the CFG, i.e. instructions that will happen *after* the current expression or statement being translated (note that the CFG is constructed bottom-up, starting from the last instructions)</p><span class="comment-delim">*)</span></td></tr><tr id="type-trans_state.continuation" class="anchored"><td class="def record field"><a href="#type-trans_state.continuation" class="anchor"></a><code><span>continuation : <span><a href="#type-continuation">continuation</a> option</span>;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>current continuation, used for <code>break</code>, <code>continue</code>, and the like</p><span class="comment-delim">*)</span></td></tr><tr id="type-trans_state.priority" class="anchored"><td class="def record field"><a href="#type-trans_state.priority" class="anchor"></a><code><span>priority : <a href="#type-priority_node">priority_node</a>;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>see <a href="#type-priority_node"><code>priority_node</code></a></p><span class="comment-delim">*)</span></td></tr><tr id="type-trans_state.var_exp_typ" class="anchored"><td class="def record field"><a href="#type-trans_state.var_exp_typ" class="anchor"></a><code><span>var_exp_typ : <span><span>(<a href="../../IR/Exp/index.html#type-t">IR.Exp.t</a> * <a href="../../IR/Typ/index.html#type-t">IR.Typ.t</a>)</span> option</span>;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>the expression (usually of the form <code>Exp.Lvar pvar</code>) that the enclosing expression or statement is trying to initialize, if any</p><span class="comment-delim">*)</span></td></tr><tr id="type-trans_state.opaque_exp" class="anchored"><td class="def record field"><a href="#type-trans_state.opaque_exp" class="anchor"></a><code><span>opaque_exp : <span><span>(<a href="../../IR/Exp/index.html#type-t">IR.Exp.t</a> * <a href="../../IR/Typ/index.html#type-t">IR.Typ.t</a>)</span> option</span>;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>needed for translating <code>OpaqueValueExpr</code> nodes</p><span class="comment-delim">*)</span></td></tr><tr id="type-trans_state.is_fst_arg_objc_instance_method_call" class="anchored"><td class="def record field"><a href="#type-trans_state.is_fst_arg_objc_instance_method_call" class="anchor"></a><code><span>is_fst_arg_objc_instance_method_call : bool;</span></code></td></tr><tr id="type-trans_state.passed_as_noescape_block_to" class="anchored"><td class="def record field"><a href="#type-trans_state.passed_as_noescape_block_to" class="anchor"></a><code><span>passed_as_noescape_block_to : <span><a href="../../IR/Procname/index.html#type-t">IR.Procname.t</a> option</span>;</span></code></td></tr></table><code><span>}</span></code></div><div class="spec-doc"><p>The input of the translation constructed from enclosing expressions.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-pp_trans_state" class="anchored"><a href="#val-pp_trans_state" class="anchor"></a><code><span><span class="keyword">val</span> pp_trans_state : <span><span class="xref-unresolved">F</span>.formatter <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-trans_state">trans_state</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-default_trans_state" class="anchored"><a href="#val-default_trans_state" class="anchor"></a><code><span><span class="keyword">val</span> default_trans_state : <span><a href="../CContext/index.html#type-t">CContext.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-trans_state">trans_state</a></span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-control" class="anchored"><a href="#type-control" class="anchor"></a><code><span><span class="keyword">type</span> control</span><span> = </span><span>{</span></code><table><tr id="type-control.root_nodes" class="anchored"><td class="def record field"><a href="#type-control.root_nodes" class="anchor"></a><code><span>root_nodes : <span><a href="../../IR/Procdesc/Node/index.html#type-t">IR.Procdesc.Node.t</a> list</span>;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Top cfg nodes (root) created by the translation</p><span class="comment-delim">*)</span></td></tr><tr id="type-control.leaf_nodes" class="anchored"><td class="def record field"><a href="#type-control.leaf_nodes" class="anchor"></a><code><span>leaf_nodes : <span><a href="../../IR/Procdesc/Node/index.html#type-t">IR.Procdesc.Node.t</a> list</span>;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Bottom cfg nodes (leaf) created by the translate</p><span class="comment-delim">*)</span></td></tr><tr id="type-control.instrs" class="anchored"><td class="def record field"><a href="#type-control.instrs" class="anchor"></a><code><span>instrs : <span><a href="../../IR/Sil/index.html#type-instr">IR.Sil.instr</a> list</span>;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Instructions that need to be placed in the current CFG node being constructed, *after* <code>leaf_nodes</code>.</p><span class="comment-delim">*)</span></td></tr><tr id="type-control.initd_exps" class="anchored"><td class="def record field"><a href="#type-control.initd_exps" class="anchor"></a><code><span>initd_exps : <span><a href="../../IR/Exp/index.html#type-t">IR.Exp.t</a> list</span>;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>list of expressions that are initialized by the instructions</p><span class="comment-delim">*)</span></td></tr><tr id="type-control.cxx_temporary_markers_set" class="anchored"><td class="def record field"><a href="#type-control.cxx_temporary_markers_set" class="anchor"></a><code><span>cxx_temporary_markers_set : <span><a href="../../IR/Pvar/index.html#type-t">IR.Pvar.t</a> list</span>;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>markers for C++ temporaries that have been set during the translation; used to avoid adding the same marker several times</p><span class="comment-delim">*)</span></td></tr></table><code><span>}</span></code></div><div class="spec-doc"><p>Part of the translation result that is (loosely) related to control flow graph construction. More importantly, this is the part of a <code>trans_result</code> that some internal translation functions work on when constructing a <code>trans_result</code> before the other components of the translation result are available (such as the return expression). This is made into a separate type to make intermediate computations easier to write and easier to typecheck.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-pp_control" class="anchored"><a href="#val-pp_control" class="anchor"></a><code><span><span class="keyword">val</span> pp_control : <span><span class="xref-unresolved">F</span>.formatter <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-control">control</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-trans_result" class="anchored"><a href="#type-trans_result" class="anchor"></a><code><span><span class="keyword">type</span> trans_result</span><span> = </span><span>{</span></code><table><tr id="type-trans_result.control" class="anchored"><td class="def record field"><a href="#type-trans_result.control" class="anchor"></a><code><span>control : <a href="#type-control">control</a>;</span></code></td></tr><tr id="type-trans_result.return" class="anchored"><td class="def record field"><a href="#type-trans_result.return" class="anchor"></a><code><span>return : <a href="../../IR/Exp/index.html#type-t">IR.Exp.t</a> * <a href="../../IR/Typ/index.html#type-t">IR.Typ.t</a>;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>value returned by the translated statement</p><span class="comment-delim">*)</span></td></tr><tr id="type-trans_result.method_name" class="anchored"><td class="def record field"><a href="#type-trans_result.method_name" class="anchor"></a><code><span>method_name : <span><a href="../../IR/Procname/index.html#type-t">IR.Procname.t</a> option</span>;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>in the specific case of translating a method call in C++, we get the method name called at the same time we get the <code>this</code> object that contains the method. The <code>this</code> instance object is returned as the <code>return</code> field, while the method to call is filled in here. This field is <code>None</code> in all other cases.</p><span class="comment-delim">*)</span></td></tr><tr id="type-trans_result.is_cpp_call_virtual" class="anchored"><td class="def record field"><a href="#type-trans_result.is_cpp_call_virtual" class="anchor"></a><code><span>is_cpp_call_virtual : bool;</span></code></td></tr></table><code><span>}</span></code></div><div class="spec-doc"><p>A translation result. It is returned by the translation function.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-empty_control" class="anchored"><a href="#val-empty_control" class="anchor"></a><code><span><span class="keyword">val</span> empty_control : <a href="#type-control">control</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-mk_trans_result" class="anchored"><a href="#val-mk_trans_result" class="anchor"></a><code><span><span class="keyword">val</span> mk_trans_result : <span>?method_name:<a href="../../IR/BuiltinDecl/index.html#type-t">IR.BuiltinDecl.t</a> <span class="arrow">&#45;&gt;</span></span> <span>?is_cpp_call_virtual:bool <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="../../IR/Exp/index.html#type-t">IR.Exp.t</a> * <a href="../../IR/Typ/index.html#type-t">IR.Typ.t</a>)</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-control">control</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-trans_result">trans_result</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-undefined_expression" class="anchored"><a href="#val-undefined_expression" class="anchor"></a><code><span><span class="keyword">val</span> undefined_expression : <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="../../IR/Exp/index.html#type-t">IR.Exp.t</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-collect_controls" class="anchored"><a href="#val-collect_controls" class="anchor"></a><code><span><span class="keyword">val</span> collect_controls : <span><a href="../../IR/Procdesc/index.html#type-t">IR.Procdesc.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-control">control</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-control">control</a></span></code></div><div class="spec-doc"><p>Collect the results of translating a list of instructions, and link up the nodes created.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-collect_trans_results" class="anchored"><a href="#val-collect_trans_results" class="anchor"></a><code><span><span class="keyword">val</span> collect_trans_results : <span><a href="../../IR/Procdesc/index.html#type-t">IR.Procdesc.t</a> <span class="arrow">&#45;&gt;</span></span> <span>return:<span>(<a href="../../IR/Exp/index.html#type-t">IR.Exp.t</a> * <a href="../../IR/Typ/index.html#type-t">IR.Typ.t</a>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-trans_result">trans_result</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-trans_result">trans_result</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-is_return_temp" class="anchored"><a href="#val-is_return_temp" class="anchor"></a><code><span><span class="keyword">val</span> is_return_temp : <span><span><a href="#type-continuation">continuation</a> option</span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-mk_cond_continuation" class="anchored"><a href="#val-mk_cond_continuation" class="anchor"></a><code><span><span class="keyword">val</span> mk_cond_continuation : <span><span><a href="#type-continuation">continuation</a> option</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-continuation">continuation</a> option</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-define_condition_side_effects" class="anchored"><a href="#val-define_condition_side_effects" class="anchor"></a><code><span><span class="keyword">val</span> define_condition_side_effects : <span><span>(<a href="../../IR/Exp/index.html#type-t">IR.Exp.t</a> * <a href="../../IR/Typ/index.html#type-t">IR.Typ.t</a>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="../../IR/Sil/index.html#type-instr">IR.Sil.instr</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../IBase/Location/index.html#type-t">IBase.Location.t</a> <span class="arrow">&#45;&gt;</span></span> <span>(<a href="../../IR/Exp/index.html#type-t">IR.Exp.t</a> * <a href="../../IR/Typ/index.html#type-t">IR.Typ.t</a>)</span> * <span><a href="../../IR/Sil/index.html#type-instr">IR.Sil.instr</a> list</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-source_range_of_stmt" class="anchored"><a href="#val-source_range_of_stmt" class="anchor"></a><code><span><span class="keyword">val</span> source_range_of_stmt : <span><a href="../../ATDGenerated/Clang_ast_t/index.html#type-stmt">ATDGenerated.Clang_ast_t.stmt</a> <span class="arrow">&#45;&gt;</span></span> <a href="../../ATDGenerated/Clang_ast_t/index.html#type-source_range">ATDGenerated.Clang_ast_t.source_range</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-extract_stmt_from_singleton" class="anchored"><a href="#val-extract_stmt_from_singleton" class="anchor"></a><code><span><span class="keyword">val</span> extract_stmt_from_singleton : <span><span><a href="../../ATDGenerated/Clang_ast_t/index.html#type-stmt">ATDGenerated.Clang_ast_t.stmt</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../ATDGenerated/Clang_ast_t/index.html#type-source_range">ATDGenerated.Clang_ast_t.source_range</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <a href="../../ATDGenerated/Clang_ast_t/index.html#type-stmt">ATDGenerated.Clang_ast_t.stmt</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-is_null_stmt" class="anchored"><a href="#val-is_null_stmt" class="anchor"></a><code><span><span class="keyword">val</span> is_null_stmt : <span><a href="../../ATDGenerated/Clang_ast_t/index.html#type-stmt">ATDGenerated.Clang_ast_t.stmt</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-dereference_var_sil" class="anchored"><a href="#val-dereference_var_sil" class="anchor"></a><code><span><span class="keyword">val</span> dereference_var_sil : <span><span>(<a href="../../IR/Exp/index.html#type-t">IR.Exp.t</a> * <a href="../../IR/Typ/index.html#type-t">IR.Typ.t</a>)</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../IBase/Location/index.html#type-t">IBase.Location.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="../../IR/Sil/index.html#type-instr">IR.Sil.instr</a> * <a href="../../IR/Exp/index.html#type-t">IR.Exp.t</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-dereference_value_from_result" class="anchored"><a href="#val-dereference_value_from_result" class="anchor"></a><code><span><span class="keyword">val</span> dereference_value_from_result : <span>?strip_pointer:bool <span class="arrow">&#45;&gt;</span></span> <span><a href="../../ATDGenerated/Clang_ast_t/index.html#type-source_range">ATDGenerated.Clang_ast_t.source_range</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../IBase/Location/index.html#type-t">IBase.Location.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-trans_result">trans_result</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-trans_result">trans_result</a></span></code></div><div class="spec-doc"><p>Given a <code>trans_result</code>, create a temporary variable with dereferenced value of an expression assigned to it</p></div></div><div class="odoc-spec"><div class="spec value" id="val-cast_operation" class="anchored"><a href="#val-cast_operation" class="anchor"></a><code><span><span class="keyword">val</span> cast_operation : <span>?objc_bridge_cast_kind:<a href="../../ATDGenerated/Clang_ast_t/index.html#type-obj_c_bridge_cast_kind">ATDGenerated.Clang_ast_t.obj_c_bridge_cast_kind</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../ATDGenerated/Clang_ast_t/index.html#type-cast_kind">ATDGenerated.Clang_ast_t.cast_kind</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="../../IR/Exp/index.html#type-t">IR.Exp.t</a> * <a href="../../IR/Typ/index.html#type-t">IR.Typ.t</a>)</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../IR/Typ/index.html#type-t">IR.Typ.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../IBase/Location/index.html#type-t">IBase.Location.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../IR/Sil/index.html#type-instr">IR.Sil.instr</a> list</span> * <span>(<a href="../../IR/Exp/index.html#type-t">IR.Exp.t</a> * <a href="../../IR/Typ/index.html#type-t">IR.Typ.t</a>)</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-trans_assertion" class="anchored"><a href="#val-trans_assertion" class="anchor"></a><code><span><span class="keyword">val</span> trans_assertion : <span><a href="#type-trans_state">trans_state</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../IBase/Location/index.html#type-t">IBase.Location.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-trans_result">trans_result</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-contains_opaque_value_expr" class="anchored"><a href="#val-contains_opaque_value_expr" class="anchor"></a><code><span><span class="keyword">val</span> contains_opaque_value_expr : <span><a href="../../ATDGenerated/Clang_ast_t/index.html#type-stmt">ATDGenerated.Clang_ast_t.stmt</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-builtin_trans" class="anchored"><a href="#val-builtin_trans" class="anchor"></a><code><span><span class="keyword">val</span> builtin_trans : <span><a href="#type-trans_state">trans_state</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../ATDGenerated/Clang_ast_t/index.html#type-source_range">ATDGenerated.Clang_ast_t.source_range</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../IBase/Location/index.html#type-t">IBase.Location.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-trans_result">trans_result</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../IR/Procname/index.html#type-t">IR.Procname.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-trans_result">trans_result</a> option</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-cxx_method_builtin_trans" class="anchored"><a href="#val-cxx_method_builtin_trans" class="anchor"></a><code><span><span class="keyword">val</span> cxx_method_builtin_trans : <span><a href="#type-trans_state">trans_state</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../ATDGenerated/Clang_ast_t/index.html#type-source_range">ATDGenerated.Clang_ast_t.source_range</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../IBase/Location/index.html#type-t">IBase.Location.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-trans_result">trans_result</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../IR/Procname/index.html#type-t">IR.Procname.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-trans_result">trans_result</a> option</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-new_or_alloc_trans" class="anchored"><a href="#val-new_or_alloc_trans" class="anchor"></a><code><span><span class="keyword">val</span> new_or_alloc_trans : <span><a href="#type-trans_state">trans_state</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../IBase/Location/index.html#type-t">IBase.Location.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../ATDGenerated/Clang_ast_t/index.html#type-stmt_info">ATDGenerated.Clang_ast_t.stmt_info</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../ATDGenerated/Clang_ast_t/index.html#type-qual_type">ATDGenerated.Clang_ast_t.qual_type</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="../../IR/Typ/Name/index.html#type-t">IR.Typ.Name.t</a> option</span> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <a href="#type-trans_result">trans_result</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-cpp_new_trans" class="anchored"><a href="#val-cpp_new_trans" class="anchor"></a><code><span><span class="keyword">val</span> cpp_new_trans : <span><a href="../../IR/Typ/IntegerWidths/index.html#type-t">IR.Typ.IntegerWidths.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../IBase/Location/index.html#type-t">IBase.Location.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../IR/Typ/index.html#type-t">IR.Typ.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="../../IR/Exp/index.html#type-t">IR.Exp.t</a> option</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<a href="../../IR/Exp/index.html#type-t">IR.Exp.t</a> * <a href="../../IR/Typ/index.html#type-t">IR.Typ.t</a>)</span> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-trans_result">trans_result</a></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Nodes" class="anchored"><a href="#module-Nodes" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Nodes/index.html">Nodes</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Module for creating cfg nodes and other utility functions related to them.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-PriorityNode" class="anchored"><a href="#module-PriorityNode" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="PriorityNode/index.html">PriorityNode</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>priority_node is used to enforce some kind of policy for creating nodes in the cfg. Certain elements of the AST _must_ create nodes therefore there is no need for them to use priority_node. Certain elements instead need or need not to create a node depending of certain factors. When an element of the latter kind wants to create a node it must claim priority first (like taking a lock). priority can be claimes only when it is free. If an element of AST succedes in claiming priority its id (pointer) is recorded in priority. After an element has finished it frees the priority. In general an AST element E checks if an ancestor has claimed priority. If priority is already claimed E does not have to create a node. If priority is free then it means E has to create the node. Then E claims priority and release it afterward.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-GotoLabel" class="anchored"><a href="#module-GotoLabel" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="GotoLabel/index.html">GotoLabel</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Module for translating goto instructions by keeping a map of labels.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Loops" class="anchored"><a href="#module-Loops" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Loops/index.html">Loops</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Module that provides utility functions for translating different types of loops.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Self" class="anchored"><a href="#module-Self" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="Self/index.html">Self</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>This module handles the translation of the variable self which is challenging because self is used both as a variable in instance method calls and also as a type in class method calls.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-is_logical_negation_of_int" class="anchored"><a href="#val-is_logical_negation_of_int" class="anchor"></a><code><span><span class="keyword">val</span> is_logical_negation_of_int : <span><a href="../../IR/Tenv/index.html#type-t">IR.Tenv.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../ATDGenerated/Clang_ast_t/index.html#type-expr_info">ATDGenerated.Clang_ast_t.expr_info</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../ATDGenerated/Clang_ast_t/index.html#type-unary_operator_info">ATDGenerated.Clang_ast_t.unary_operator_info</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-mk_fresh_void_exp_typ" class="anchored"><a href="#val-mk_fresh_void_exp_typ" class="anchor"></a><code><span><span class="keyword">val</span> mk_fresh_void_exp_typ : <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="../../IR/Exp/index.html#type-t">IR.Exp.t</a> * <a href="../../IR/Typ/index.html#type-t">IR.Typ.t</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-mk_fresh_void_id_typ" class="anchored"><a href="#val-mk_fresh_void_id_typ" class="anchor"></a><code><span><span class="keyword">val</span> mk_fresh_void_id_typ : <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="../../IR/Ident/index.html#type-t">IR.Ident.t</a> * <a href="../../IR/Typ/index.html#type-t">IR.Typ.t</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-mk_fresh_void_return" class="anchored"><a href="#val-mk_fresh_void_return" class="anchor"></a><code><span><span class="keyword">val</span> mk_fresh_void_return : <span>unit <span class="arrow">&#45;&gt;</span></span> <span>(<a href="../../IR/Ident/index.html#type-t">IR.Ident.t</a> * <a href="../../IR/Typ/index.html#type-t">IR.Typ.t</a>)</span> * <span>(<a href="../../IR/Exp/index.html#type-t">IR.Exp.t</a> * <a href="../../IR/Typ/index.html#type-t">IR.Typ.t</a>)</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-last_or_mk_fresh_void_exp_typ" class="anchored"><a href="#val-last_or_mk_fresh_void_exp_typ" class="anchor"></a><code><span><span class="keyword">val</span> last_or_mk_fresh_void_exp_typ : <span><span><span>(<a href="../../IR/Exp/index.html#type-t">IR.Exp.t</a> * <a href="../../IR/Typ/index.html#type-t">IR.Typ.t</a>)</span> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="../../IR/Exp/index.html#type-t">IR.Exp.t</a> * <a href="../../IR/Typ/index.html#type-t">IR.Typ.t</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-should_remove_first_param" class="anchored"><a href="#val-should_remove_first_param" class="anchor"></a><code><span><span class="keyword">val</span> should_remove_first_param : <span><a href="#type-trans_state">trans_state</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../ATDGenerated/Clang_ast_t/index.html#type-stmt">ATDGenerated.Clang_ast_t.stmt</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../IR/Typ/index.html#type-name">IR.Typ.name</a> option</span></span></code></div><div class="spec-doc"><p>Return a class name when the first parameter should be removed according to its context, for example, when <code>self</code> or <code>[x class]</code> is given as the first parameter for a class method.</p></div></div></div></body></html>