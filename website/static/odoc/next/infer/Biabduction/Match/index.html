<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Match (infer.Biabduction.Match)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">infer</a> &#x00BB; <a href="../index.html">Biabduction</a> &#x00BB; Match</nav><header class="odoc-preamble"><h1>Module <code><span>Biabduction.Match</span></code></h1></header><div class="odoc-content"><p>Implementation of &quot;Smart&quot; Pattern Matching for higher order singly-linked list predicate.</p><p>Used for detecting on a given program if some data scructures are matching some predefined higher-order list predicates. When it is the case, these predicates can be used as possible candidates for abstracting the data-structures. See <a href="http://dx.doi.org/10.1007/978-3-540-73368-3_22">CAV 2007</a> for the therory involved.</p><div class="odoc-spec"><div class="spec value" id="val-hpara_match_with_impl" class="anchored"><a href="#val-hpara_match_with_impl" class="anchor"></a><code><span><span class="keyword">val</span> hpara_match_with_impl : <span><a href="../../IR/Tenv/index.html#type-t">IR.Tenv.t</a> <span class="arrow">&#45;&gt;</span></span> <span>bool <span class="arrow">&#45;&gt;</span></span> <span><a href="../Predicates/index.html#type-hpara">Predicates.hpara</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Predicates/index.html#type-hpara">Predicates.hpara</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-hpara_dll_match_with_impl" class="anchored"><a href="#val-hpara_dll_match_with_impl" class="anchor"></a><code><span><span class="keyword">val</span> hpara_dll_match_with_impl : <span><a href="../../IR/Tenv/index.html#type-t">IR.Tenv.t</a> <span class="arrow">&#45;&gt;</span></span> <span>bool <span class="arrow">&#45;&gt;</span></span> <span><a href="../Predicates/index.html#type-hpara_dll">Predicates.hpara_dll</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Predicates/index.html#type-hpara_dll">Predicates.hpara_dll</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-hpred_pat" class="anchored"><a href="#type-hpred_pat" class="anchor"></a><code><span><span class="keyword">type</span> hpred_pat</span><span> = </span><span>{</span></code><table><tr id="type-hpred_pat.hpred" class="anchored"><td class="def record field"><a href="#type-hpred_pat.hpred" class="anchor"></a><code><span>hpred : <a href="../Predicates/index.html#type-hpred">Predicates.hpred</a>;</span></code></td></tr><tr id="type-hpred_pat.flag" class="anchored"><td class="def record field"><a href="#type-hpred_pat.flag" class="anchor"></a><code><span>flag : bool;</span></code></td></tr></table><code><span>}</span></code></div><div class="spec-doc"><p>Type for a hpred pattern. <code>flag=false</code> means that the implication between hpreds is not considered, and <code>flag = true</code> means that it is considered during pattern matching.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-sidecondition" class="anchored"><a href="#type-sidecondition" class="anchor"></a><code><span><span class="keyword">type</span> sidecondition</span><span> = <span><span><a href="../Prop/index.html#type-normal">Prop.normal</a> <a href="../Prop/index.html#type-t">Prop.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Predicates/index.html#type-subst">Predicates.subst</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-prop_match_with_impl" class="anchored"><a href="#val-prop_match_with_impl" class="anchor"></a><code><span><span class="keyword">val</span> prop_match_with_impl : <span><a href="../../IR/Tenv/index.html#type-t">IR.Tenv.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="../Prop/index.html#type-normal">Prop.normal</a> <a href="../Prop/index.html#type-t">Prop.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-sidecondition">sidecondition</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="../../IR/Ident/index.html#type-t">IR.Ident.t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-hpred_pat">hpred_pat</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-hpred_pat">hpred_pat</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="../Predicates/index.html#type-subst">Predicates.subst</a> * <span><a href="../Prop/index.html#type-normal">Prop.normal</a> <a href="../Prop/index.html#type-t">Prop.t</a></span>)</span> option</span></span></code></div><div class="spec-doc"><p><code>prop_match_with_impl p condition vars hpat hpats</code> returns <code>(subst, p_leftover)</code> such that</p><ol><li><code>dom(subst) = vars</code></li><li><code>p |- (hpat.hpred * hpats.hpred)[subst] * p_leftover</code>.</li></ol><p>Using the flag <code>field</code>, we can control the strength of |-.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-find_partial_iso" class="anchored"><a href="#val-find_partial_iso" class="anchor"></a><code><span><span class="keyword">val</span> find_partial_iso : <span><a href="../../IR/Tenv/index.html#type-t">IR.Tenv.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><a href="../../IR/Exp/index.html#type-t">IR.Exp.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../IR/Exp/index.html#type-t">IR.Exp.t</a> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<a href="../../IR/Exp/index.html#type-t">IR.Exp.t</a> * <a href="../../IR/Exp/index.html#type-t">IR.Exp.t</a>)</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<a href="../../IR/Exp/index.html#type-t">IR.Exp.t</a> * <a href="../../IR/Exp/index.html#type-t">IR.Exp.t</a>)</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="../Predicates/index.html#type-hpred">Predicates.hpred</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span>(<a href="../../IR/Exp/index.html#type-t">IR.Exp.t</a> * <a href="../../IR/Exp/index.html#type-t">IR.Exp.t</a>)</span> list</span> * <span><a href="../Predicates/index.html#type-hpred">Predicates.hpred</a> list</span> * <span><a href="../Predicates/index.html#type-hpred">Predicates.hpred</a> list</span> * <span><a href="../Predicates/index.html#type-hpred">Predicates.hpred</a> list</span>)</span> option</span></span></code></div><div class="spec-doc"><p><code>find_partial_iso</code> finds disjoint isomorphic sub-sigmas inside a given sigma. The first argument is an equality checker. The function returns a partial iso and three sigmas. The first sigma is the first copy of the two isomorphic sigmas, so it uses expressions in the domain of the returned isomorphism. The second is the second copy of the two isomorphic sigmas, and it uses expressions in the range of the isomorphism. The third is the unused part of the input sigma.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-hpara_iso" class="anchored"><a href="#val-hpara_iso" class="anchor"></a><code><span><span class="keyword">val</span> hpara_iso : <span><a href="../../IR/Tenv/index.html#type-t">IR.Tenv.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Predicates/index.html#type-hpara">Predicates.hpara</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Predicates/index.html#type-hpara">Predicates.hpara</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>hpara_iso</code> soundly checks whether two hparas are isomorphic.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-hpara_dll_iso" class="anchored"><a href="#val-hpara_dll_iso" class="anchor"></a><code><span><span class="keyword">val</span> hpara_dll_iso : <span><a href="../../IR/Tenv/index.html#type-t">IR.Tenv.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Predicates/index.html#type-hpara_dll">Predicates.hpara_dll</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Predicates/index.html#type-hpara_dll">Predicates.hpara_dll</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>hpara_dll_iso</code> soundly checks whether two hpara_dlls are isomorphic.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-hpara_create" class="anchored"><a href="#val-hpara_create" class="anchor"></a><code><span><span class="keyword">val</span> hpara_create : <span><a href="../../IR/Tenv/index.html#type-t">IR.Tenv.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<a href="../../IR/Exp/index.html#type-t">IR.Exp.t</a> * <a href="../../IR/Exp/index.html#type-t">IR.Exp.t</a>)</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="../Predicates/index.html#type-hpred">Predicates.hpred</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../IR/Exp/index.html#type-t">IR.Exp.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../IR/Exp/index.html#type-t">IR.Exp.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Predicates/index.html#type-hpara">Predicates.hpara</a> * <span><a href="../../IR/Exp/index.html#type-t">IR.Exp.t</a> list</span></span></code></div><div class="spec-doc"><p><code>hpara_create</code> takes a correspondence, and a sigma, a root and a next for the first part of this correspondence. Then, it creates a hpara and discovers a list of shared expressions that are passed as arguments to hpara. Both of them are returned as a result.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-hpara_dll_create" class="anchored"><a href="#val-hpara_dll_create" class="anchor"></a><code><span><span class="keyword">val</span> hpara_dll_create : <span><a href="../../IR/Tenv/index.html#type-t">IR.Tenv.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<a href="../../IR/Exp/index.html#type-t">IR.Exp.t</a> * <a href="../../IR/Exp/index.html#type-t">IR.Exp.t</a>)</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="../Predicates/index.html#type-hpred">Predicates.hpred</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../IR/Exp/index.html#type-t">IR.Exp.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../IR/Exp/index.html#type-t">IR.Exp.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../IR/Exp/index.html#type-t">IR.Exp.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Predicates/index.html#type-hpara_dll">Predicates.hpara_dll</a> * <span><a href="../../IR/Exp/index.html#type-t">IR.Exp.t</a> list</span></span></code></div><div class="spec-doc"><p><code>hpara_dll_create</code> takes a correspondence, and a sigma, a root, a blink and a flink for the first part of this correspondence. Then, it creates a hpara_dll and discovers a list of shared expressions that are passed as arguments to hpara. Both of them are returned as a result.</p></div></div></div></body></html>