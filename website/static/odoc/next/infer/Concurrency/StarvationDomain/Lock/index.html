<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Lock (infer.Concurrency.StarvationDomain.Lock)</title><link rel="stylesheet" href="../../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../index.html">infer</a> &#x00BB; <a href="../../index.html">Concurrency</a> &#x00BB; <a href="../index.html">StarvationDomain</a> &#x00BB; Lock</nav><header class="odoc-preamble"><h1>Module <code><span>StarvationDomain.Lock</span></code></h1><p>Abstract address for a lock. There are two notions of equality:</p><ul><li>Equality for comparing two addresses within the same thread/process/trace. Under this, identical globals and identical class objects compare equal. Locks represented by access paths rooted at method parameters must have equal access paths to compare equal. Paths rooted at locals are ignored.</li><li>Equality for comparing two addresses in two distinct threads/traces. Globals and class objects are compared in the same way, but locks represented by access paths rooted at parameters need only have equal access lists (ie <code>x.f.g == y.f.g</code>). This allows demonically aliasing parameters in *distinct* threads. This relation is used in <code>may_deadlock</code>.</li></ul></header><div class="odoc-content"><div class="odoc-include"><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <span class="keyword">module</span> <span class="keyword">type</span> <span class="keyword">of</span> <a href="../../AbstractAddress/index.html">AbstractAddress</a></span></code></summary><div class="odoc-spec"><div class="spec module" id="module-F" class="anchored"><a href="#module-F" class="anchor"></a><code><span><span class="keyword">module</span> </span><span>F</span><span> = <span class="xref-unresolved">Stdlib</span>.Format</span></code></div></div><p>Type meant to represent abstract addresses based on access paths. It currently distinguishes between paths</p><ul><li>rooted at formal parameters (these are identified by the parameter index and the path without the root variable, though that variable is kept for pretty printing);</li><li>rooted at global variables;</li><li>non access-path expressions representing class objects (java only).</li></ul><p>Notably, there are no addresses rooted at locals (because proving aliasing between those is difficult).</p><p>There are two notions of equality:</p><ul><li>Equality for comparing two addresses within the same thread/process/trace. Under this, identical globals and identical class objects compare equal. Parameter-rooted paths compare equal if their parameter indices, types and lists of accesses are equal.</li><li>Equality for comparing two addresses in two distinct threads/traces. Globals and class objects are compared in the same way, but parameter-rooted paths need only have equal access lists (ie <code>x.f.g == y.f.g</code>). This allows demonically aliasing parameters in *distinct* threads.</li></ul><div class="odoc-include"><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <a href="../../../IStdlib/PrettyPrintable/module-type-PrintableOrderedType/index.html">IStdlib.PrettyPrintable.PrintableOrderedType</a></span></code></summary><div class="odoc-include"><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <span class="xref-unresolved">IStdlib</span>.IStd.Caml.Set.OrderedType</span></code></summary><div class="odoc-spec"><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-compare" class="anchored"><a href="#val-compare" class="anchor"></a><code><span><span class="keyword">val</span> compare : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div></div></details></div><div class="odoc-include"><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <a href="../../../IStdlib/PrettyPrintable/module-type-PrintableType/index.html">IStdlib.PrettyPrintable.PrintableType</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <a href="../../../IStdlib/PrettyPrintable/module-type-PrintableType/index.html#type-t">t</a> := <a href="#type-t">t</a></span></span></code></summary><div class="odoc-spec"><div class="spec value" id="val-pp" class="anchored"><a href="#val-pp" class="anchor"></a><code><span><span class="keyword">val</span> pp : <span><a href="../../../IStdlib/PrettyPrintable/index.html">IStdlib.PrettyPrintable</a>.F.formatter <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div></details></div></details></div><div class="odoc-spec"><div class="spec value" id="val-describe" class="anchored"><a href="#val-describe" class="anchor"></a><code><span><span class="keyword">val</span> describe : <span><span class="xref-unresolved">F</span>.formatter <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>human readable description</p></div></div><div class="odoc-spec"><div class="spec value" id="val-equal" class="anchored"><a href="#val-equal" class="anchor"></a><code><span><span class="keyword">val</span> equal : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-equal_across_threads" class="anchored"><a href="#val-equal_across_threads" class="anchor"></a><code><span><span class="keyword">val</span> equal_across_threads : <span><a href="../../../IR/Tenv/index.html#type-t">IR.Tenv.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-root_class" class="anchored"><a href="#val-root_class" class="anchor"></a><code><span><span class="keyword">val</span> root_class : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../../IR/Typ/index.html#type-name">IR.Typ.name</a> option</span></span></code></div><div class="spec-doc"><p>Class of the root variable of the expression representing the address</p></div></div><div class="odoc-spec"><div class="spec value" id="val-get_typ" class="anchored"><a href="#val-get_typ" class="anchor"></a><code><span><span class="keyword">val</span> get_typ : <span><a href="../../../IR/Tenv/index.html#type-t">IR.Tenv.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../../IR/Typ/index.html#type-t">IR.Typ.t</a> option</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-make" class="anchored"><a href="#val-make" class="anchor"></a><code><span><span class="keyword">val</span> make : <span><a href="../../../Absint/FormalMap/index.html#type-t">Absint.FormalMap.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../../Absint/HilExp/index.html#type-t">Absint.HilExp.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> option</span></span></code></div><div class="spec-doc"><p>convert an expression to a canonical form for an address</p></div></div><div class="odoc-spec"><div class="spec value" id="val-is_class_object" class="anchored"><a href="#val-is_class_object" class="anchor"></a><code><span><span class="keyword">val</span> is_class_object : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>is the address a Java class object such as in <code>synchronized(MyClass.class){}</code> or <code>static synchronized void foo()</code></p></div></div><div class="odoc-spec"><div class="spec type" id="type-subst" class="anchored"><a href="#type-subst" class="anchor"></a><code><span><span class="keyword">type</span> subst</span></code></div><div class="spec-doc"><p>A substitution from formal position indices to address options. <code>None</code> is used to for actuals that cannot be resolved to an address (eg local-rooted paths or arithmetic expressions).</p></div></div><div class="odoc-spec"><div class="spec value" id="val-pp_subst" class="anchored"><a href="#val-pp_subst" class="anchor"></a><code><span><span class="keyword">val</span> pp_subst : <span><span class="xref-unresolved">F</span>.formatter <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-subst">subst</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-make_subst" class="anchored"><a href="#val-make_subst" class="anchor"></a><code><span><span class="keyword">val</span> make_subst : <span><a href="../../../Absint/FormalMap/index.html#type-t">Absint.FormalMap.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="../../../Absint/HilExp/index.html#type-t">Absint.HilExp.t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-subst">subst</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-apply_subst" class="anchored"><a href="#val-apply_subst" class="anchor"></a><code><span><span class="keyword">val</span> apply_subst : <span><a href="#type-subst">subst</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> option</span></span></code></div></div></details></div><div class="odoc-spec"><div class="spec value" id="val-pp_locks" class="anchored"><a href="#val-pp_locks" class="anchor"></a><code><span><span class="keyword">val</span> pp_locks : <span><span class="xref-unresolved">F</span>.formatter <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-make_java_synchronized" class="anchored"><a href="#val-make_java_synchronized" class="anchor"></a><code><span><span class="keyword">val</span> make_java_synchronized : <span><a href="../../../Absint/FormalMap/index.html#type-t">Absint.FormalMap.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../../IR/Procname/index.html#type-t">IR.Procname.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> option</span></span></code></div><div class="spec-doc"><p>create the monitor locked when entering a synchronized java method</p></div></div><div class="odoc-spec"><div class="spec value" id="val-compare_wrt_reporting" class="anchored"><a href="#val-compare_wrt_reporting" class="anchor"></a><code><span><span class="keyword">val</span> compare_wrt_reporting : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>a stable order for avoiding reporting deadlocks twice based on the root variable type</p></div></div></div></body></html>