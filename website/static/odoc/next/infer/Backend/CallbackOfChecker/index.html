<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>CallbackOfChecker (infer.Backend.CallbackOfChecker)</title><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.2.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">infer</a> &#x00BB; <a href="../index.html">Backend</a> &#x00BB; CallbackOfChecker</nav><header class="odoc-preamble"><h1>Module <code><span>Backend.CallbackOfChecker</span></code></h1><p>Conversions from checkers taking &quot;functional&quot; <a href="../../Absint/InterproceduralAnalysis/index.html#type-t"><code>Absint.InterproceduralAnalysis.t</code></a> et al. payloads to <a href="../Callbacks/index.html#type-proc_callback_t"><code>Callbacks.proc_callback_t</code></a> and friends.</p></header><div class="odoc-content"><div class="odoc-spec"><div class="spec value anchored" id="val-mk_interprocedural_field_t"><a href="#val-mk_interprocedural_field_t" class="anchor"></a><code><span><span class="keyword">val</span> mk_interprocedural_field_t : 
  <span><span><span>(<a href="../Payloads/index.html#type-t">Payloads.t</a>, <span><span><span class="type-var">'payload</span> option</span> <span class="xref-unresolved">IStdlib</span>.IStd.Lazy.t</span>)</span> <span class="xref-unresolved">IStdlib</span>.IStd.Field.t</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Callbacks/index.html#type-proc_callback_args">Callbacks.proc_callback_args</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?tenv:<a href="../../IR/Tenv/index.html#type-t">IR.Tenv.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>unit <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'payload</span> <a href="../../Absint/InterproceduralAnalysis/index.html#type-t">Absint.InterproceduralAnalysis.t</a></span> * <span><a href="../Summary/Stats/index.html#type-t">Summary.Stats.t</a> <a href="../../IStdlib/IStd/index.html#type-ref">IStdlib.IStd.ref</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-interprocedural"><a href="#val-interprocedural" class="anchor"></a><code><span><span class="keyword">val</span> interprocedural : 
  <span>f_analyze_dep:<span>(<span><span class="type-var">'payloads_orig</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'payloads</span> option</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span>get_payload:<span>(<span><a href="../Payloads/index.html#type-t">Payloads.t</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'payloads_orig</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span>set_payload:
    <span>(<span><a href="../Payloads/index.html#type-t">Payloads.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'payload_checker</span> <span class="xref-unresolved">IStdlib</span>.IStd.Lazy.t</span> <span class="arrow">&#45;&gt;</span></span> <a href="../Payloads/index.html#type-t">Payloads.t</a>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span><span class="type-var">'payloads</span> <a href="../../Absint/InterproceduralAnalysis/index.html#type-t">Absint.InterproceduralAnalysis.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'payload_checker</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <a href="../Callbacks/index.html#type-proc_callback_t">Callbacks.proc_callback_t</a></span></code></div><div class="spec-doc"><p>the general form of interprocedural checkers: can read and update several payloads, and massage analysis results (mostly used to join option types)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-interprocedural_with_field"><a href="#val-interprocedural_with_field" class="anchor"></a><code><span><span class="keyword">val</span> interprocedural_with_field : 
  <span><span><span>(<a href="../Payloads/index.html#type-t">Payloads.t</a>, <span><span><span class="type-var">'payload</span> option</span> <span class="xref-unresolved">IStdlib</span>.IStd.Lazy.t</span>)</span> <span class="xref-unresolved">IStdlib</span>.IStd.Field.t</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span><span class="type-var">'payload</span> <a href="../../Absint/InterproceduralAnalysis/index.html#type-t">Absint.InterproceduralAnalysis.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'payload</span> option</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <a href="../Callbacks/index.html#type-proc_callback_t">Callbacks.proc_callback_t</a></span></code></div><div class="spec-doc"><p><code>interprocedural_with_field field checker</code> expects <code>checker</code> to compute a payload (option) suitable for <code>field</code>, given an inter-procedural analysis of callees that computes the same payload type</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-interprocedural_with_field_and_specialization"><a href="#val-interprocedural_with_field_and_specialization" class="anchor"></a><code><span><span class="keyword">val</span> interprocedural_with_field_and_specialization : 
  <span><span><span>(<a href="../Payloads/index.html#type-t">Payloads.t</a>, <span><span><span class="type-var">'payload</span> option</span> <span class="xref-unresolved">IStdlib</span>.IStd.Lazy.t</span>)</span> <span class="xref-unresolved">IStdlib</span>.IStd.Field.t</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span>?specialization:<span>(<span class="type-var">'payload</span> * <a href="../../IR/Specialization/index.html#type-t">IR.Specialization.t</a>)</span> <span class="arrow">&#45;&gt;</span></span>
    <span><span><span class="type-var">'payload</span> <a href="../../Absint/InterproceduralAnalysis/index.html#type-t">Absint.InterproceduralAnalysis.t</a></span> <span class="arrow">&#45;&gt;</span></span>
    <span><span class="type-var">'payload</span> option</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <a href="../Callbacks/index.html#type-proc_callback_with_specialization_t">Callbacks.proc_callback_with_specialization_t</a></span></code></div><div class="spec-doc"><p>same as <code>interprocedural_with_field</code> but allowing specialization</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-make_is_already_specialized_test"><a href="#val-make_is_already_specialized_test" class="anchor"></a><code><span><span class="keyword">val</span> make_is_already_specialized_test : 
  <span><span><span>(<a href="../Payloads/index.html#type-t">Payloads.t</a>, <span><span><span class="type-var">'payload</span> option</span> <span class="xref-unresolved">IStdlib</span>.IStd.Lazy.t</span>)</span> <span class="xref-unresolved">IStdlib</span>.IStd.Field.t</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><a href="../../IR/Specialization/index.html#type-t">IR.Specialization.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'payload</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../IR/Specialization/index.html#type-t">IR.Specialization.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Summary/index.html#type-t">Summary.t</a> <span class="arrow">&#45;&gt;</span></span>
  bool</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-interprocedural_with_field_dependency"><a href="#val-interprocedural_with_field_dependency" class="anchor"></a><code><span><span class="keyword">val</span> interprocedural_with_field_dependency : 
  <span>dep_field:<span><span>(<a href="../Payloads/index.html#type-t">Payloads.t</a>, <span><span class="type-var">'payload_dep</span> <span class="xref-unresolved">IStdlib</span>.IStd.Lazy.t</span>)</span> <span class="xref-unresolved">IStdlib</span>.IStd.Field.t</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<a href="../Payloads/index.html#type-t">Payloads.t</a>, <span><span class="type-var">'payload</span> <span class="xref-unresolved">IStdlib</span>.IStd.Lazy.t</span>)</span> <span class="xref-unresolved">IStdlib</span>.IStd.Field.t</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span><span>(<span class="type-var">'payload</span> * <span class="type-var">'payload_dep</span>)</span> <a href="../../Absint/InterproceduralAnalysis/index.html#type-t">Absint.InterproceduralAnalysis.t</a></span> <span class="arrow">&#45;&gt;</span></span>
    <span><span class="type-var">'payload_dep</span> <span class="arrow">&#45;&gt;</span></span>
    <span class="type-var">'payload</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Callbacks/index.html#type-proc_callback_args">Callbacks.proc_callback_args</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="../Summary/index.html#type-t">Summary.t</a></span></code></div><div class="spec-doc"><p>An inter-procedural analysis that depends on the summary payload found by another one for a procedure to analyse the same procedure. The checker will be passed that payload dependency as an argument for the procedure being analysed. The <code>InterproceduralAnalysis</code> argument allows retrieving both the dependency payload and the &quot;current&quot; one on other procedures.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-interprocedural_file"><a href="#val-interprocedural_file" class="anchor"></a><code><span><span class="keyword">val</span> interprocedural_file : 
  <span><span><span>(<a href="../Payloads/index.html#type-t">Payloads.t</a>, <span><span><span class="type-var">'payload</span> option</span> <span class="xref-unresolved">IStdlib</span>.IStd.Lazy.t</span>)</span> <span class="xref-unresolved">IStdlib</span>.IStd.Field.t</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span><span class="type-var">'payload</span> <a href="../../Absint/InterproceduralAnalysis/index.html#type-file_t">Absint.InterproceduralAnalysis.file_t</a></span> <span class="arrow">&#45;&gt;</span></span> <a href="../../Absint/IssueLog/index.html#type-t">Absint.IssueLog.t</a>)</span> <span class="arrow">&#45;&gt;</span></span>
  <a href="../Callbacks/index.html#type-file_callback_t">Callbacks.file_callback_t</a></span></code></div><div class="spec-doc"><p><code>interprocedural_file field checker</code> expects <code>checker</code> to compute an <a href="../../Absint/IssueLog/index.html#type-t"><code>Absint.IssueLog.t</code></a> from the file-level analysis, given an inter-procedural analysis of dependencies that computes the payload type corresponding to <code>field</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-intraprocedural"><a href="#val-intraprocedural" class="anchor"></a><code><span><span class="keyword">val</span> intraprocedural : 
  <span><span>(<span><a href="../../Absint/IntraproceduralAnalysis/index.html#type-t">Absint.IntraproceduralAnalysis.t</a> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span>
  <a href="../Callbacks/index.html#type-proc_callback_t">Callbacks.proc_callback_t</a></span></code></div><div class="spec-doc"><p>runs a simple intra-procedural analysis (one that doesn't need the results of the analysis on any transitive dependencies to analyze a given procedure)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-intraprocedural_with_field_dependency"><a href="#val-intraprocedural_with_field_dependency" class="anchor"></a><code><span><span class="keyword">val</span> intraprocedural_with_field_dependency : 
  <span><span><span>(<a href="../Payloads/index.html#type-t">Payloads.t</a>, <span><span class="type-var">'payload</span> <span class="xref-unresolved">IStdlib</span>.IStd.Lazy.t</span>)</span> <span class="xref-unresolved">IStdlib</span>.IStd.Field.t</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><a href="../../Absint/IntraproceduralAnalysis/index.html#type-t">Absint.IntraproceduralAnalysis.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'payload</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span>
  <a href="../Callbacks/index.html#type-proc_callback_t">Callbacks.proc_callback_t</a></span></code></div><div class="spec-doc"><p>an intra-procedural analysis that depends on the summary payload found by another</p></div></div></div></body></html>