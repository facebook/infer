<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Absint__AbstractDomain (infer.Absint__AbstractDomain)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">infer</a> &#x00BB; Absint__AbstractDomain</nav><h1>Module <code>Absint__AbstractDomain</code></h1><nav class="toc"><ul><li><a href="#abstract-domains-and-domain-combinators">Abstract domains and domain combinators</a></li></ul></nav></header><section><header><h2 id="abstract-domains-and-domain-combinators"><a href="#abstract-domains-and-domain-combinators" class="anchor"></a>Abstract domains and domain combinators</h2></header><div class="spec module" id="module-Types"><a href="#module-Types" class="anchor"></a><code><span class="keyword">module</span> <a href="Types/index.html">Types</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module-type" id="module-type-NoJoin"><a href="#module-type-NoJoin" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-NoJoin/index.html">NoJoin</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module-type" id="module-type-S"><a href="#module-type-S" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-S/index.html">S</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></span></summary><dl><dt class="spec module" id="module-Empty"><a href="#module-Empty" class="anchor"></a><code><span class="keyword">module</span> <a href="Empty/index.html">Empty</a> : <a href="index.html#module-type-S">S</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="module-type-S/index.html#type-t">t</a> = unit</code></dt><dd><p>a trivial domain</p></dd></dl></details></div></div></div><dl><dt class="spec module-type" id="module-type-WithBottom"><a href="#module-type-WithBottom" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-WithBottom/index.html">WithBottom</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>A domain with an explicit bottom value</p></dd></dl><dl><dt class="spec module-type" id="module-type-WithTop"><a href="#module-type-WithTop" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-WithTop/index.html">WithTop</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>A domain with an explicit top value</p></dd></dl><dl><dt class="spec module" id="module-BottomLifted"><a href="#module-BottomLifted" class="anchor"></a><code><span class="keyword">module</span> <a href="BottomLifted/index.html">BottomLifted</a> : <span class="keyword">functor</span> (<a href="BottomLifted/argument-1-Domain/index.html">Domain</a> : <a href="index.html#module-type-S">S</a>) <span>&#45;&gt;</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Create a domain with Bottom element from a pre-domain</p></dd></dl><div class="spec module" id="module-BottomLiftedUtils"><a href="#module-BottomLiftedUtils" class="anchor"></a><code><span class="keyword">module</span> <a href="BottomLiftedUtils/index.html">BottomLiftedUtils</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec module" id="module-TopLifted"><a href="#module-TopLifted" class="anchor"></a><code><span class="keyword">module</span> <a href="TopLifted/index.html">TopLifted</a> : <span class="keyword">functor</span> (<a href="TopLifted/argument-1-Domain/index.html">Domain</a> : <a href="index.html#module-type-S">S</a>) <span>&#45;&gt;</span> <a href="index.html#module-type-WithTop">WithTop</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="TopLifted/index.html#type-t">t</a> = <span><a href="TopLifted/argument-1-Domain/index.html#type-t">Domain.t</a> <a href="Types/index.html#type-top_lifted">Types.top_lifted</a></span></code></dt><dd><p>Create a domain with Top element from a pre-domain</p></dd></dl><div class="spec module" id="module-TopLiftedUtils"><a href="#module-TopLiftedUtils" class="anchor"></a><code><span class="keyword">module</span> <a href="TopLiftedUtils/index.html">TopLiftedUtils</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec module" id="module-Pair"><a href="#module-Pair" class="anchor"></a><code><span class="keyword">module</span> <a href="Pair/index.html">Pair</a> : <span class="keyword">functor</span> (<a href="Pair/argument-1-Domain1/index.html">Domain1</a> : <a href="index.html#module-type-S">S</a>) <span>&#45;&gt;</span> <span class="keyword">functor</span> (<a href="Pair/argument-2-Domain2/index.html">Domain2</a> : <a href="index.html#module-type-S">S</a>) <span>&#45;&gt;</span> <a href="index.html#module-type-S">S</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="Pair/index.html#type-t">t</a> = <a href="Pair/argument-1-Domain1/index.html#type-t">Domain1.t</a> * <a href="Pair/argument-2-Domain2/index.html#type-t">Domain2.t</a></code></dt><dd><p>Cartesian product of two domains.</p></dd></dl><dl><dt class="spec module" id="module-Flat"><a href="#module-Flat" class="anchor"></a><code><span class="keyword">module</span> <a href="Flat/index.html">Flat</a> : <span class="keyword">functor</span> (<a href="Flat/argument-1-V/index.html">V</a> : <a href="../IStdlib/PrettyPrintable/index.html#module-type-PrintableEquatableType">IStdlib.PrettyPrintable.PrintableEquatableType</a>) <span>&#45;&gt;</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Flat abstract domain: Bottom, Top, and non-comparable elements in between</p></dd></dl><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></span></summary><dl><dt class="spec module" id="module-Stacked"><a href="#module-Stacked" class="anchor"></a><code><span class="keyword">module</span> <a href="Stacked/index.html">Stacked</a> : <span class="keyword">functor</span> (<a href="Stacked/argument-1-Below/index.html">Below</a> : <a href="index.html#module-type-S">S</a>) <span>&#45;&gt;</span> <span class="keyword">functor</span> (<a href="Stacked/argument-2-Val/index.html">Val</a> : <a href="index.html#module-type-S">S</a>) <span>&#45;&gt;</span> <span class="keyword">functor</span> (<a href="Stacked/argument-3-Above/index.html">Above</a> : <a href="index.html#module-type-S">S</a>) <span>&#45;&gt;</span> <a href="index.html#module-type-S">S</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="Stacked/index.html#type-t">t</a> = <span><span>(<a href="Stacked/argument-1-Below/index.html#type-t">Below.t</a>, <a href="Stacked/argument-2-Val/index.html#type-t">Val.t</a>, <a href="Stacked/argument-3-Above/index.html#type-t">Above.t</a>)</span> <a href="Types/index.html#type-below_above">Types.below_above</a></span></code></dt><dd><p>Stacked abstract domain: tagged union of <code>Below</code>, <code>Val</code>, and <code>Above</code> domains where all elements of <code>Below</code> are strictly smaller than all elements of <code>Val</code> which are strictly smaller than all elements of <code>Above</code></p></dd></dl></details></div></div></div><div class="spec module" id="module-StackedUtils"><a href="#module-StackedUtils" class="anchor"></a><code><span class="keyword">module</span> <a href="StackedUtils/index.html">StackedUtils</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec module" id="module-MinReprSet"><a href="#module-MinReprSet" class="anchor"></a><code><span class="keyword">module</span> <a href="MinReprSet/index.html">MinReprSet</a> : <span class="keyword">functor</span> (<a href="MinReprSet/argument-1-Element/index.html">Element</a> : <a href="../IStdlib/PrettyPrintable/index.html#module-type-PrintableOrderedType">IStdlib.PrettyPrintable.PrintableOrderedType</a>) <span>&#45;&gt;</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Abstracts a set of <code>Element</code>s by keeping its smallest representative only. The widening is terminating only if the order fulfills the descending chain condition.</p></dd></dl><div class="spec module-type" id="module-type-FiniteSetS"><a href="#module-type-FiniteSetS" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-FiniteSetS/index.html">FiniteSetS</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></span></summary><dl><dt class="spec module" id="module-FiniteSetOfPPSet"><a href="#module-FiniteSetOfPPSet" class="anchor"></a><code><span class="keyword">module</span> FiniteSetOfPPSet : <span class="keyword">functor</span> (<a href="FiniteSetOfPPSet/argument-1-PPSet/index.html">PPSet</a> : <a href="../IStdlib/PrettyPrintable/index.html#module-type-PPSet">IStdlib.PrettyPrintable.PPSet</a>) <span>&#45;&gt;</span> <a href="index.html#module-type-FiniteSetS">FiniteSetS</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="index.html#module-FiniteSetOfPPSet">FiniteSetOfPPSet</a>.elt = <a href="FiniteSetOfPPSet/index.html#argument-1-PPSet">PPSet</a>.elt</code></dt><dd><p>Lift a PPSet to a powerset domain ordered by subset. The elements of the set should be drawn from a *finite* collection of possible values, since the widening operator here is just union.</p></dd></dl></details></div></div></div><dl><dt class="spec module" id="module-FiniteSet"><a href="#module-FiniteSet" class="anchor"></a><code><span class="keyword">module</span> FiniteSet : <span class="keyword">functor</span> (<a href="FiniteSet/argument-1-Element/index.html">Element</a> : <a href="../IStdlib/PrettyPrintable/index.html#module-type-PrintableOrderedType">IStdlib.PrettyPrintable.PrintableOrderedType</a>) <span>&#45;&gt;</span> <a href="index.html#module-type-FiniteSetS">FiniteSetS</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="index.html#module-FiniteSet">FiniteSet</a>.elt = <a href="FiniteSet/index.html#argument-1-Element">Element</a>.t</code></dt><dd><p>Lift a set to a powerset domain ordered by subset. The elements of the set should be drawn from a *finite* collection of possible values, since the widening operator here is just union.</p></dd></dl><div class="spec module-type" id="module-type-InvertedSetS"><a href="#module-type-InvertedSetS" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-InvertedSetS/index.html">InvertedSetS</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec module" id="module-InvertedSet"><a href="#module-InvertedSet" class="anchor"></a><code><span class="keyword">module</span> InvertedSet : <span class="keyword">functor</span> (<a href="InvertedSet/argument-1-Element/index.html">Element</a> : <a href="../IStdlib/PrettyPrintable/index.html#module-type-PrintableOrderedType">IStdlib.PrettyPrintable.PrintableOrderedType</a>) <span>&#45;&gt;</span> <a href="index.html#module-type-InvertedSetS">InvertedSetS</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="index.html#module-InvertedSet">InvertedSet</a>.elt = <a href="InvertedSet/index.html#argument-1-Element">Element</a>.t</code></dt><dd><p>Lift a set to a powerset domain ordered by superset, so the join operator is intersection</p></dd></dl><div class="spec module-type" id="module-type-MapS"><a href="#module-type-MapS" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-MapS/index.html">MapS</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></span></summary><dl><dt class="spec module" id="module-MapOfPPMap"><a href="#module-MapOfPPMap" class="anchor"></a><code><span class="keyword">module</span> <a href="MapOfPPMap/index.html">MapOfPPMap</a> : <span class="keyword">functor</span> (<a href="MapOfPPMap/argument-1-PPMap/index.html">PPMap</a> : <a href="../IStdlib/PrettyPrintable/index.html#module-type-PPMap">IStdlib.PrettyPrintable.PPMap</a>) <span>&#45;&gt;</span> <span class="keyword">functor</span> (<a href="MapOfPPMap/argument-2-ValueDomain/index.html">ValueDomain</a> : <a href="index.html#module-type-S">S</a>) <span>&#45;&gt;</span> <a href="index.html#module-type-MapS">MapS</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="MapOfPPMap/index.html#type-key">key</a> = <a href="MapOfPPMap/index.html#argument-1-PPMap">PPMap</a>.key <span class="keyword">and</span> <span class="keyword">type</span> <a href="MapOfPPMap/index.html#type-value">value</a> = <a href="MapOfPPMap/argument-2-ValueDomain/index.html#type-t">ValueDomain.t</a> <span class="keyword">and</span> <span class="keyword">type</span> <a href="MapOfPPMap/index.html#type-t">t</a> = <span><a href="MapOfPPMap/argument-2-ValueDomain/index.html#type-t">ValueDomain.t</a> <a href="MapOfPPMap/index.html#argument-1-PPMap">PPMap</a>.t</span></code></dt><dd><p>Map domain ordered by union over the set of bindings, so the bottom element is the empty map. Every element implicitly maps to bottom unless it is explicitly bound to something else. Uses PPMap as the underlying map</p></dd></dl></details></div></div></div><dl><dt class="spec module" id="module-Map"><a href="#module-Map" class="anchor"></a><code><span class="keyword">module</span> <a href="Map/index.html">Map</a> : <span class="keyword">functor</span> (<a href="Map/argument-1-Key/index.html">Key</a> : <a href="../IStdlib/PrettyPrintable/index.html#module-type-PrintableOrderedType">IStdlib.PrettyPrintable.PrintableOrderedType</a>) <span>&#45;&gt;</span> <span class="keyword">functor</span> (<a href="Map/argument-2-ValueDomain/index.html">ValueDomain</a> : <a href="index.html#module-type-S">S</a>) <span>&#45;&gt;</span> <a href="index.html#module-type-MapS">MapS</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="Map/index.html#type-key">key</a> = <a href="Map/index.html#argument-1-Key">Key</a>.t <span class="keyword">and</span> <span class="keyword">type</span> <a href="Map/index.html#type-value">value</a> = <a href="Map/argument-2-ValueDomain/index.html#type-t">ValueDomain.t</a></code></dt><dd><p>Map domain ordered by union over the set of bindings, so the bottom element is the empty map. Every element implicitly maps to bottom unless it is explicitly bound to something else</p></dd></dl><div class="spec module-type" id="module-type-InvertedMapS"><a href="#module-type-InvertedMapS" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-InvertedMapS/index.html">InvertedMapS</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec module" id="module-InvertedMap"><a href="#module-InvertedMap" class="anchor"></a><code><span class="keyword">module</span> <a href="InvertedMap/index.html">InvertedMap</a> : <span class="keyword">functor</span> (<a href="InvertedMap/argument-1-Key/index.html">Key</a> : <a href="../IStdlib/PrettyPrintable/index.html#module-type-PrintableOrderedType">IStdlib.PrettyPrintable.PrintableOrderedType</a>) <span>&#45;&gt;</span> <span class="keyword">functor</span> (<a href="InvertedMap/argument-2-ValueDomain/index.html">ValueDomain</a> : <a href="index.html#module-type-S">S</a>) <span>&#45;&gt;</span> <a href="index.html#module-type-InvertedMapS">InvertedMapS</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="InvertedMap/index.html#type-key">key</a> = <a href="InvertedMap/index.html#argument-1-Key">Key</a>.t <span class="keyword">and</span> <span class="keyword">type</span> <a href="InvertedMap/index.html#type-value">value</a> = <a href="InvertedMap/argument-2-ValueDomain/index.html#type-t">ValueDomain.t</a></code></dt><dd><p>Map domain ordered by intersection over the set of bindings, so the top element is the empty map. Every element implictly maps to top unless it is explicitly bound to something else</p></dd></dl><dl><dt class="spec module" id="module-SafeInvertedMap"><a href="#module-SafeInvertedMap" class="anchor"></a><code><span class="keyword">module</span> <a href="SafeInvertedMap/index.html">SafeInvertedMap</a> : <span class="keyword">functor</span> (<a href="SafeInvertedMap/argument-1-Key/index.html">Key</a> : <a href="../IStdlib/PrettyPrintable/index.html#module-type-PrintableOrderedType">IStdlib.PrettyPrintable.PrintableOrderedType</a>) <span>&#45;&gt;</span> <span class="keyword">functor</span> (<a href="SafeInvertedMap/argument-2-ValueDomain/index.html">ValueDomain</a> : <a href="index.html#module-type-WithTop">WithTop</a>) <span>&#45;&gt;</span> <a href="index.html#module-type-InvertedMapS">InvertedMapS</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="SafeInvertedMap/index.html#type-key">key</a> = <a href="SafeInvertedMap/index.html#argument-1-Key">Key</a>.t <span class="keyword">and</span> <span class="keyword">type</span> <a href="SafeInvertedMap/index.html#type-value">value</a> = <a href="SafeInvertedMap/argument-2-ValueDomain/index.html#type-t">ValueDomain.t</a></code></dt><dd><p>Similar to <code>InvertedMap</code> but it guarantees that it has a canonical form. For example, both <code>{a -&gt; top_v}</code> and <code>empty</code> represent the same abstract value <code>top</code> in <code>InvertedMap</code>, but in this implementation, <code>top</code> is always implemented as <code>empty</code> by not adding the <code>top_v</code> explicitly.</p></dd></dl><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></span></summary><div class="spec module" id="module-FiniteMultiMap"><a href="#module-FiniteMultiMap" class="anchor"></a><code><span class="keyword">module</span> <a href="FiniteMultiMap/index.html">FiniteMultiMap</a> : <span class="keyword">functor</span> (<a href="FiniteMultiMap/argument-1-Key/index.html">Key</a> : <a href="../IStdlib/PrettyPrintable/index.html#module-type-PrintableOrderedType">IStdlib.PrettyPrintable.PrintableOrderedType</a>) <span>&#45;&gt;</span> <span class="keyword">functor</span> (<a href="FiniteMultiMap/argument-2-Value/index.html">Value</a> : <a href="../IStdlib/PrettyPrintable/index.html#module-type-PrintableOrderedType">IStdlib.PrettyPrintable.PrintableOrderedType</a>) <span>&#45;&gt;</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></details></div></div></div><dl><dt class="spec module" id="module-BooleanAnd"><a href="#module-BooleanAnd" class="anchor"></a><code><span class="keyword">module</span> <a href="BooleanAnd/index.html">BooleanAnd</a> : <a href="index.html#module-type-S">S</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="module-type-S/index.html#type-t">t</a> = bool</code></dt><dd><p>Boolean domain ordered by p || ~q. Useful when you want a boolean that's true only when it's true in both conditional branches.</p></dd></dl><dl><dt class="spec module" id="module-BooleanOr"><a href="#module-BooleanOr" class="anchor"></a><code><span class="keyword">module</span> <a href="BooleanOr/index.html">BooleanOr</a> : <a href="index.html#module-type-WithBottom">WithBottom</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="module-type-WithBottom/index.html#type-t">t</a> = bool</code></dt><dd><p>Boolean domain ordered by ~p || q. Useful when you want a boolean that's true only when it's true in one conditional branch.</p></dd></dl><div class="spec module-type" id="module-type-MaxCount"><a href="#module-type-MaxCount" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-MaxCount/index.html">MaxCount</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec module" id="module-CountDomain"><a href="#module-CountDomain" class="anchor"></a><code><span class="keyword">module</span> <a href="CountDomain/index.html">CountDomain</a> : <span class="keyword">functor</span> (<a href="CountDomain/argument-1-MaxCount/index.html">MaxCount</a> : <a href="index.html#module-type-MaxCount">MaxCount</a>) <span>&#45;&gt;</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Domain keeping a non-negative count with a bounded maximum value. The count can be only incremented and decremented.</p></dd></dl><dl><dt class="spec module" id="module-DownwardIntDomain"><a href="#module-DownwardIntDomain" class="anchor"></a><code><span class="keyword">module</span> <a href="DownwardIntDomain/index.html">DownwardIntDomain</a> : <span class="keyword">functor</span> (<a href="DownwardIntDomain/argument-1-MaxCount/index.html">MaxCount</a> : <a href="index.html#module-type-MaxCount">MaxCount</a>) <span>&#45;&gt;</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Domain keeping a non-negative count with a bounded maximum value. <code>join</code> is minimum and <code>top</code> is zero.</p></dd></dl></section></div></body></html>