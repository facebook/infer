<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Biabduction__Prop (infer.Biabduction__Prop)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">infer</a> &#x00BB; Biabduction__Prop</nav><h1>Module <code>Biabduction__Prop</code></h1><nav class="toc"><ul><li><a href="#basic-functions-for-propositions">Basic Functions for propositions</a></li><li><a href="#normalization">Normalization</a></li><li><a href="#compaction">Compaction</a></li><li><a href="#queries-about-propositions">Queries about propositions</a></li><li><a href="#functions-for-changing-and-generating-propositions">Functions for changing and generating propositions</a></li><li><a href="#functions-for-existentially-quantifying-and-unquantifying-variables">Functions for existentially quantifying and unquantifying variables</a></li><li><a href="#prop-iterators">Prop iterators</a></li><li><a href="#internal-modules">Internal modules</a></li></ul></nav></header><aside><p>Functions for Propositions (i.e., Symbolic Heaps)</p></aside><dl><dt class="spec type" id="type-normal"><a href="#type-normal" class="anchor"></a><code><span class="keyword">type</span> normal</code></dt><dd><p>kind for normal props, i.e. normalized</p></dd></dl><dl><dt class="spec type" id="type-exposed"><a href="#type-exposed" class="anchor"></a><code><span class="keyword">type</span> exposed</code></dt><dd><p>kind for exposed props</p></dd></dl><dl><dt class="spec type" id="type-sorted"><a href="#type-sorted" class="anchor"></a><code><span class="keyword">type</span> sorted</code></dt><dd><p>kind for sorted props</p></dd></dl><aside><p>Proposition.</p></aside><dl><dt class="spec type" id="type-pi"><a href="#type-pi" class="anchor"></a><code><span class="keyword">type</span> pi</code><code> = <span><a href="../Biabduction/Predicates/index.html#type-atom">Biabduction.Predicates.atom</a> list</span></code></dt><dt class="spec type" id="type-sigma"><a href="#type-sigma" class="anchor"></a><code><span class="keyword">type</span> sigma</code><code> = <span><a href="../Biabduction/Predicates/index.html#type-hpred">Biabduction.Predicates.hpred</a> list</span></code></dt><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> <span>'a t</span></code><code> = <span class="keyword">private</span> </code><code>{</code><table class="record"><tr id="type-t.sigma" class="anchored"><td class="def field"><a href="#type-t.sigma" class="anchor"></a><code>sigma : <a href="index.html#type-sigma">sigma</a>;</code></td><td class="doc"><p>spatial part</p></td></tr><tr id="type-t.sub" class="anchored"><td class="def field"><a href="#type-t.sub" class="anchor"></a><code>sub : <a href="../Biabduction/Predicates/index.html#type-subst">Biabduction.Predicates.subst</a>;</code></td><td class="doc"><p>substitution</p></td></tr><tr id="type-t.pi" class="anchored"><td class="def field"><a href="#type-t.pi" class="anchor"></a><code>pi : <a href="index.html#type-pi">pi</a>;</code></td><td class="doc"><p>pure part</p></td></tr><tr id="type-t.sigma_fp" class="anchored"><td class="def field"><a href="#type-t.sigma_fp" class="anchor"></a><code>sigma_fp : <a href="index.html#type-sigma">sigma</a>;</code></td><td class="doc"><p>abduced spatial part</p></td></tr><tr id="type-t.pi_fp" class="anchored"><td class="def field"><a href="#type-t.pi_fp" class="anchor"></a><code>pi_fp : <a href="index.html#type-pi">pi</a>;</code></td><td class="doc"><p>abduced pure part</p></td></tr></table><code>}</code></dt><dd><p>the kind 'a should range over <code>normal</code> and <code>exposed</code></p></dd></dl><div><div class="spec include"><div class="doc"><dl><dt class="spec value" id="val-compare"><a href="#val-compare" class="anchor"></a><code><span class="keyword">val</span> compare : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> int)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> int</code></dt></dl></div></div></div><dl><dt class="spec type" id="type-struct_init_mode"><a href="#type-struct_init_mode" class="anchor"></a><code><span class="keyword">type</span> struct_init_mode</code><code> = </code><table class="variant"><tr id="type-struct_init_mode.No_init" class="anchored"><td class="def constructor"><a href="#type-struct_init_mode.No_init" class="anchor"></a><code>| </code><code><span class="constructor">No_init</span></code></td></tr><tr id="type-struct_init_mode.Fld_init" class="anchored"><td class="def constructor"><a href="#type-struct_init_mode.Fld_init" class="anchor"></a><code>| </code><code><span class="constructor">Fld_init</span></code></td></tr></table></dt><dd><p>type to describe different strategies for initializing fields of a structure. <code>No_init</code> does not initialize any fields of the struct. <code>Fld_init</code> initializes the fields of the struct with fresh variables (C) or default values (Java).</p></dd></dl><section><header><h3 id="basic-functions-for-propositions"><a href="#basic-functions-for-propositions" class="anchor"></a>Basic Functions for propositions</h3></header><dl><dt class="spec value" id="val-has_footprint"><a href="#val-has_footprint" class="anchor"></a><code><span class="keyword">val</span> has_footprint : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> bool</code></dt><dd><p>sigma_fp is nonempty or pi_fp is nonempty</p></dd></dl><dl><dt class="spec value" id="val-compare_prop"><a href="#val-compare_prop" class="anchor"></a><code><span class="keyword">val</span> compare_prop : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> int</code></dt><dd><p>Compare propositions</p></dd></dl><dl><dt class="spec value" id="val-equal_sigma"><a href="#val-equal_sigma" class="anchor"></a><code><span class="keyword">val</span> equal_sigma : <a href="index.html#type-sigma">sigma</a> <span>&#45;&gt;</span> <a href="index.html#type-sigma">sigma</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Check the equality of two sigma's</p></dd></dl><dl><dt class="spec value" id="val-d_sub"><a href="#val-d_sub" class="anchor"></a><code><span class="keyword">val</span> d_sub : <a href="../Biabduction/Predicates/index.html#type-subst">Biabduction.Predicates.subst</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Dump a substitution.</p></dd></dl><dl><dt class="spec value" id="val-pp_pi"><a href="#val-pp_pi" class="anchor"></a><code><span class="keyword">val</span> pp_pi : <a href="../IStdlib/Pp/index.html#type-env">IStdlib.Pp.env</a> <span>&#45;&gt;</span> Stdlib.Format.formatter <span>&#45;&gt;</span> <a href="index.html#type-pi">pi</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Pretty print a pi.</p></dd></dl><dl><dt class="spec value" id="val-d_pi"><a href="#val-d_pi" class="anchor"></a><code><span class="keyword">val</span> d_pi : <a href="index.html#type-pi">pi</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Dump a pi.</p></dd></dl><dl><dt class="spec value" id="val-d_sigma"><a href="#val-d_sigma" class="anchor"></a><code><span class="keyword">val</span> d_sigma : <a href="index.html#type-sigma">sigma</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Dump a sigma.</p></dd></dl><dl><dt class="spec value" id="val-d_pi_sigma"><a href="#val-d_pi_sigma" class="anchor"></a><code><span class="keyword">val</span> d_pi_sigma : <a href="index.html#type-pi">pi</a> <span>&#45;&gt;</span> <a href="index.html#type-sigma">sigma</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Dump a pi and a sigma</p></dd></dl><dl><dt class="spec value" id="val-sigma_get_stack_nonstack"><a href="#val-sigma_get_stack_nonstack" class="anchor"></a><code><span class="keyword">val</span> sigma_get_stack_nonstack : bool <span>&#45;&gt;</span> <a href="index.html#type-sigma">sigma</a> <span>&#45;&gt;</span> <a href="index.html#type-sigma">sigma</a> * <a href="index.html#type-sigma">sigma</a></code></dt><dd><p>Split sigma into stack and nonstack parts. The boolean indicates whether the stack should only include local variales.</p></dd></dl><dl><dt class="spec value" id="val-prop_update_obj_sub"><a href="#val-prop_update_obj_sub" class="anchor"></a><code><span class="keyword">val</span> prop_update_obj_sub : <a href="../IStdlib/Pp/index.html#type-env">IStdlib.Pp.env</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <a href="../IStdlib/Pp/index.html#type-env">IStdlib.Pp.env</a></code></dt><dd><p>Update the object substitution given the stack variables in the prop</p></dd></dl><dl><dt class="spec value" id="val-pp_prop"><a href="#val-pp_prop" class="anchor"></a><code><span class="keyword">val</span> pp_prop : <a href="../IStdlib/Pp/index.html#type-env">IStdlib.Pp.env</a> <span>&#45;&gt;</span> Stdlib.Format.formatter <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Pretty print a proposition.</p></dd></dl><dl><dt class="spec value" id="val-prop_pred_env"><a href="#val-prop_pred_env" class="anchor"></a><code><span class="keyword">val</span> prop_pred_env : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <a href="../Biabduction/Predicates/Env/index.html#type-t">Biabduction.Predicates.Env.t</a></code></dt><dd><p>Create a predicate environment for a prop</p></dd></dl><dl><dt class="spec value" id="val-d_prop"><a href="#val-d_prop" class="anchor"></a><code><span class="keyword">val</span> d_prop : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Dump a proposition.</p></dd></dl><dl><dt class="spec value" id="val-d_proplist_with_typ"><a href="#val-d_proplist_with_typ" class="anchor"></a><code><span class="keyword">val</span> d_proplist_with_typ : <span><span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> list</span> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-max_stamp"><a href="#val-max_stamp" class="anchor"></a><code><span class="keyword">val</span> max_stamp : <span>?&#8288;f:<span>(<a href="../IR/Ident/index.html#type-t">IR.Ident.t</a> <span>&#45;&gt;</span> bool)</span></span> <span>&#45;&gt;</span> <span><a href="index.html#type-normal">normal</a> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> int</code></dt><dt class="spec value" id="val-pi_free_vars"><a href="#val-pi_free_vars" class="anchor"></a><code><span class="keyword">val</span> pi_free_vars : <a href="index.html#type-pi">pi</a> <span>&#45;&gt;</span> <span><a href="../IR/Ident/index.html#type-t">IR.Ident.t</a> <a href="../IStdlib/index.html#module-IStd">IStdlib.IStd</a>.Sequence.t</span></code></dt><dt class="spec value" id="val-sigma_free_vars"><a href="#val-sigma_free_vars" class="anchor"></a><code><span class="keyword">val</span> sigma_free_vars : <a href="index.html#type-sigma">sigma</a> <span>&#45;&gt;</span> <span><a href="../IR/Ident/index.html#type-t">IR.Ident.t</a> <a href="../IStdlib/index.html#module-IStd">IStdlib.IStd</a>.Sequence.t</span></code></dt><dt class="spec value" id="val-free_vars"><a href="#val-free_vars" class="anchor"></a><code><span class="keyword">val</span> free_vars : <span><a href="index.html#type-normal">normal</a> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><a href="../IR/Ident/index.html#type-t">IR.Ident.t</a> <a href="../IStdlib/index.html#module-IStd">IStdlib.IStd</a>.Sequence.t</span></code></dt><dt class="spec value" id="val-gen_free_vars"><a href="#val-gen_free_vars" class="anchor"></a><code><span class="keyword">val</span> gen_free_vars : <span><a href="index.html#type-normal">normal</a> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(unit,Â <a href="../IR/Ident/index.html#type-t">IR.Ident.t</a>)</span> <a href="../IStdlib/index.html#module-IStd">IStdlib.IStd</a>.Sequence.Generator.t</span></code></dt><dt class="spec value" id="val-sorted_gen_free_vars"><a href="#val-sorted_gen_free_vars" class="anchor"></a><code><span class="keyword">val</span> sorted_gen_free_vars : <span><a href="index.html#type-sorted">sorted</a> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(unit,Â <a href="../IR/Ident/index.html#type-t">IR.Ident.t</a>)</span> <a href="../IStdlib/index.html#module-IStd">IStdlib.IStd</a>.Sequence.Generator.t</span></code></dt><dt class="spec value" id="val-non_pure_free_vars"><a href="#val-non_pure_free_vars" class="anchor"></a><code><span class="keyword">val</span> non_pure_free_vars : <span><a href="index.html#type-normal">normal</a> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><a href="../IR/Ident/index.html#type-t">IR.Ident.t</a> <a href="../IStdlib/index.html#module-IStd">IStdlib.IStd</a>.Sequence.t</span></code></dt><dt class="spec value" id="val-dfs_sort"><a href="#val-dfs_sort" class="anchor"></a><code><span class="keyword">val</span> dfs_sort : <a href="../IR/Tenv/index.html#type-t">IR.Tenv.t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-normal">normal</a> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><a href="index.html#type-sorted">sorted</a> <a href="index.html#type-t">t</a></span></code></dt><dt class="spec value" id="val-pi_sub"><a href="#val-pi_sub" class="anchor"></a><code><span class="keyword">val</span> pi_sub : <a href="../Biabduction/Predicates/index.html#type-subst">Biabduction.Predicates.subst</a> <span>&#45;&gt;</span> <span><a href="../Biabduction/Predicates/index.html#type-atom">Biabduction.Predicates.atom</a> list</span> <span>&#45;&gt;</span> <span><a href="../Biabduction/Predicates/index.html#type-atom">Biabduction.Predicates.atom</a> list</span></code></dt><dd><p>Apply substitution for pi</p></dd></dl><dl><dt class="spec value" id="val-sigma_sub"><a href="#val-sigma_sub" class="anchor"></a><code><span class="keyword">val</span> sigma_sub : <a href="../Biabduction/Predicates/index.html#type-subst">Biabduction.Predicates.subst</a> <span>&#45;&gt;</span> <span><a href="../Biabduction/Predicates/index.html#type-hpred">Biabduction.Predicates.hpred</a> list</span> <span>&#45;&gt;</span> <span><a href="../Biabduction/Predicates/index.html#type-hpred">Biabduction.Predicates.hpred</a> list</span></code></dt><dd><p>Apply subsitution for sigma</p></dd></dl><dl><dt class="spec value" id="val-prop_sub"><a href="#val-prop_sub" class="anchor"></a><code><span class="keyword">val</span> prop_sub : <a href="../Biabduction/Predicates/index.html#type-subst">Biabduction.Predicates.subst</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><a href="index.html#type-exposed">exposed</a> <a href="index.html#type-t">t</a></span></code></dt><dd><p>Apply subsitution to prop. Result is not normalized.</p></dd></dl><dl><dt class="spec value" id="val-prop_expmap"><a href="#val-prop_expmap" class="anchor"></a><code><span class="keyword">val</span> prop_expmap : <span>(<a href="../IR/Exp/index.html#type-t">IR.Exp.t</a> <span>&#45;&gt;</span> <a href="../IR/Exp/index.html#type-t">IR.Exp.t</a>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><a href="index.html#type-exposed">exposed</a> <a href="index.html#type-t">t</a></span></code></dt><dd><p>Apply the substitution to all the expressions in the prop.</p></dd></dl><dl><dt class="spec value" id="val-sigma_replace_exp"><a href="#val-sigma_replace_exp" class="anchor"></a><code><span class="keyword">val</span> sigma_replace_exp : <a href="../IR/Tenv/index.html#type-t">IR.Tenv.t</a> <span>&#45;&gt;</span> <span><span>(<a href="../IR/Exp/index.html#type-t">IR.Exp.t</a> * <a href="../IR/Exp/index.html#type-t">IR.Exp.t</a>)</span> list</span> <span>&#45;&gt;</span> <span><a href="../Biabduction/Predicates/index.html#type-hpred">Biabduction.Predicates.hpred</a> list</span> <span>&#45;&gt;</span> <span><a href="../Biabduction/Predicates/index.html#type-hpred">Biabduction.Predicates.hpred</a> list</span></code></dt><dd><p>Relaces all expressions in the <code>hpred list</code> using the first argument. Assume that the first parameter defines a partial function. No expressions inside hpara are replaced.</p></dd></dl></section><section><header><h3 id="normalization"><a href="#normalization" class="anchor"></a>Normalization</h3></header><dl><dt class="spec value" id="val-mk_inequality"><a href="#val-mk_inequality" class="anchor"></a><code><span class="keyword">val</span> mk_inequality : <a href="../IR/Tenv/index.html#type-t">IR.Tenv.t</a> <span>&#45;&gt;</span> <a href="../IR/Exp/index.html#type-t">IR.Exp.t</a> <span>&#45;&gt;</span> <a href="../Biabduction/Predicates/index.html#type-atom">Biabduction.Predicates.atom</a></code></dt><dd><p>Turn an inequality expression into an atom</p></dd></dl><dl><dt class="spec value" id="val-atom_is_inequality"><a href="#val-atom_is_inequality" class="anchor"></a><code><span class="keyword">val</span> atom_is_inequality : <a href="../Biabduction/Predicates/index.html#type-atom">Biabduction.Predicates.atom</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Return <code>true</code> if the atom is an inequality</p></dd></dl><dl><dt class="spec value" id="val-atom_exp_le_const"><a href="#val-atom_exp_le_const" class="anchor"></a><code><span class="keyword">val</span> atom_exp_le_const : <a href="../Biabduction/Predicates/index.html#type-atom">Biabduction.Predicates.atom</a> <span>&#45;&gt;</span> <span><span>(<a href="../IR/Exp/index.html#type-t">IR.Exp.t</a> * <a href="../IR/IntLit/index.html#type-t">IR.IntLit.t</a>)</span> option</span></code></dt><dd><p>If the atom is <code>e&lt;=n</code> return <code>e,n</code></p></dd></dl><dl><dt class="spec value" id="val-atom_const_lt_exp"><a href="#val-atom_const_lt_exp" class="anchor"></a><code><span class="keyword">val</span> atom_const_lt_exp : <a href="../Biabduction/Predicates/index.html#type-atom">Biabduction.Predicates.atom</a> <span>&#45;&gt;</span> <span><span>(<a href="../IR/IntLit/index.html#type-t">IR.IntLit.t</a> * <a href="../IR/Exp/index.html#type-t">IR.Exp.t</a>)</span> option</span></code></dt><dd><p>If the atom is <code>n&lt;e</code> return <code>n,e</code></p></dd></dl><dl><dt class="spec value" id="val-exp_normalize_prop"><a href="#val-exp_normalize_prop" class="anchor"></a><code><span class="keyword">val</span> exp_normalize_prop : <span>?&#8288;destructive:bool</span> <span>&#45;&gt;</span> <a href="../IR/Tenv/index.html#type-t">IR.Tenv.t</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <a href="../IR/Exp/index.html#type-t">IR.Exp.t</a> <span>&#45;&gt;</span> <a href="../IR/Exp/index.html#type-t">IR.Exp.t</a></code></dt><dd><p>Normalize <code>exp</code> using the pure part of <code>prop</code>. Later, we should change this such that the normalization exposes offsets of <code>exp</code> as much as possible.</p><p>If <code>destructive</code> is true then normalize more aggressively, which may lose some useful structure or types.</p></dd></dl><dl><dt class="spec value" id="val-exp_normalize_noabs"><a href="#val-exp_normalize_noabs" class="anchor"></a><code><span class="keyword">val</span> exp_normalize_noabs : <a href="../IR/Tenv/index.html#type-t">IR.Tenv.t</a> <span>&#45;&gt;</span> <a href="../Biabduction/Predicates/index.html#type-subst">Biabduction.Predicates.subst</a> <span>&#45;&gt;</span> <a href="../IR/Exp/index.html#type-t">IR.Exp.t</a> <span>&#45;&gt;</span> <a href="../IR/Exp/index.html#type-t">IR.Exp.t</a></code></dt><dd><p>Normalize the expression without abstracting complex subexpressions</p></dd></dl><dl><dt class="spec value" id="val-exp_collapse_consecutive_indices_prop"><a href="#val-exp_collapse_consecutive_indices_prop" class="anchor"></a><code><span class="keyword">val</span> exp_collapse_consecutive_indices_prop : <a href="../IR/Typ/index.html#type-t">IR.Typ.t</a> <span>&#45;&gt;</span> <a href="../IR/Exp/index.html#type-t">IR.Exp.t</a> <span>&#45;&gt;</span> <a href="../IR/Exp/index.html#type-t">IR.Exp.t</a></code></dt><dd><p>Collapse consecutive indices that should be added. For instance, this function reduces <code>x[1][1]</code> to <code>x[2]</code>. The <code>typ</code> argument is used to ensure the soundness of this collapsing.</p></dd></dl><dl><dt class="spec value" id="val-lexp_normalize_prop"><a href="#val-lexp_normalize_prop" class="anchor"></a><code><span class="keyword">val</span> lexp_normalize_prop : <a href="../IR/Tenv/index.html#type-t">IR.Tenv.t</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <a href="../IR/Exp/index.html#type-t">IR.Exp.t</a> <span>&#45;&gt;</span> <a href="../IR/Exp/index.html#type-t">IR.Exp.t</a></code></dt><dd><p>Normalize <code>exp</code> used for the address of a heap cell. This normalization does not combine two offsets inside <code>exp</code>.</p></dd></dl><dl><dt class="spec value" id="val-atom_normalize_prop"><a href="#val-atom_normalize_prop" class="anchor"></a><code><span class="keyword">val</span> atom_normalize_prop : <a href="../IR/Tenv/index.html#type-t">IR.Tenv.t</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <a href="../Biabduction/Predicates/index.html#type-atom">Biabduction.Predicates.atom</a> <span>&#45;&gt;</span> <a href="../Biabduction/Predicates/index.html#type-atom">Biabduction.Predicates.atom</a></code></dt><dt class="spec value" id="val-sigma_normalize_prop"><a href="#val-sigma_normalize_prop" class="anchor"></a><code><span class="keyword">val</span> sigma_normalize_prop : <a href="../IR/Tenv/index.html#type-t">IR.Tenv.t</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><a href="../Biabduction/Predicates/index.html#type-hpred">Biabduction.Predicates.hpred</a> list</span> <span>&#45;&gt;</span> <span><a href="../Biabduction/Predicates/index.html#type-hpred">Biabduction.Predicates.hpred</a> list</span></code></dt><dt class="spec value" id="val-normalize"><a href="#val-normalize" class="anchor"></a><code><span class="keyword">val</span> normalize : <a href="../IR/Tenv/index.html#type-t">IR.Tenv.t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-exposed">exposed</a> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><a href="index.html#type-normal">normal</a> <a href="index.html#type-t">t</a></span></code></dt><dd><p>normalize a prop</p></dd></dl><dl><dt class="spec value" id="val-expose"><a href="#val-expose" class="anchor"></a><code><span class="keyword">val</span> expose : <span><span class="type-var">_</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><a href="index.html#type-exposed">exposed</a> <a href="index.html#type-t">t</a></span></code></dt><dd><p>expose a prop, no-op used to instantiate the sub-type relation</p></dd></dl></section><section><header><h3 id="compaction"><a href="#compaction" class="anchor"></a>Compaction</h3></header><dl><dt class="spec value" id="val-prop_compact"><a href="#val-prop_compact" class="anchor"></a><code><span class="keyword">val</span> prop_compact : <a href="../Biabduction/Predicates/index.html#type-sharing_env">Biabduction.Predicates.sharing_env</a> <span>&#45;&gt;</span> <span><a href="index.html#type-normal">normal</a> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><a href="index.html#type-normal">normal</a> <a href="index.html#type-t">t</a></span></code></dt><dd><p>Return a compact representation of the prop</p></dd></dl></section><section><header><h3 id="queries-about-propositions"><a href="#queries-about-propositions" class="anchor"></a>Queries about propositions</h3></header><dl><dt class="spec value" id="val-prop_is_emp"><a href="#val-prop_is_emp" class="anchor"></a><code><span class="keyword">val</span> prop_is_emp : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> bool</code></dt><dd><p>Check if the sigma part of the proposition is emp</p></dd></dl></section><section><header><h3 id="functions-for-changing-and-generating-propositions"><a href="#functions-for-changing-and-generating-propositions" class="anchor"></a>Functions for changing and generating propositions</h3></header><dl><dt class="spec value" id="val-mk_neq"><a href="#val-mk_neq" class="anchor"></a><code><span class="keyword">val</span> mk_neq : <a href="../IR/Tenv/index.html#type-t">IR.Tenv.t</a> <span>&#45;&gt;</span> <a href="../IR/Exp/index.html#type-t">IR.Exp.t</a> <span>&#45;&gt;</span> <a href="../IR/Exp/index.html#type-t">IR.Exp.t</a> <span>&#45;&gt;</span> <a href="../Biabduction/Predicates/index.html#type-atom">Biabduction.Predicates.atom</a></code></dt><dd><p>Construct a disequality.</p></dd></dl><dl><dt class="spec value" id="val-mk_eq"><a href="#val-mk_eq" class="anchor"></a><code><span class="keyword">val</span> mk_eq : <a href="../IR/Tenv/index.html#type-t">IR.Tenv.t</a> <span>&#45;&gt;</span> <a href="../IR/Exp/index.html#type-t">IR.Exp.t</a> <span>&#45;&gt;</span> <a href="../IR/Exp/index.html#type-t">IR.Exp.t</a> <span>&#45;&gt;</span> <a href="../Biabduction/Predicates/index.html#type-atom">Biabduction.Predicates.atom</a></code></dt><dd><p>Construct an equality.</p></dd></dl><dl><dt class="spec value" id="val-mk_pred"><a href="#val-mk_pred" class="anchor"></a><code><span class="keyword">val</span> mk_pred : <a href="../IR/Tenv/index.html#type-t">IR.Tenv.t</a> <span>&#45;&gt;</span> <a href="../IR/PredSymb/index.html#type-t">IR.PredSymb.t</a> <span>&#45;&gt;</span> <span><a href="../IR/Exp/index.html#type-t">IR.Exp.t</a> list</span> <span>&#45;&gt;</span> <a href="../Biabduction/Predicates/index.html#type-atom">Biabduction.Predicates.atom</a></code></dt><dd><p>Construct a positive pred.</p></dd></dl><dl><dt class="spec value" id="val-mk_npred"><a href="#val-mk_npred" class="anchor"></a><code><span class="keyword">val</span> mk_npred : <a href="../IR/Tenv/index.html#type-t">IR.Tenv.t</a> <span>&#45;&gt;</span> <a href="../IR/PredSymb/index.html#type-t">IR.PredSymb.t</a> <span>&#45;&gt;</span> <span><a href="../IR/Exp/index.html#type-t">IR.Exp.t</a> list</span> <span>&#45;&gt;</span> <a href="../Biabduction/Predicates/index.html#type-atom">Biabduction.Predicates.atom</a></code></dt><dd><p>Construct a negative pred.</p></dd></dl><dl><dt class="spec value" id="val-create_strexp_of_type"><a href="#val-create_strexp_of_type" class="anchor"></a><code><span class="keyword">val</span> create_strexp_of_type : <a href="../IR/Tenv/index.html#type-t">IR.Tenv.t</a> <span>&#45;&gt;</span> <a href="index.html#type-struct_init_mode">struct_init_mode</a> <span>&#45;&gt;</span> <a href="../IR/Typ/index.html#type-t">IR.Typ.t</a> <span>&#45;&gt;</span> <span><a href="../IR/Exp/index.html#type-t">IR.Exp.t</a> option</span> <span>&#45;&gt;</span> <a href="../Biabduction/Predicates/index.html#type-inst">Biabduction.Predicates.inst</a> <span>&#45;&gt;</span> <a href="../Biabduction/Predicates/index.html#type-strexp">Biabduction.Predicates.strexp</a></code></dt><dd><p>create a strexp of the given type, populating the structures if <code>expand_structs</code> is true</p></dd></dl><dl><dt class="spec value" id="val-mk_ptsto"><a href="#val-mk_ptsto" class="anchor"></a><code><span class="keyword">val</span> mk_ptsto : <a href="../IR/Tenv/index.html#type-t">IR.Tenv.t</a> <span>&#45;&gt;</span> <a href="../IR/Exp/index.html#type-t">IR.Exp.t</a> <span>&#45;&gt;</span> <a href="../Biabduction/Predicates/index.html#type-strexp">Biabduction.Predicates.strexp</a> <span>&#45;&gt;</span> <a href="../IR/Exp/index.html#type-t">IR.Exp.t</a> <span>&#45;&gt;</span> <a href="../Biabduction/Predicates/index.html#type-hpred">Biabduction.Predicates.hpred</a></code></dt><dd><p>Construct a pointsto.</p></dd></dl><dl><dt class="spec value" id="val-mk_ptsto_exp"><a href="#val-mk_ptsto_exp" class="anchor"></a><code><span class="keyword">val</span> mk_ptsto_exp : <a href="../IR/Tenv/index.html#type-t">IR.Tenv.t</a> <span>&#45;&gt;</span> <a href="index.html#type-struct_init_mode">struct_init_mode</a> <span>&#45;&gt;</span> <span>(<a href="../IR/Exp/index.html#type-t">IR.Exp.t</a> * <a href="../IR/Exp/index.html#type-t">IR.Exp.t</a> * <span><a href="../IR/Exp/index.html#type-t">IR.Exp.t</a> option</span>)</span> <span>&#45;&gt;</span> <a href="../Biabduction/Predicates/index.html#type-inst">Biabduction.Predicates.inst</a> <span>&#45;&gt;</span> <a href="../Biabduction/Predicates/index.html#type-hpred">Biabduction.Predicates.hpred</a></code></dt><dd><p>Construct a points-to predicate for an expression using either the provided expression <code>name</code> as base for fresh identifiers.</p></dd></dl><dl><dt class="spec value" id="val-mk_ptsto_lvar"><a href="#val-mk_ptsto_lvar" class="anchor"></a><code><span class="keyword">val</span> mk_ptsto_lvar : <a href="../IR/Tenv/index.html#type-t">IR.Tenv.t</a> <span>&#45;&gt;</span> <a href="index.html#type-struct_init_mode">struct_init_mode</a> <span>&#45;&gt;</span> <a href="../Biabduction/Predicates/index.html#type-inst">Biabduction.Predicates.inst</a> <span>&#45;&gt;</span> <span>(<a href="../IR/Pvar/index.html#type-t">IR.Pvar.t</a> * <a href="../IR/Exp/index.html#type-t">IR.Exp.t</a> * <span><a href="../IR/Exp/index.html#type-t">IR.Exp.t</a> option</span>)</span> <span>&#45;&gt;</span> <a href="../Biabduction/Predicates/index.html#type-hpred">Biabduction.Predicates.hpred</a></code></dt><dd><p>Construct a points-to predicate for a single program variable. If <code>expand_structs</code> is true, initialize the fields of structs with fresh variables.</p></dd></dl><dl><dt class="spec value" id="val-mk_lseg"><a href="#val-mk_lseg" class="anchor"></a><code><span class="keyword">val</span> mk_lseg : <a href="../IR/Tenv/index.html#type-t">IR.Tenv.t</a> <span>&#45;&gt;</span> <a href="../Biabduction/Predicates/index.html#type-lseg_kind">Biabduction.Predicates.lseg_kind</a> <span>&#45;&gt;</span> <a href="../Biabduction/Predicates/index.html#type-hpara">Biabduction.Predicates.hpara</a> <span>&#45;&gt;</span> <a href="../IR/Exp/index.html#type-t">IR.Exp.t</a> <span>&#45;&gt;</span> <a href="../IR/Exp/index.html#type-t">IR.Exp.t</a> <span>&#45;&gt;</span> <span><a href="../IR/Exp/index.html#type-t">IR.Exp.t</a> list</span> <span>&#45;&gt;</span> <a href="../Biabduction/Predicates/index.html#type-hpred">Biabduction.Predicates.hpred</a></code></dt><dd><p>Construct a lseg predicate</p></dd></dl><dl><dt class="spec value" id="val-mk_dllseg"><a href="#val-mk_dllseg" class="anchor"></a><code><span class="keyword">val</span> mk_dllseg : <a href="../IR/Tenv/index.html#type-t">IR.Tenv.t</a> <span>&#45;&gt;</span> <a href="../Biabduction/Predicates/index.html#type-lseg_kind">Biabduction.Predicates.lseg_kind</a> <span>&#45;&gt;</span> <a href="../Biabduction/Predicates/index.html#type-hpara_dll">Biabduction.Predicates.hpara_dll</a> <span>&#45;&gt;</span> <a href="../IR/Exp/index.html#type-t">IR.Exp.t</a> <span>&#45;&gt;</span> <a href="../IR/Exp/index.html#type-t">IR.Exp.t</a> <span>&#45;&gt;</span> <a href="../IR/Exp/index.html#type-t">IR.Exp.t</a> <span>&#45;&gt;</span> <a href="../IR/Exp/index.html#type-t">IR.Exp.t</a> <span>&#45;&gt;</span> <span><a href="../IR/Exp/index.html#type-t">IR.Exp.t</a> list</span> <span>&#45;&gt;</span> <a href="../Biabduction/Predicates/index.html#type-hpred">Biabduction.Predicates.hpred</a></code></dt><dd><p>Construct a dllseg predicate</p></dd></dl><dl><dt class="spec value" id="val-prop_emp"><a href="#val-prop_emp" class="anchor"></a><code><span class="keyword">val</span> prop_emp : <span><a href="index.html#type-normal">normal</a> <a href="index.html#type-t">t</a></span></code></dt><dd><p>Proposition <code>true /\ emp</code>.</p></dd></dl><dl><dt class="spec value" id="val-prop_reset_inst"><a href="#val-prop_reset_inst" class="anchor"></a><code><span class="keyword">val</span> prop_reset_inst : <span>(<a href="../Biabduction/Predicates/index.html#type-inst">Biabduction.Predicates.inst</a> <span>&#45;&gt;</span> <a href="../Biabduction/Predicates/index.html#type-inst">Biabduction.Predicates.inst</a>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><a href="index.html#type-exposed">exposed</a> <a href="index.html#type-t">t</a></span></code></dt><dd><p>Reset every inst in the prop using the given map</p></dd></dl><dl><dt class="spec value" id="val-prop_hpred_star"><a href="#val-prop_hpred_star" class="anchor"></a><code><span class="keyword">val</span> prop_hpred_star : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <a href="../Biabduction/Predicates/index.html#type-hpred">Biabduction.Predicates.hpred</a> <span>&#45;&gt;</span> <span><a href="index.html#type-exposed">exposed</a> <a href="index.html#type-t">t</a></span></code></dt><dd><p>Conjoin a heap predicate by separating conjunction.</p></dd></dl><dl><dt class="spec value" id="val-prop_sigma_star"><a href="#val-prop_sigma_star" class="anchor"></a><code><span class="keyword">val</span> prop_sigma_star : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><a href="../Biabduction/Predicates/index.html#type-hpred">Biabduction.Predicates.hpred</a> list</span> <span>&#45;&gt;</span> <span><a href="index.html#type-exposed">exposed</a> <a href="index.html#type-t">t</a></span></code></dt><dd><p>Conjoin a list of heap predicates by separating conjunction</p></dd></dl><dl><dt class="spec value" id="val-prop_atom_and"><a href="#val-prop_atom_and" class="anchor"></a><code><span class="keyword">val</span> prop_atom_and : <a href="../IR/Tenv/index.html#type-t">IR.Tenv.t</a> <span>&#45;&gt;</span> <span>?&#8288;footprint:bool</span> <span>&#45;&gt;</span> <span><a href="index.html#type-normal">normal</a> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <a href="../Biabduction/Predicates/index.html#type-atom">Biabduction.Predicates.atom</a> <span>&#45;&gt;</span> <span><a href="index.html#type-normal">normal</a> <a href="index.html#type-t">t</a></span></code></dt><dd><p>Conjoin a pure atomic predicate by normal conjunction.</p></dd></dl><dl><dt class="spec value" id="val-conjoin_eq"><a href="#val-conjoin_eq" class="anchor"></a><code><span class="keyword">val</span> conjoin_eq : <a href="../IR/Tenv/index.html#type-t">IR.Tenv.t</a> <span>&#45;&gt;</span> <span>?&#8288;footprint:bool</span> <span>&#45;&gt;</span> <a href="../IR/Exp/index.html#type-t">IR.Exp.t</a> <span>&#45;&gt;</span> <a href="../IR/Exp/index.html#type-t">IR.Exp.t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-normal">normal</a> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><a href="index.html#type-normal">normal</a> <a href="index.html#type-t">t</a></span></code></dt><dd><p>Conjoin <code>exp1</code>=<code>exp2</code> with a symbolic heap <code>prop</code>.</p></dd></dl><dl><dt class="spec value" id="val-conjoin_neq"><a href="#val-conjoin_neq" class="anchor"></a><code><span class="keyword">val</span> conjoin_neq : <a href="../IR/Tenv/index.html#type-t">IR.Tenv.t</a> <span>&#45;&gt;</span> <span>?&#8288;footprint:bool</span> <span>&#45;&gt;</span> <a href="../IR/Exp/index.html#type-t">IR.Exp.t</a> <span>&#45;&gt;</span> <a href="../IR/Exp/index.html#type-t">IR.Exp.t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-normal">normal</a> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><a href="index.html#type-normal">normal</a> <a href="index.html#type-t">t</a></span></code></dt><dd><p>Conjoin <code>exp1</code>!=<code>exp2</code> with a symbolic heap <code>prop</code>.</p></dd></dl><dl><dt class="spec value" id="val-get_pure"><a href="#val-get_pure" class="anchor"></a><code><span class="keyword">val</span> get_pure : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><a href="../Biabduction/Predicates/index.html#type-atom">Biabduction.Predicates.atom</a> list</span></code></dt><dd><p>Return the pure part of <code>prop</code>.</p></dd></dl><dl><dt class="spec value" id="val-prop_rename_primed_footprint_vars"><a href="#val-prop_rename_primed_footprint_vars" class="anchor"></a><code><span class="keyword">val</span> prop_rename_primed_footprint_vars : <a href="../IR/Tenv/index.html#type-t">IR.Tenv.t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-normal">normal</a> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><a href="index.html#type-normal">normal</a> <a href="index.html#type-t">t</a></span></code></dt><dd><p>Canonicalize the names of primed variables.</p></dd></dl><dl><dt class="spec value" id="val-extract_footprint"><a href="#val-extract_footprint" class="anchor"></a><code><span class="keyword">val</span> extract_footprint : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><a href="index.html#type-exposed">exposed</a> <a href="index.html#type-t">t</a></span></code></dt><dd><p>Extract the footprint and return it as a prop</p></dd></dl><dl><dt class="spec value" id="val-extract_spec"><a href="#val-extract_spec" class="anchor"></a><code><span class="keyword">val</span> extract_spec : <span><a href="index.html#type-normal">normal</a> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><a href="index.html#type-normal">normal</a> <a href="index.html#type-t">t</a></span> * <span><a href="index.html#type-normal">normal</a> <a href="index.html#type-t">t</a></span></code></dt><dd><p>Extract the (footprint,current) pair</p></dd></dl><dl><dt class="spec value" id="val-prop_expand"><a href="#val-prop_expand" class="anchor"></a><code><span class="keyword">val</span> prop_expand : <a href="../IR/Tenv/index.html#type-t">IR.Tenv.t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-normal">normal</a> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span><a href="index.html#type-normal">normal</a> <a href="index.html#type-t">t</a></span> list</span></code></dt><dd><p>Expand PE listsegs if the flag is on.</p></dd></dl></section><section><header><h3 id="functions-for-existentially-quantifying-and-unquantifying-variables"><a href="#functions-for-existentially-quantifying-and-unquantifying-variables" class="anchor"></a>Functions for existentially quantifying and unquantifying variables</h3></header><dl><dt class="spec value" id="val-exist_quantify"><a href="#val-exist_quantify" class="anchor"></a><code><span class="keyword">val</span> exist_quantify : <a href="../IR/Tenv/index.html#type-t">IR.Tenv.t</a> <span>&#45;&gt;</span> <span>?&#8288;ids_queue:<span>unit <a href="../IR__Ident/index.html#module-HashQueue">IR.Ident.HashQueue</a>.t</span></span> <span>&#45;&gt;</span> <span><a href="../IR/Ident/index.html#type-t">IR.Ident.t</a> list</span> <span>&#45;&gt;</span> <span><a href="index.html#type-normal">normal</a> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><a href="index.html#type-normal">normal</a> <a href="index.html#type-t">t</a></span></code></dt><dd><p>Existentially quantify the <code>ids</code> in <code>prop</code>.</p></dd></dl><dl><dt class="spec value" id="val-prop_normal_vars_to_primed_vars"><a href="#val-prop_normal_vars_to_primed_vars" class="anchor"></a><code><span class="keyword">val</span> prop_normal_vars_to_primed_vars : <a href="../IR/Tenv/index.html#type-t">IR.Tenv.t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-normal">normal</a> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><a href="index.html#type-normal">normal</a> <a href="index.html#type-t">t</a></span></code></dt><dd><p>convert the footprint vars to primed vars.</p></dd></dl><dl><dt class="spec value" id="val-prop_primed_vars_to_normal_vars"><a href="#val-prop_primed_vars_to_normal_vars" class="anchor"></a><code><span class="keyword">val</span> prop_primed_vars_to_normal_vars : <a href="../IR/Tenv/index.html#type-t">IR.Tenv.t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-normal">normal</a> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><a href="index.html#type-normal">normal</a> <a href="index.html#type-t">t</a></span></code></dt><dd><p>convert the primed vars to normal vars.</p></dd></dl><dl><dt class="spec value" id="val-from_pi"><a href="#val-from_pi" class="anchor"></a><code><span class="keyword">val</span> from_pi : <a href="index.html#type-pi">pi</a> <span>&#45;&gt;</span> <span><a href="index.html#type-exposed">exposed</a> <a href="index.html#type-t">t</a></span></code></dt><dd><p>Build an exposed prop from pi</p></dd></dl><dl><dt class="spec value" id="val-from_sigma"><a href="#val-from_sigma" class="anchor"></a><code><span class="keyword">val</span> from_sigma : <a href="index.html#type-sigma">sigma</a> <span>&#45;&gt;</span> <span><a href="index.html#type-exposed">exposed</a> <a href="index.html#type-t">t</a></span></code></dt><dd><p>Build an exposed prop from sigma</p></dd></dl><dl><dt class="spec value" id="val-set"><a href="#val-set" class="anchor"></a><code><span class="keyword">val</span> set : <span>?&#8288;sub:<a href="../Biabduction/Predicates/index.html#type-subst">Biabduction.Predicates.subst</a></span> <span>&#45;&gt;</span> <span>?&#8288;pi:<a href="index.html#type-pi">pi</a></span> <span>&#45;&gt;</span> <span>?&#8288;sigma:<a href="index.html#type-sigma">sigma</a></span> <span>&#45;&gt;</span> <span>?&#8288;pi_fp:<a href="index.html#type-pi">pi</a></span> <span>&#45;&gt;</span> <span>?&#8288;sigma_fp:<a href="index.html#type-sigma">sigma</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><a href="index.html#type-exposed">exposed</a> <a href="index.html#type-t">t</a></span></code></dt><dd><p>Set individual fields of the prop.</p></dd></dl></section><section><header><h3 id="prop-iterators"><a href="#prop-iterators" class="anchor"></a>Prop iterators</h3></header><dl><dt class="spec type" id="type-prop_iter"><a href="#type-prop_iter" class="anchor"></a><code><span class="keyword">type</span> <span>'a prop_iter</span></code></dt><dd><p>Iterator over the sigma part. Each iterator has a current <code>hpred</code>.</p></dd></dl><dl><dt class="spec value" id="val-prop_iter_create"><a href="#val-prop_iter_create" class="anchor"></a><code><span class="keyword">val</span> prop_iter_create : <span><a href="index.html#type-normal">normal</a> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>unit <a href="index.html#type-prop_iter">prop_iter</a></span> option</span></code></dt><dd><p>Create an iterator, return None if sigma part is empty.</p></dd></dl><dl><dt class="spec value" id="val-prop_iter_to_prop"><a href="#val-prop_iter_to_prop" class="anchor"></a><code><span class="keyword">val</span> prop_iter_to_prop : <a href="../IR/Tenv/index.html#type-t">IR.Tenv.t</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-prop_iter">prop_iter</a></span> <span>&#45;&gt;</span> <span><a href="index.html#type-normal">normal</a> <a href="index.html#type-t">t</a></span></code></dt><dd><p>Return the prop associated to the iterator.</p></dd></dl><dl><dt class="spec value" id="val-prop_iter_add_atom"><a href="#val-prop_iter_add_atom" class="anchor"></a><code><span class="keyword">val</span> prop_iter_add_atom : bool <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-prop_iter">prop_iter</a></span> <span>&#45;&gt;</span> <a href="../Biabduction/Predicates/index.html#type-atom">Biabduction.Predicates.atom</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-prop_iter">prop_iter</a></span></code></dt><dd><p>Add an atom to the pi part of prop iter. The first parameter records whether it is done during footprint or during re - execution.</p></dd></dl><dl><dt class="spec value" id="val-prop_iter_remove_curr_then_to_prop"><a href="#val-prop_iter_remove_curr_then_to_prop" class="anchor"></a><code><span class="keyword">val</span> prop_iter_remove_curr_then_to_prop : <a href="../IR/Tenv/index.html#type-t">IR.Tenv.t</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-prop_iter">prop_iter</a></span> <span>&#45;&gt;</span> <span><a href="index.html#type-normal">normal</a> <a href="index.html#type-t">t</a></span></code></dt><dd><p>Remove the current element from the iterator, and return the prop associated to the resulting iterator.</p></dd></dl><dl><dt class="spec value" id="val-prop_iter_current"><a href="#val-prop_iter_current" class="anchor"></a><code><span class="keyword">val</span> prop_iter_current : <a href="../IR/Tenv/index.html#type-t">IR.Tenv.t</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-prop_iter">prop_iter</a></span> <span>&#45;&gt;</span> <a href="../Biabduction/Predicates/index.html#type-hpred">Biabduction.Predicates.hpred</a> * <span class="type-var">'a</span></code></dt><dd><p>Return the current hpred and state.</p></dd></dl><dl><dt class="spec value" id="val-prop_iter_next"><a href="#val-prop_iter_next" class="anchor"></a><code><span class="keyword">val</span> prop_iter_next : <span><span class="type-var">'a</span> <a href="index.html#type-prop_iter">prop_iter</a></span> <span>&#45;&gt;</span> <span><span>unit <a href="index.html#type-prop_iter">prop_iter</a></span> option</span></code></dt><dd><p>Return the next iterator.</p></dd></dl><dl><dt class="spec value" id="val-prop_iter_update_current"><a href="#val-prop_iter_update_current" class="anchor"></a><code><span class="keyword">val</span> prop_iter_update_current : <span><span class="type-var">'a</span> <a href="index.html#type-prop_iter">prop_iter</a></span> <span>&#45;&gt;</span> <a href="../Biabduction/Predicates/index.html#type-hpred">Biabduction.Predicates.hpred</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-prop_iter">prop_iter</a></span></code></dt><dd><p>Update the current element of the iterator.</p></dd></dl><dl><dt class="spec value" id="val-prop_iter_prev_then_insert"><a href="#val-prop_iter_prev_then_insert" class="anchor"></a><code><span class="keyword">val</span> prop_iter_prev_then_insert : <span><span class="type-var">'a</span> <a href="index.html#type-prop_iter">prop_iter</a></span> <span>&#45;&gt;</span> <a href="../Biabduction/Predicates/index.html#type-hpred">Biabduction.Predicates.hpred</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-prop_iter">prop_iter</a></span></code></dt><dd><p>Insert before the current element of the iterator.</p></dd></dl><dl><dt class="spec value" id="val-prop_iter_max_stamp"><a href="#val-prop_iter_max_stamp" class="anchor"></a><code><span class="keyword">val</span> prop_iter_max_stamp : <span>?&#8288;f:<span>(<a href="../IR/Ident/index.html#type-t">IR.Ident.t</a> <span>&#45;&gt;</span> bool)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-prop_iter">prop_iter</a></span> <span>&#45;&gt;</span> int</code></dt><dd><p>Find the maximum stamp of a free variable of a certain kind.</p></dd></dl><dl><dt class="spec value" id="val-prop_iter_get_footprint_sigma"><a href="#val-prop_iter_get_footprint_sigma" class="anchor"></a><code><span class="keyword">val</span> prop_iter_get_footprint_sigma : <span><span class="type-var">'a</span> <a href="index.html#type-prop_iter">prop_iter</a></span> <span>&#45;&gt;</span> <span><a href="../Biabduction/Predicates/index.html#type-hpred">Biabduction.Predicates.hpred</a> list</span></code></dt><dd><p>Extract the sigma part of the footprint</p></dd></dl><dl><dt class="spec value" id="val-prop_iter_replace_footprint_sigma"><a href="#val-prop_iter_replace_footprint_sigma" class="anchor"></a><code><span class="keyword">val</span> prop_iter_replace_footprint_sigma : <span><span class="type-var">'a</span> <a href="index.html#type-prop_iter">prop_iter</a></span> <span>&#45;&gt;</span> <span><a href="../Biabduction/Predicates/index.html#type-hpred">Biabduction.Predicates.hpred</a> list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-prop_iter">prop_iter</a></span></code></dt><dd><p>Replace the sigma part of the footprint</p></dd></dl><dl><dt class="spec value" id="val-prop_iter_find"><a href="#val-prop_iter_find" class="anchor"></a><code><span class="keyword">val</span> prop_iter_find : <span>unit <a href="index.html#type-prop_iter">prop_iter</a></span> <span>&#45;&gt;</span> <span>(<a href="../Biabduction/Predicates/index.html#type-hpred">Biabduction.Predicates.hpred</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> option</span>)</span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> <a href="index.html#type-prop_iter">prop_iter</a></span> option</span></code></dt><dd><p>Scan sigma to find an <code>hpred</code> satisfying the filter function.</p></dd></dl><dl><dt class="spec value" id="val-prop_iter_update_current_by_list"><a href="#val-prop_iter_update_current_by_list" class="anchor"></a><code><span class="keyword">val</span> prop_iter_update_current_by_list : <span><span class="type-var">'a</span> <a href="index.html#type-prop_iter">prop_iter</a></span> <span>&#45;&gt;</span> <span><a href="../Biabduction/Predicates/index.html#type-hpred">Biabduction.Predicates.hpred</a> list</span> <span>&#45;&gt;</span> <span>unit <a href="index.html#type-prop_iter">prop_iter</a></span></code></dt><dd><p>Update the current element of the iterator by a nonempty list of elements.</p></dd></dl><dl><dt class="spec value" id="val-prop_iter_set_state"><a href="#val-prop_iter_set_state" class="anchor"></a><code><span class="keyword">val</span> prop_iter_set_state : <span><span class="type-var">'a</span> <a href="index.html#type-prop_iter">prop_iter</a></span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> <a href="index.html#type-prop_iter">prop_iter</a></span></code></dt><dd><p>Set the state of an iterator</p></dd></dl><dl><dt class="spec value" id="val-prop_iter_make_id_primed"><a href="#val-prop_iter_make_id_primed" class="anchor"></a><code><span class="keyword">val</span> prop_iter_make_id_primed : <a href="../IR/Tenv/index.html#type-t">IR.Tenv.t</a> <span>&#45;&gt;</span> <a href="../IR/Ident/index.html#type-t">IR.Ident.t</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-prop_iter">prop_iter</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-prop_iter">prop_iter</a></span></code></dt><dd><p>Rename <code>ident</code> in <code>iter</code> by a fresh primed identifier</p></dd></dl><dl><dt class="spec value" id="val-prop_iter_gc_fields"><a href="#val-prop_iter_gc_fields" class="anchor"></a><code><span class="keyword">val</span> prop_iter_gc_fields : <span>unit <a href="index.html#type-prop_iter">prop_iter</a></span> <span>&#45;&gt;</span> <span>unit <a href="index.html#type-prop_iter">prop_iter</a></span></code></dt><dd><p>Collect garbage fields.</p></dd></dl></section><section><header><h3 id="internal-modules"><a href="#internal-modules" class="anchor"></a>Internal modules</h3></header><div class="spec module" id="module-Metrics"><a href="#module-Metrics" class="anchor"></a><code><span class="keyword">module</span> <a href="Metrics/index.html">Metrics</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module" id="module-CategorizePreconditions"><a href="#module-CategorizePreconditions" class="anchor"></a><code><span class="keyword">module</span> <a href="CategorizePreconditions/index.html">CategorizePreconditions</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></section></div></body></html>