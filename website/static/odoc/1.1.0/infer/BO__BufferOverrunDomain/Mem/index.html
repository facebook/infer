<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Mem (infer.BO__BufferOverrunDomain.Mem)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">infer</a> &#x00BB; <a href="../index.html">BO__BufferOverrunDomain</a> &#x00BB; Mem</nav><h1>Module <code>BO__BufferOverrunDomain.Mem</code></h1></header><dl><dt class="spec type" id="type-t0"><a href="#type-t0" class="anchor"></a><code><span class="keyword">type</span> <span>'has_oenv t0</span></code><code> = </code><table class="variant"><tr id="type-t0.Unreachable" class="anchored"><td class="def constructor"><a href="#type-t0.Unreachable" class="anchor"></a><code>| </code><code><span class="constructor">Unreachable</span></code></td><td class="doc"><p>Memory of unreachable node</p></td></tr><tr id="type-t0.ExcRaised" class="anchored"><td class="def constructor"><a href="#type-t0.ExcRaised" class="anchor"></a><code>| </code><code><span class="constructor">ExcRaised</span></code></td><td class="doc"><p>Memory of node that can be reachable only with exception raises that we want to ignore</p></td></tr><tr id="type-t0.Reachable" class="anchored"><td class="def constructor"><a href="#type-t0.Reachable" class="anchor"></a><code>| </code><code><span class="constructor">Reachable</span> <span class="keyword">of</span> <span><span class="type-var">'has_oenv</span> <a href="../MemReach/index.html#type-t0">MemReach.t0</a></span></code></td></tr></table></dt><dt class="spec type" id="type-no_oenv_t"><a href="#type-no_oenv_t" class="anchor"></a><code><span class="keyword">type</span> no_oenv_t</code><code> = <span><a href="../../IStdlib/GOption/index.html#type-none">IStdlib.GOption.none</a> <a href="index.html#type-t0">t0</a></span></code></dt><dd><p>Memory type without an environment for on-demand symbol evaluation</p></dd></dl><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code><code> = <span><a href="../../IStdlib/GOption/index.html#type-some">IStdlib.GOption.some</a> <a href="index.html#type-t0">t0</a></span></code></dt><dd><p>Memory type with an environment for on-demand symbol evaluation</p></dd></dl><dl><dt class="spec value" id="val-unset_oenv"><a href="#val-unset_oenv" class="anchor"></a><code><span class="keyword">val</span> unset_oenv : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-no_oenv_t">no_oenv_t</a></code></dt></dl><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="../../Absint/AbstractDomain/index.html#module-type-S">Absint.AbstractDomain.S</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="../../Absint/AbstractDomain/module-type-S/index.html#type-t">t</a> := <a href="index.html#type-t">t</a></code></span></summary><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="../../Absint/AbstractDomain/index.html#module-type-NoJoin">Absint.AbstractDomain.NoJoin</a></code></span></summary><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="../../IStdlib/PrettyPrintable/index.html#module-type-PrintableType">IStdlib.PrettyPrintable.PrintableType</a></code></span></summary><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code></dt></dl><dl><dt class="spec value" id="val-pp"><a href="#val-pp" class="anchor"></a><code><span class="keyword">val</span> pp : <a href="../../IStdlib/PrettyPrintable/index.html#module-F">IStdlib.PrettyPrintable.F</a>.formatter <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt></dl></details></div></div></div><dl><dt class="spec value" id="val-leq"><a href="#val-leq" class="anchor"></a><code><span class="keyword">val</span> leq : <span>lhs:<a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>rhs:<a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> bool</code></dt><dd><p>the implication relation: <code>lhs &lt;= rhs</code> means <code>lhs |- rhs</code></p></dd></dl></details></div></div></div><dl><dt class="spec value" id="val-join"><a href="#val-join" class="anchor"></a><code><span class="keyword">val</span> join : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-widen"><a href="#val-widen" class="anchor"></a><code><span class="keyword">val</span> widen : <span>prev:<a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>next:<a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>num_iters:int</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt></dl></details></div></div></div><dl><dt class="spec value" id="val-pp"><a href="#val-pp" class="anchor"></a><code><span class="keyword">val</span> pp : Stdlib.Format.formatter <span>&#45;&gt;</span> <span><span class="type-var">_</span> <a href="index.html#type-t0">t0</a></span> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-unreachable"><a href="#val-unreachable" class="anchor"></a><code><span class="keyword">val</span> unreachable : <a href="index.html#type-t">t</a></code></dt></dl><dl><dt class="spec type" id="type-get_summary"><a href="#type-get_summary" class="anchor"></a><code><span class="keyword">type</span> get_summary</code><code> = <a href="../../IR/Procname/index.html#type-t">IR.Procname.t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-no_oenv_t">no_oenv_t</a> option</span></code></dt></dl><dl><dt class="spec value" id="val-init"><a href="#val-init" class="anchor"></a><code><span class="keyword">val</span> init : <a href="index.html#type-get_summary">get_summary</a> <span>&#45;&gt;</span> <a href="../../BO/BufferOverrunOndemandEnv/index.html#type-t">BO.BufferOverrunOndemandEnv.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-exc_raised"><a href="#val-exc_raised" class="anchor"></a><code><span class="keyword">val</span> exc_raised : <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-is_rep_multi_loc"><a href="#val-is_rep_multi_loc" class="anchor"></a><code><span class="keyword">val</span> is_rep_multi_loc : <a href="../../BO/AbsLoc/Loc/index.html#type-t">BO.AbsLoc.Loc.t</a> <span>&#45;&gt;</span> <span><span class="type-var">_</span> <a href="index.html#type-t0">t0</a></span> <span>&#45;&gt;</span> bool</code></dt><dd><p>Check if an abstract location represents multiple concrete locations.</p></dd></dl><dl><dt class="spec value" id="val-is_stack_loc"><a href="#val-is_stack_loc" class="anchor"></a><code><span class="keyword">val</span> is_stack_loc : <a href="../../BO/AbsLoc/Loc/index.html#type-t">BO.AbsLoc.Loc.t</a> <span>&#45;&gt;</span> <span><span class="type-var">_</span> <a href="index.html#type-t0">t0</a></span> <span>&#45;&gt;</span> bool</code></dt><dd><p>Check if an abstract location is a stack variable, e.g., <code>n$0</code>.</p></dd></dl><dl><dt class="spec value" id="val-set_prune_pairs"><a href="#val-set_prune_pairs" class="anchor"></a><code><span class="keyword">val</span> set_prune_pairs : <a href="../PrunePairs/index.html#type-t">PrunePairs.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-set_latest_prune"><a href="#val-set_latest_prune" class="anchor"></a><code><span class="keyword">val</span> set_latest_prune : <a href="../LatestPrune/index.html#type-t">LatestPrune.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-set_first_idx_of_null"><a href="#val-set_first_idx_of_null" class="anchor"></a><code><span class="keyword">val</span> set_first_idx_of_null : <a href="../../BO/AbsLoc/Loc/index.html#type-t">BO.AbsLoc.Loc.t</a> <span>&#45;&gt;</span> <a href="../Val/index.html#type-t">Val.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>In C string, set the index of the first null character, i.e., end of string, when called by <code>set_first_idx_of_null loc_to_string index_value mem</code>.</p></dd></dl><dl><dt class="spec value" id="val-unset_first_idx_of_null"><a href="#val-unset_first_idx_of_null" class="anchor"></a><code><span class="keyword">val</span> unset_first_idx_of_null : <a href="../../BO/AbsLoc/Loc/index.html#type-t">BO.AbsLoc.Loc.t</a> <span>&#45;&gt;</span> <a href="../Val/index.html#type-t">Val.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>In C string, unset the index of the first null character, i.e., end of string, when called by <code>unset_first_idx_of_null loc_to_string index_value mem</code>. This is unsound because the index can be assigned as <code>previous index + 1</code> that is a heuristic to keep string lengths in some loops.</p></dd></dl><dl><dt class="spec value" id="val-get_c_strlen"><a href="#val-get_c_strlen" class="anchor"></a><code><span class="keyword">val</span> get_c_strlen : <a href="../../BO/AbsLoc/PowLoc/index.html#type-t">BO.AbsLoc.PowLoc.t</a> <span>&#45;&gt;</span> <span><span class="type-var">_</span> <a href="index.html#type-t0">t0</a></span> <span>&#45;&gt;</span> <a href="../Val/index.html#type-t">Val.t</a></code></dt><dd><p>Get C string length that is set/unset by <code>set_first_idex_of_null</code> and <code>unset_first_idex_of_null</code></p></dd></dl><dl><dt class="spec value" id="val-get_latest_prune"><a href="#val-get_latest_prune" class="anchor"></a><code><span class="keyword">val</span> get_latest_prune : <span><span class="type-var">_</span> <a href="index.html#type-t0">t0</a></span> <span>&#45;&gt;</span> <a href="../LatestPrune/index.html#type-t">LatestPrune.t</a></code></dt><dt class="spec value" id="val-get_reachable_locs_from"><a href="#val-get_reachable_locs_from" class="anchor"></a><code><span class="keyword">val</span> get_reachable_locs_from : <span><span>(<a href="../../IR/Pvar/index.html#type-t">IR.Pvar.t</a> * <a href="../../IR/Typ/index.html#type-t">IR.Typ.t</a>)</span> list</span> <span>&#45;&gt;</span> <a href="../../BO__AbsLoc/index.html#module-LocSet">BO.AbsLoc.LocSet</a>.t <span>&#45;&gt;</span> <span><span class="type-var">_</span> <a href="index.html#type-t0">t0</a></span> <span>&#45;&gt;</span> <a href="../../BO__AbsLoc/index.html#module-LocSet">BO.AbsLoc.LocSet</a>.t</code></dt><dd><p>Get reachable locations from <code>formals</code> and <code>locs</code> when called <code>get_reachable_locs_from formals locs mem</code></p></dd></dl><dl><dt class="spec value" id="val-add_stack"><a href="#val-add_stack" class="anchor"></a><code><span class="keyword">val</span> add_stack : <span>?&#8288;represents_multiple_values:bool</span> <span>&#45;&gt;</span> <a href="../../BO/AbsLoc/Loc/index.html#type-t">BO.AbsLoc.Loc.t</a> <span>&#45;&gt;</span> <a href="../Val/index.html#type-t">Val.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Add an abstract value for stack variables such as <code>n$0</code></p></dd></dl><dl><dt class="spec value" id="val-add_stack_loc"><a href="#val-add_stack_loc" class="anchor"></a><code><span class="keyword">val</span> add_stack_loc : <a href="../../BO/AbsLoc/Loc/index.html#type-t">BO.AbsLoc.Loc.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-add_heap"><a href="#val-add_heap" class="anchor"></a><code><span class="keyword">val</span> add_heap : <span>?&#8288;represents_multiple_values:bool</span> <span>&#45;&gt;</span> <a href="../../BO/AbsLoc/Loc/index.html#type-t">BO.AbsLoc.Loc.t</a> <span>&#45;&gt;</span> <a href="../Val/index.html#type-t">Val.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Add an abstract value for non-stack variables</p></dd></dl><dl><dt class="spec value" id="val-add_heap_set"><a href="#val-add_heap_set" class="anchor"></a><code><span class="keyword">val</span> add_heap_set : <span>?&#8288;represents_multiple_values:bool</span> <span>&#45;&gt;</span> <a href="../../BO/AbsLoc/PowLoc/index.html#type-t">BO.AbsLoc.PowLoc.t</a> <span>&#45;&gt;</span> <a href="../Val/index.html#type-t">Val.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-add_unknown"><a href="#val-add_unknown" class="anchor"></a><code><span class="keyword">val</span> add_unknown : <span>(<a href="../../IR/Ident/index.html#type-t">IR.Ident.t</a> * <a href="../../IR/Typ/index.html#type-t">IR.Typ.t</a>)</span> <span>&#45;&gt;</span> <span>location:<a href="../../IBase/Location/index.html#type-t">IBase.Location.t</a></span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Add an unknown value for stack variables</p></dd></dl><dl><dt class="spec value" id="val-add_unknown_from"><a href="#val-add_unknown_from" class="anchor"></a><code><span class="keyword">val</span> add_unknown_from : <span>(<a href="../../IR/Ident/index.html#type-t">IR.Ident.t</a> * <a href="../../IR/Typ/index.html#type-t">IR.Typ.t</a>)</span> <span>&#45;&gt;</span> <span>callee_pname:<a href="../../IR/Procname/index.html#type-t">IR.Procname.t</a></span> <span>&#45;&gt;</span> <span>location:<a href="../../IBase/Location/index.html#type-t">IBase.Location.t</a></span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Add an unknown return value of <code>callee_pname</code> for stack variables</p></dd></dl><dl><dt class="spec value" id="val-remove_temps"><a href="#val-remove_temps" class="anchor"></a><code><span class="keyword">val</span> remove_temps : <span><a href="../../IR/Ident/index.html#type-t">IR.Ident.t</a> list</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Remove given temporary variables from the abstract memory</p></dd></dl><dl><dt class="spec value" id="val-find"><a href="#val-find" class="anchor"></a><code><span class="keyword">val</span> find : <a href="../../BO/AbsLoc/Loc/index.html#type-t">BO.AbsLoc.Loc.t</a> <span>&#45;&gt;</span> <span><span class="type-var">_</span> <a href="index.html#type-t0">t0</a></span> <span>&#45;&gt;</span> <a href="../Val/index.html#type-t">Val.t</a></code></dt><dt class="spec value" id="val-find_opt"><a href="#val-find_opt" class="anchor"></a><code><span class="keyword">val</span> find_opt : <a href="../../BO/AbsLoc/Loc/index.html#type-t">BO.AbsLoc.Loc.t</a> <span>&#45;&gt;</span> <span><span class="type-var">_</span> <a href="index.html#type-t0">t0</a></span> <span>&#45;&gt;</span> <span><a href="../Val/index.html#type-t">Val.t</a> option</span></code></dt><dt class="spec value" id="val-find_set"><a href="#val-find_set" class="anchor"></a><code><span class="keyword">val</span> find_set : <span>?&#8288;typ:<a href="../../IR/Typ/index.html#type-t">IR.Typ.t</a></span> <span>&#45;&gt;</span> <a href="../../BO/AbsLoc/PowLoc/index.html#type-t">BO.AbsLoc.PowLoc.t</a> <span>&#45;&gt;</span> <span><span class="type-var">_</span> <a href="index.html#type-t0">t0</a></span> <span>&#45;&gt;</span> <a href="../Val/index.html#type-t">Val.t</a></code></dt><dt class="spec value" id="val-find_stack"><a href="#val-find_stack" class="anchor"></a><code><span class="keyword">val</span> find_stack : <a href="../../BO/AbsLoc/Loc/index.html#type-t">BO.AbsLoc.Loc.t</a> <span>&#45;&gt;</span> <span><span class="type-var">_</span> <a href="index.html#type-t0">t0</a></span> <span>&#45;&gt;</span> <a href="../Val/index.html#type-t">Val.t</a></code></dt><dt class="spec value" id="val-find_alias_id"><a href="#val-find_alias_id" class="anchor"></a><code><span class="keyword">val</span> find_alias_id : <a href="../../IR/Ident/index.html#type-t">IR.Ident.t</a> <span>&#45;&gt;</span> <span><span class="type-var">_</span> <a href="index.html#type-t0">t0</a></span> <span>&#45;&gt;</span> <a href="../AliasTargets/index.html#type-t">AliasTargets.t</a></code></dt><dd><p>Find aliases between given ident</p></dd></dl><dl><dt class="spec value" id="val-find_alias_loc"><a href="#val-find_alias_loc" class="anchor"></a><code><span class="keyword">val</span> find_alias_loc : <a href="../../BO/AbsLoc/Loc/index.html#type-t">BO.AbsLoc.Loc.t</a> <span>&#45;&gt;</span> <span><span class="type-var">_</span> <a href="index.html#type-t0">t0</a></span> <span>&#45;&gt;</span> <a href="../AliasTargets/index.html#type-t">AliasTargets.t</a></code></dt><dd><p>Find aliases between given abstract location</p></dd></dl><dl><dt class="spec value" id="val-find_simple_alias"><a href="#val-find_simple_alias" class="anchor"></a><code><span class="keyword">val</span> find_simple_alias : <a href="../../IR/Ident/index.html#type-t">IR.Ident.t</a> <span>&#45;&gt;</span> <span><span class="type-var">_</span> <a href="index.html#type-t0">t0</a></span> <span>&#45;&gt;</span> <span><span>(<a href="../../BO/AbsLoc/Loc/index.html#type-t">BO.AbsLoc.Loc.t</a> * <a href="../../IR/IntLit/index.html#type-t">IR.IntLit.t</a>)</span> list</span></code></dt><dd><p>Find simple aliases between given ident. It returns a list of pairs of abstract locations and integer which represent aliases <code>id == x + i</code>.</p></dd></dl><dl><dt class="spec value" id="val-find_size_alias"><a href="#val-find_size_alias" class="anchor"></a><code><span class="keyword">val</span> find_size_alias : <a href="../../IR/Ident/index.html#type-t">IR.Ident.t</a> <span>&#45;&gt;</span> <span><span class="type-var">_</span> <a href="index.html#type-t0">t0</a></span> <span>&#45;&gt;</span> <span><span>(<a href="../AliasTarget/index.html#type-alias_typ">AliasTarget.alias_typ</a> * <a href="../../BO/AbsLoc/Loc/index.html#type-t">BO.AbsLoc.Loc.t</a> * <a href="../../IR/IntLit/index.html#type-t">IR.IntLit.t</a> * <span><a href="../../BO/AbsLoc/Loc/index.html#type-t">BO.AbsLoc.Loc.t</a> option</span>)</span> list</span></code></dt><dd><p>Find size aliases between given ident. It returns a list of four elements, alias type <code>== or &gt;=</code>, location <code>x</code>, integer <code>i</code>, java temporary variable <code>$irvar0</code>. This represents <code>id == $irvar0 (== or &gt;=) x.size() + i</code>.</p></dd></dl><dl><dt class="spec value" id="val-find_ret_alias"><a href="#val-find_ret_alias" class="anchor"></a><code><span class="keyword">val</span> find_ret_alias : <span><span class="type-var">_</span> <a href="index.html#type-t0">t0</a></span> <span>&#45;&gt;</span> <span><a href="../AliasRet/index.html#type-t">AliasRet.t</a> <a href="../../Absint/AbstractDomain/Types/index.html#type-bottom_lifted">Absint.AbstractDomain.Types.bottom_lifted</a></span></code></dt><dd><p>Find aliases bound to the return variable</p></dd></dl><dl><dt class="spec value" id="val-fgets_alias"><a href="#val-fgets_alias" class="anchor"></a><code><span class="keyword">val</span> fgets_alias : <a href="../../IR/Ident/index.html#type-t">IR.Ident.t</a> <span>&#45;&gt;</span> <a href="../../BO/AbsLoc/PowLoc/index.html#type-t">BO.AbsLoc.PowLoc.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Set <code>fgets</code> alias between an ident and an abstract location</p></dd></dl><dl><dt class="spec value" id="val-apply_latest_prune"><a href="#val-apply_latest_prune" class="anchor"></a><code><span class="keyword">val</span> apply_latest_prune : <a href="../../IR/Exp/index.html#type-t">IR.Exp.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> * <a href="../PrunePairs/index.html#type-t">PrunePairs.t</a></code></dt><dd><p>Apply latest_prunes when given <code>e : Exp.t</code> is true. It returns pruned memory and pairs of pruned locations and values.</p></dd></dl><dl><dt class="spec value" id="val-load_alias"><a href="#val-load_alias" class="anchor"></a><code><span class="keyword">val</span> load_alias : <a href="../../IR/Ident/index.html#type-t">IR.Ident.t</a> <span>&#45;&gt;</span> <a href="../../BO/AbsLoc/Loc/index.html#type-t">BO.AbsLoc.Loc.t</a> <span>&#45;&gt;</span> <a href="../AliasTarget/index.html#type-t">AliasTarget.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Add an alias between ident and abstract location with given alias target</p></dd></dl><dl><dt class="spec value" id="val-load_empty_alias"><a href="#val-load_empty_alias" class="anchor"></a><code><span class="keyword">val</span> load_empty_alias : <a href="../../IR/Ident/index.html#type-t">IR.Ident.t</a> <span>&#45;&gt;</span> <a href="../../BO/AbsLoc/Loc/index.html#type-t">BO.AbsLoc.Loc.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Add an empty alias between ident and abstract location, i.e., <code>ident == loc.empty()</code></p></dd></dl><dl><dt class="spec value" id="val-load_simple_alias"><a href="#val-load_simple_alias" class="anchor"></a><code><span class="keyword">val</span> load_simple_alias : <a href="../../IR/Ident/index.html#type-t">IR.Ident.t</a> <span>&#45;&gt;</span> <a href="../../BO/AbsLoc/Loc/index.html#type-t">BO.AbsLoc.Loc.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Add a simple alias between ident and abstract location, i.e., <code>ident == loc</code></p></dd></dl><dl><dt class="spec value" id="val-load_size_alias"><a href="#val-load_size_alias" class="anchor"></a><code><span class="keyword">val</span> load_size_alias : <a href="../../IR/Ident/index.html#type-t">IR.Ident.t</a> <span>&#45;&gt;</span> <a href="../../BO/AbsLoc/Loc/index.html#type-t">BO.AbsLoc.Loc.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Add a size alias between ident and abstract location, i.e., <code>ident == loc.size()</code></p></dd></dl><dl><dt class="spec value" id="val-store_simple_alias"><a href="#val-store_simple_alias" class="anchor"></a><code><span class="keyword">val</span> store_simple_alias : <a href="../../BO/AbsLoc/Loc/index.html#type-t">BO.AbsLoc.Loc.t</a> <span>&#45;&gt;</span> <a href="../../IR/Exp/index.html#type-t">IR.Exp.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Add a simple alias between abstract location and expression, i.e., <code>loc == exp</code></p></dd></dl><dl><dt class="spec value" id="val-forget_size_alias"><a href="#val-forget_size_alias" class="anchor"></a><code><span class="keyword">val</span> forget_size_alias : <a href="../../BO/AbsLoc/PowLoc/index.html#type-t">BO.AbsLoc.PowLoc.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Forget size aliases of given <code>locs</code></p></dd></dl><dl><dt class="spec value" id="val-incr_size_alias"><a href="#val-incr_size_alias" class="anchor"></a><code><span class="keyword">val</span> incr_size_alias : <a href="../../BO/AbsLoc/PowLoc/index.html#type-t">BO.AbsLoc.PowLoc.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Update size aliases when the size of <code>loc</code> is increased by one. For example if there was an alias <code>ident == loc.size() + i</code>, this changes it to <code>ident == loc.size() + i - 1</code>, since <code>loc.size()</code> has been increased.</p></dd></dl><dl><dt class="spec value" id="val-incr_or_not_size_alias"><a href="#val-incr_or_not_size_alias" class="anchor"></a><code><span class="keyword">val</span> incr_or_not_size_alias : <a href="../../BO/AbsLoc/PowLoc/index.html#type-t">BO.AbsLoc.PowLoc.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Update size aliases when the size of <code>loc</code> may be increased by one. For example if there was an alias <code>ident == loc.size() + i</code>, this changes it to <code>ident &gt;= loc.size() + i - 1</code></p></dd></dl><dl><dt class="spec value" id="val-add_iterator_has_next_alias"><a href="#val-add_iterator_has_next_alias" class="anchor"></a><code><span class="keyword">val</span> add_iterator_has_next_alias : <a href="../../IR/Ident/index.html#type-t">IR.Ident.t</a> <span>&#45;&gt;</span> <a href="../../IR/Exp/index.html#type-t">IR.Exp.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Add an <code>AliasTarget.IteratorHasNext</code> alias when <code>ident = iterator.hasNext()</code> is called</p></dd></dl><dl><dt class="spec value" id="val-add_iterator_next_object_alias"><a href="#val-add_iterator_next_object_alias" class="anchor"></a><code><span class="keyword">val</span> add_iterator_next_object_alias : <span>ret_id:<a href="../../IR/Ident/index.html#type-t">IR.Ident.t</a></span> <span>&#45;&gt;</span> <span>iterator:<a href="../../IR/Ident/index.html#type-t">IR.Ident.t</a></span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Add an <code>AliasTarget.IteratorNextObject</code> alias when <code>ident = iterator.nextObject()</code> is called</p></dd></dl><dl><dt class="spec value" id="val-incr_iterator_simple_alias_on_call"><a href="#val-incr_iterator_simple_alias_on_call" class="anchor"></a><code><span class="keyword">val</span> incr_iterator_simple_alias_on_call : <a href="../index.html#type-eval_sym_trace">eval_sym_trace</a> <span>&#45;&gt;</span> <span>callee_exit_mem:<a href="index.html#type-no_oenv_t">no_oenv_t</a></span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Update <code>AliasTarget.IteratorSimple</code> alias at function calls</p></dd></dl><dl><dt class="spec value" id="val-add_iterator_alias"><a href="#val-add_iterator_alias" class="anchor"></a><code><span class="keyword">val</span> add_iterator_alias : <a href="../../IR/Ident/index.html#type-t">IR.Ident.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Add <code>AliasTarget.IteratorSimple</code> and <code>AliasTarget.IteratorOffset</code> aliases when <code>Iteratable.iterator()</code> is called</p></dd></dl><dl><dt class="spec value" id="val-incr_iterator_offset_alias"><a href="#val-incr_iterator_offset_alias" class="anchor"></a><code><span class="keyword">val</span> incr_iterator_offset_alias : <a href="../../IR/Exp/index.html#type-t">IR.Exp.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Update iterator offset alias when <code>iterator.next()</code> is called</p></dd></dl><dl><dt class="spec value" id="val-update_mem"><a href="#val-update_mem" class="anchor"></a><code><span class="keyword">val</span> update_mem : <a href="../../BO/AbsLoc/PowLoc/index.html#type-t">BO.AbsLoc.PowLoc.t</a> <span>&#45;&gt;</span> <a href="../Val/index.html#type-t">Val.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Add a map from locations to a value. If the given set of locations is a singleton set and the only element represents one concrete abstract location, it does strong update. Otherwise, weak update.</p></dd></dl><dl><dt class="spec value" id="val-strong_update"><a href="#val-strong_update" class="anchor"></a><code><span class="keyword">val</span> strong_update : <a href="../../BO/AbsLoc/PowLoc/index.html#type-t">BO.AbsLoc.PowLoc.t</a> <span>&#45;&gt;</span> <a href="../Val/index.html#type-t">Val.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-update_latest_prune"><a href="#val-update_latest_prune" class="anchor"></a><code><span class="keyword">val</span> update_latest_prune : <span>updated_locs:<a href="../../BO/AbsLoc/PowLoc/index.html#type-t">BO.AbsLoc.PowLoc.t</a></span> <span>&#45;&gt;</span> <a href="../../IR/Exp/index.html#type-t">IR.Exp.t</a> <span>&#45;&gt;</span> <a href="../../IR/Exp/index.html#type-t">IR.Exp.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Update latest prunes when <code>store(x,1)</code> or <code>store(x,0)</code> is called after <code>assume</code> statement</p></dd></dl><dl><dt class="spec value" id="val-forget_unreachable_locs"><a href="#val-forget_unreachable_locs" class="anchor"></a><code><span class="keyword">val</span> forget_unreachable_locs : <span>formals:<span><span>(<a href="../../IR/Pvar/index.html#type-t">IR.Pvar.t</a> * <a href="../../IR/Typ/index.html#type-t">IR.Typ.t</a>)</span> list</span></span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Forget unreachable locations from <code>formals</code></p></dd></dl><dl><dt class="spec value" id="val-transform_mem"><a href="#val-transform_mem" class="anchor"></a><code><span class="keyword">val</span> transform_mem : <span>f:<span>(<a href="../Val/index.html#type-t">Val.t</a> <span>&#45;&gt;</span> <a href="../Val/index.html#type-t">Val.t</a>)</span></span> <span>&#45;&gt;</span> <a href="../../BO/AbsLoc/PowLoc/index.html#type-t">BO.AbsLoc.PowLoc.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Apply <code>f</code> to values bound to given <code>locs</code></p></dd></dl></div></body></html>