<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>IBase__Utils (infer.IBase__Utils)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">infer</a> &#x00BB; IBase__Utils</nav><h1>Module <code>IBase__Utils</code></h1></header><dl><dt class="spec value" id="val-find_files"><a href="#val-find_files" class="anchor"></a><code><span class="keyword">val</span> find_files : <span>path:string</span> <span>&#45;&gt;</span> <span>extension:string</span> <span>&#45;&gt;</span> <span>string list</span></code></dt><dd><p>recursively traverse a path for files ending with a given extension</p></dd></dl><dl><dt class="spec value" id="val-fold_folders"><a href="#val-fold_folders" class="anchor"></a><code><span class="keyword">val</span> fold_folders : <span>init:<span class="type-var">'acc</span></span> <span>&#45;&gt;</span> <span>f:<span>(<span class="type-var">'acc</span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span class="type-var">'acc</span>)</span></span> <span>&#45;&gt;</span> <span>path:string</span> <span>&#45;&gt;</span> <span class="type-var">'acc</span></code></dt><dd><p>recursively traverse a path for folders, returning resuls by a given fold function</p></dd></dl><dl><dt class="spec value" id="val-string_crc_hex32"><a href="#val-string_crc_hex32" class="anchor"></a><code><span class="keyword">val</span> string_crc_hex32 : string <span>&#45;&gt;</span> string</code></dt><dd><p>Compute a 32-character hexadecimal crc using the Digest module</p></dd></dl><dl><dt class="spec value" id="val-read_file"><a href="#val-read_file" class="anchor"></a><code><span class="keyword">val</span> read_file : string <span>&#45;&gt;</span> <span><span>(<span>string list</span>, string)</span> <a href="../IStdlib/index.html#module-IStd">IStdlib.IStd</a>.Result.t</span></code></dt><dd><p>read a source file and return a list of lines</p></dd></dl><dl><dt class="spec value" id="val-normalize_path_from"><a href="#val-normalize_path_from" class="anchor"></a><code><span class="keyword">val</span> normalize_path_from : <span>root:string</span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string * string</code></dt><dd><p><code>normalize_path_from ~root path</code> removes &quot;..&quot; and &quot;.&quot; parts of <code>root/path</code> when possible and returns the new <code>root</code> and <code>path</code>, eg if <code>root = &quot;r&quot;</code> and <code>path = &quot;a/../../../foo/./bar&quot;</code> then the result is <code>(&quot;../foo/bar&quot;, &quot;.&quot;)</code> (in particular &quot;r/a/../../../foo/./bar&quot; and &quot;./../foo/bar&quot; represent the same file)</p></dd></dl><dl><dt class="spec value" id="val-normalize_path"><a href="#val-normalize_path" class="anchor"></a><code><span class="keyword">val</span> normalize_path : string <span>&#45;&gt;</span> string</code></dt><dd><p>Normalize a path without a root</p></dd></dl><dl><dt class="spec value" id="val-filename_to_absolute"><a href="#val-filename_to_absolute" class="anchor"></a><code><span class="keyword">val</span> filename_to_absolute : <span>root:string</span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string</code></dt><dd><p>Convert a filename to an absolute one if it is relative, and normalize &quot;.&quot; and &quot;..&quot;</p></dd></dl><dl><dt class="spec value" id="val-filename_to_relative"><a href="#val-filename_to_relative" class="anchor"></a><code><span class="keyword">val</span> filename_to_relative : <span>?&#8288;force_full_backtrack:bool</span> <span>&#45;&gt;</span> <span>?&#8288;backtrack:int</span> <span>&#45;&gt;</span> <span>root:string</span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span>string option</span></code></dt><dd><p>Convert an absolute filename to one relative to a root directory. Returns <code>None</code> if filename is not under root. The backtrack level sets the maximum level of steps in the parent directories to search for a common prefix</p></dd></dl><dl><dt class="spec type" id="type-outfile"><a href="#type-outfile" class="anchor"></a><code><span class="keyword">type</span> outfile</code><code> = </code><code>{</code><table class="record"><tr id="type-outfile.fname" class="anchored"><td class="def field"><a href="#type-outfile.fname" class="anchor"></a><code>fname : string;</code></td><td class="doc"><p>name of the file</p></td></tr><tr id="type-outfile.out_c" class="anchored"><td class="def field"><a href="#type-outfile.out_c" class="anchor"></a><code>out_c : <a href="../IStdlib/index.html#module-IStd">IStdlib.IStd</a>.Out_channel.t;</code></td><td class="doc"><p>output channel</p></td></tr><tr id="type-outfile.fmt" class="anchored"><td class="def field"><a href="#type-outfile.fmt" class="anchor"></a><code>fmt : Stdlib.Format.formatter;</code></td><td class="doc"><p>formatter for printing</p></td></tr></table><code>}</code></dt><dd><p>type for files used for printing</p></dd></dl><dl><dt class="spec value" id="val-create_outfile"><a href="#val-create_outfile" class="anchor"></a><code><span class="keyword">val</span> create_outfile : string <span>&#45;&gt;</span> <span><a href="index.html#type-outfile">outfile</a> option</span></code></dt><dd><p>create an outfile for the command line, the boolean indicates whether to do demangling when closing the file</p></dd></dl><dl><dt class="spec value" id="val-close_outf"><a href="#val-close_outf" class="anchor"></a><code><span class="keyword">val</span> close_outf : <a href="index.html#type-outfile">outfile</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>close an outfile</p></dd></dl><dl><dt class="spec value" id="val-directory_fold"><a href="#val-directory_fold" class="anchor"></a><code><span class="keyword">val</span> directory_fold : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>Functional fold function over all the file of a directory</p></dd></dl><dl><dt class="spec value" id="val-directory_iter"><a href="#val-directory_iter" class="anchor"></a><code><span class="keyword">val</span> directory_iter : <span>(string <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> unit</code></dt><dd><p>Functional iter function over all the file of a directory</p></dd></dl><dl><dt class="spec value" id="val-directory_is_empty"><a href="#val-directory_is_empty" class="anchor"></a><code><span class="keyword">val</span> directory_is_empty : string <span>&#45;&gt;</span> bool</code></dt><dd><p>Returns true if a given directory is empty. The directory is assumed to exist.</p></dd></dl><dl><dt class="spec value" id="val-read_json_file"><a href="#val-read_json_file" class="anchor"></a><code><span class="keyword">val</span> read_json_file : string <span>&#45;&gt;</span> <span><span>(Yojson.Basic.t, string)</span> <a href="../IStdlib/index.html#module-IStd">IStdlib.IStd</a>.Result.t</span></code></dt><dt class="spec value" id="val-with_file_in"><a href="#val-with_file_in" class="anchor"></a><code><span class="keyword">val</span> with_file_in : string <span>&#45;&gt;</span> <span>f:<span>(<a href="../IStdlib/index.html#module-IStd">IStdlib.IStd</a>.In_channel.t <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span></span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dt class="spec value" id="val-with_file_out"><a href="#val-with_file_out" class="anchor"></a><code><span class="keyword">val</span> with_file_out : string <span>&#45;&gt;</span> <span>f:<span>(<a href="../IStdlib/index.html#module-IStd">IStdlib.IStd</a>.Out_channel.t <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span></span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dt class="spec value" id="val-with_intermediate_temp_file_out"><a href="#val-with_intermediate_temp_file_out" class="anchor"></a><code><span class="keyword">val</span> with_intermediate_temp_file_out : string <span>&#45;&gt;</span> <span>f:<span>(<a href="../IStdlib/index.html#module-IStd">IStdlib.IStd</a>.Out_channel.t <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span></span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>like <code>with_file_out</code> but uses a fresh intermediate temporary file and rename to avoid write-write races</p></dd></dl><dl><dt class="spec value" id="val-write_json_to_file"><a href="#val-write_json_to_file" class="anchor"></a><code><span class="keyword">val</span> write_json_to_file : string <span>&#45;&gt;</span> Yojson.Basic.t <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-consume_in"><a href="#val-consume_in" class="anchor"></a><code><span class="keyword">val</span> consume_in : <a href="../IStdlib/index.html#module-IStd">IStdlib.IStd</a>.In_channel.t <span>&#45;&gt;</span> unit</code></dt><dd><p>consume and ignore all the lines from the channel until End_of_file is reached</p></dd></dl><dl><dt class="spec value" id="val-echo_in"><a href="#val-echo_in" class="anchor"></a><code><span class="keyword">val</span> echo_in : <a href="../IStdlib/index.html#module-IStd">IStdlib.IStd</a>.In_channel.t <span>&#45;&gt;</span> unit</code></dt><dd><p>echo the lines we get to stdout until End_of_file is reached</p></dd></dl><dl><dt class="spec value" id="val-with_channel_in"><a href="#val-with_channel_in" class="anchor"></a><code><span class="keyword">val</span> with_channel_in : <span>f:<span>(string <span>&#45;&gt;</span> unit)</span></span> <span>&#45;&gt;</span> <a href="../IStdlib/index.html#module-IStd">IStdlib.IStd</a>.In_channel.t <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-with_process_in"><a href="#val-with_process_in" class="anchor"></a><code><span class="keyword">val</span> with_process_in : string <span>&#45;&gt;</span> <span>(<a href="../IStdlib/index.html#module-IStd">IStdlib.IStd</a>.In_channel.t <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> * <a href="../IStdlib/index.html#module-IStd">IStdlib.IStd</a>.Unix.Exit_or_signal.t</code></dt><dt class="spec value" id="val-create_dir"><a href="#val-create_dir" class="anchor"></a><code><span class="keyword">val</span> create_dir : string <span>&#45;&gt;</span> unit</code></dt><dd><p>recursively create a directory if it does not exist already</p></dd></dl><dl><dt class="spec value" id="val-out_channel_create_with_dir"><a href="#val-out_channel_create_with_dir" class="anchor"></a><code><span class="keyword">val</span> out_channel_create_with_dir : <a href="../IStdlib/index.html#module-IStd">IStdlib.IStd</a>.Filename.t <span>&#45;&gt;</span> <a href="../IStdlib/index.html#module-IStd">IStdlib.IStd</a>.Out_channel.t</code></dt><dd><p>create an out channel with creating missing directories</p></dd></dl><dl><dt class="spec value" id="val-realpath"><a href="#val-realpath" class="anchor"></a><code><span class="keyword">val</span> realpath : <span>?&#8288;warn_on_error:bool</span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string</code></dt><dd><p><code>realpath warn_on_error path</code> returns path with all symbolic links resolved. It caches results of previous calls to avoid expensive system calls. WARNING: If warn_on_error is false, no warning will be shown whenever an error occurs for the given path (e.g. if it does not exist).</p></dd></dl><dl><dt class="spec value" id="val-suppress_stderr2"><a href="#val-suppress_stderr2" class="anchor"></a><code><span class="keyword">val</span> suppress_stderr2 : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span></code></dt><dd><p>wraps a function expecting 2 arguments in another that temporarily redirects stderr to /dev/null for the duration of the function call</p></dd></dl><dl><dt class="spec value" id="val-rmtree"><a href="#val-rmtree" class="anchor"></a><code><span class="keyword">val</span> rmtree : string <span>&#45;&gt;</span> unit</code></dt><dd><p><code>rmtree path</code> removes <code>path</code> and, if <code>path</code> is a directory, recursively removes its contents</p></dd></dl><dl><dt class="spec value" id="val-try_finally_swallow_timeout"><a href="#val-try_finally_swallow_timeout" class="anchor"></a><code><span class="keyword">val</span> try_finally_swallow_timeout : <span>f:<span>(unit <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span></span> <span>&#45;&gt;</span> <span>finally:<span>(unit <span>&#45;&gt;</span> unit)</span></span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>Calls <code>f</code> then <code>finally</code> even if <code>f</code> raised an exception. The original exception is reraised afterwards. Where possible use <code>SymOp.try_finally</code> to avoid swallowing timeouts.</p></dd></dl><dl><dt class="spec value" id="val-better_hash"><a href="#val-better_hash" class="anchor"></a><code><span class="keyword">val</span> better_hash : <span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="../IStdlib/index.html#module-IStd">IStdlib.IStd</a>.Caml.Digest.t</code></dt><dd><p>Hashtbl.hash only hashes the first 10 meaningful values, <code>better_hash</code> uses everything.</p></dd></dl><dl><dt class="spec value" id="val-unlink_file_on_exit"><a href="#val-unlink_file_on_exit" class="anchor"></a><code><span class="keyword">val</span> unlink_file_on_exit : string <span>&#45;&gt;</span> unit</code></dt><dd><p>delete <code>temporary</code> file on exit</p></dd></dl><dl><dt class="spec value" id="val-strip_balanced_once"><a href="#val-strip_balanced_once" class="anchor"></a><code><span class="keyword">val</span> strip_balanced_once : <span>drop:<span>(char <span>&#45;&gt;</span> bool)</span></span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string</code></dt><dd><p>drop at most one layer of well-balanced first and last characters satisfying <code>drop</code> from the string; for instance, <code>strip_balanced ~drop:(function | 'a' | 'x' -&gt; true | _ -&gt; false) &quot;xaabax&quot;</code> returns &quot;aaba&quot;</p></dd></dl><dl><dt class="spec value" id="val-assoc_of_yojson"><a href="#val-assoc_of_yojson" class="anchor"></a><code><span class="keyword">val</span> assoc_of_yojson : Yojson.Basic.t <span>&#45;&gt;</span> <span>src:string</span> <span>&#45;&gt;</span> <span><span>(string, Yojson.Basic.t)</span> <a href="../IStdlib/index.html#module-IStd">IStdlib.IStd</a>.List.Assoc.t</span></code></dt><dd><p>Verify we have a json object (or empty list) and return the corresponding assoc list. Otherwise die with a message including src.</p></dd></dl><dl><dt class="spec value" id="val-string_of_yojson"><a href="#val-string_of_yojson" class="anchor"></a><code><span class="keyword">val</span> string_of_yojson : Yojson.Basic.t <span>&#45;&gt;</span> <span>src:string</span> <span>&#45;&gt;</span> string</code></dt><dd><p>Verify we have a json string and return the corresponding ocaml string. Otherwise die with a message including src.</p></dd></dl><dl><dt class="spec value" id="val-string_list_of_yojson"><a href="#val-string_list_of_yojson" class="anchor"></a><code><span class="keyword">val</span> string_list_of_yojson : Yojson.Basic.t <span>&#45;&gt;</span> <span>src:string</span> <span>&#45;&gt;</span> <span>string list</span></code></dt><dd><p>Verify we have a json list of strings and return the corresponding ocaml string list. Otherwise die with a message including src.</p></dd></dl><dl><dt class="spec value" id="val-yojson_lookup"><a href="#val-yojson_lookup" class="anchor"></a><code><span class="keyword">val</span> yojson_lookup : <span><span>(string, Yojson.Basic.t)</span> <a href="../IStdlib/index.html#module-IStd">IStdlib.IStd</a>.List.Assoc.t</span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span>src:string</span> <span>&#45;&gt;</span> <span>f:<span>(Yojson.Basic.t <span>&#45;&gt;</span> <span>src:string</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span></span> <span>&#45;&gt;</span> <span>default:<span class="type-var">'a</span></span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>Lookup a json value on an assoc list. If not present, returns default. Otherwise returns (f json_value ~src) where src has element name appended. f is typically one of the above _of_yojson functions.</p></dd></dl><dl><dt class="spec value" id="val-timeit"><a href="#val-timeit" class="anchor"></a><code><span class="keyword">val</span> timeit : <span>f:<span>(unit <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span></span> <span>&#45;&gt;</span> <span class="type-var">'a</span> * int</code></dt><dd><p>Returns the execution time of <code>f</code> in milliseconds together with its result</p></dd></dl><dl><dt class="spec value" id="val-do_in_dir"><a href="#val-do_in_dir" class="anchor"></a><code><span class="keyword">val</span> do_in_dir : <span>dir:string</span> <span>&#45;&gt;</span> <span>f:<span>(unit <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span></span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>executes <code>f</code> after cding into <code>dir</code> and then restores original cwd</p></dd></dl><dl><dt class="spec value" id="val-get_available_memory_MB"><a href="#val-get_available_memory_MB" class="anchor"></a><code><span class="keyword">val</span> get_available_memory_MB : unit <span>&#45;&gt;</span> <span>int option</span></code></dt><dd><p>On Linux systems, return <code>Some x</code> where <code>MemAvailable x</code> is in <code>/proc/meminfo</code>. Returns <code>None</code> in all other cases.</p></dd></dl><dl><dt class="spec value" id="val-iter_infer_deps"><a href="#val-iter_infer_deps" class="anchor"></a><code><span class="keyword">val</span> iter_infer_deps : <span>project_root:string</span> <span>&#45;&gt;</span> <span>f:<span>(string <span>&#45;&gt;</span> unit)</span></span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> unit</code></dt><dd><p>Parse each line of the given infer_deps.txt file (split on tabs, assume 3 elements per line) and run <code>f</code> on the third element. <code>project_root</code> is an argument to avoid dependency cycles.</p></dd></dl><dl><dt class="spec value" id="val-numcores"><a href="#val-numcores" class="anchor"></a><code><span class="keyword">val</span> numcores : int</code></dt><dd><ul><li>On Linux return the number of physical cores (sockets * cores per socket).</li><li>On Darwin and Windows returns half of the number of CPUs since most processors have 2 hardware threads per core.</li></ul></dd></dl><dl><dt class="spec value" id="val-set_best_cpu_for"><a href="#val-set_best_cpu_for" class="anchor"></a><code><span class="keyword">val</span> set_best_cpu_for : int <span>&#45;&gt;</span> unit</code></dt><dd><p>Pins processes to CPUs aiming to saturate physical cores evenly</p></dd></dl><dl><dt class="spec value" id="val-zip_fold_filenames"><a href="#val-zip_fold_filenames" class="anchor"></a><code><span class="keyword">val</span> zip_fold_filenames : <span>init:<span class="type-var">'a</span></span> <span>&#45;&gt;</span> <span>f:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span></span> <span>&#45;&gt;</span> <span>zip_filename:string</span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>fold over each filename in the given <code>zip_filename</code>.</p></dd></dl></div></body></html>