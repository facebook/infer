<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>ClangFrontend__CTrans_utils (infer.ClangFrontend__CTrans_utils)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">infer</a> &#x00BB; ClangFrontend__CTrans_utils</nav><h1>Module <code>ClangFrontend__CTrans_utils</code></h1></header><div class="spec module" id="module-F"><a href="#module-F" class="anchor"></a><code><span class="keyword">module</span> F = Stdlib.Format</code></div><aside><p>Utility methods to support the translation of clang ast constructs into sil instructions.</p></aside><dl><dt class="spec type" id="type-continuation"><a href="#type-continuation" class="anchor"></a><code><span class="keyword">type</span> continuation</code><code> = </code><code>{</code><table class="record"><tr id="type-continuation.break" class="anchored"><td class="def field"><a href="#type-continuation.break" class="anchor"></a><code>break : <span><a href="../IR/Procdesc/Node/index.html#type-t">IR.Procdesc.Node.t</a> list</span>;</code></td></tr><tr id="type-continuation.continue" class="anchored"><td class="def field"><a href="#type-continuation.continue" class="anchor"></a><code>continue : <span><a href="../IR/Procdesc/Node/index.html#type-t">IR.Procdesc.Node.t</a> list</span>;</code></td></tr><tr id="type-continuation.return_temp" class="anchored"><td class="def field"><a href="#type-continuation.return_temp" class="anchor"></a><code>return_temp : bool;</code></td><td class="doc"><p>true if temps should not be removed in the node but returned to ancestors</p></td></tr></table><code>}</code></dt><dt class="spec type" id="type-priority_node"><a href="#type-priority_node" class="anchor"></a><code><span class="keyword">type</span> priority_node</code><code> = </code><table class="variant"><tr id="type-priority_node.Free" class="anchored"><td class="def constructor"><a href="#type-priority_node.Free" class="anchor"></a><code>| </code><code><span class="constructor">Free</span></code></td><td class="doc"><p>no node currently being created</p></td></tr><tr id="type-priority_node.Busy" class="anchored"><td class="def constructor"><a href="#type-priority_node.Busy" class="anchor"></a><code>| </code><code><span class="constructor">Busy</span> <span class="keyword">of</span> <a href="../ATDGenerated/Clang_ast_t/index.html#type-pointer">ATDGenerated.Clang_ast_t.pointer</a></code></td><td class="doc"><p>the translation of the clang expression or statement at <code>pointer</code> will create a node with the collected instructions from the sub-expressions (see <a href="index.html#type-control.instrs"><code>control.instrs</code></a></p></td></tr></table></dt><dd><p>Whether we are collecting instructions for a new block in the CFG (<code>Busy</code>) or there are no blocks being created from enclosing translations (<code>Free</code>)</p></dd></dl><dl><dt class="spec type" id="type-trans_state"><a href="#type-trans_state" class="anchor"></a><code><span class="keyword">type</span> trans_state</code><code> = </code><code>{</code><table class="record"><tr id="type-trans_state.context" class="anchored"><td class="def field"><a href="#type-trans_state.context" class="anchor"></a><code>context : <a href="../ClangFrontend/CContext/index.html#type-t">ClangFrontend.CContext.t</a>;</code></td><td class="doc"><p>global context of the translation</p></td></tr><tr id="type-trans_state.succ_nodes" class="anchored"><td class="def field"><a href="#type-trans_state.succ_nodes" class="anchor"></a><code>succ_nodes : <span><a href="../IR/Procdesc/Node/index.html#type-t">IR.Procdesc.Node.t</a> list</span>;</code></td><td class="doc"><p>successor nodes in the CFG, i.e. instructions that will happen *after* the current expression or statement being translated (note that the CFG is constructed bottom-up, starting from the last instructions)</p></td></tr><tr id="type-trans_state.continuation" class="anchored"><td class="def field"><a href="#type-trans_state.continuation" class="anchor"></a><code>continuation : <span><a href="index.html#type-continuation">continuation</a> option</span>;</code></td><td class="doc"><p>current continuation, used for <code>break</code>, <code>continue</code>, and the like</p></td></tr><tr id="type-trans_state.priority" class="anchored"><td class="def field"><a href="#type-trans_state.priority" class="anchor"></a><code>priority : <a href="index.html#type-priority_node">priority_node</a>;</code></td><td class="doc"><p>see <a href="index.html#type-priority_node"><code>priority_node</code></a></p></td></tr><tr id="type-trans_state.var_exp_typ" class="anchored"><td class="def field"><a href="#type-trans_state.var_exp_typ" class="anchor"></a><code>var_exp_typ : <span><span>(<a href="../IR/Exp/index.html#type-t">IR.Exp.t</a> * <a href="../IR/Typ/index.html#type-t">IR.Typ.t</a>)</span> option</span>;</code></td><td class="doc"><p>the expression (usually of the form <code>Exp.Lvar pvar</code>) that the enclosing expression or statement is trying to initialize, if any</p></td></tr><tr id="type-trans_state.opaque_exp" class="anchored"><td class="def field"><a href="#type-trans_state.opaque_exp" class="anchor"></a><code>opaque_exp : <span><span>(<a href="../IR/Exp/index.html#type-t">IR.Exp.t</a> * <a href="../IR/Typ/index.html#type-t">IR.Typ.t</a>)</span> option</span>;</code></td><td class="doc"><p>needed for translating <code>OpaqueValueExpr</code> nodes</p></td></tr><tr id="type-trans_state.is_fst_arg_objc_instance_method_call" class="anchored"><td class="def field"><a href="#type-trans_state.is_fst_arg_objc_instance_method_call" class="anchor"></a><code>is_fst_arg_objc_instance_method_call : bool;</code></td></tr><tr id="type-trans_state.passed_as_noescape_block_to" class="anchored"><td class="def field"><a href="#type-trans_state.passed_as_noescape_block_to" class="anchor"></a><code>passed_as_noescape_block_to : <span><a href="../IR/Procname/index.html#type-t">IR.Procname.t</a> option</span>;</code></td></tr></table><code>}</code></dt><dd><p>The input of the translation constructed from enclosing expressions.</p></dd></dl><dl><dt class="spec value" id="val-pp_trans_state"><a href="#val-pp_trans_state" class="anchor"></a><code><span class="keyword">val</span> pp_trans_state : <a href="index.html#module-F">F</a>.formatter <span>&#45;&gt;</span> <a href="index.html#type-trans_state">trans_state</a> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-default_trans_state"><a href="#val-default_trans_state" class="anchor"></a><code><span class="keyword">val</span> default_trans_state : <a href="../ClangFrontend/CContext/index.html#type-t">ClangFrontend.CContext.t</a> <span>&#45;&gt;</span> <a href="index.html#type-trans_state">trans_state</a></code></dt></dl><dl><dt class="spec type" id="type-control"><a href="#type-control" class="anchor"></a><code><span class="keyword">type</span> control</code><code> = </code><code>{</code><table class="record"><tr id="type-control.root_nodes" class="anchored"><td class="def field"><a href="#type-control.root_nodes" class="anchor"></a><code>root_nodes : <span><a href="../IR/Procdesc/Node/index.html#type-t">IR.Procdesc.Node.t</a> list</span>;</code></td><td class="doc"><p>Top cfg nodes (root) created by the translation</p></td></tr><tr id="type-control.leaf_nodes" class="anchored"><td class="def field"><a href="#type-control.leaf_nodes" class="anchor"></a><code>leaf_nodes : <span><a href="../IR/Procdesc/Node/index.html#type-t">IR.Procdesc.Node.t</a> list</span>;</code></td><td class="doc"><p>Bottom cfg nodes (leaf) created by the translate</p></td></tr><tr id="type-control.instrs" class="anchored"><td class="def field"><a href="#type-control.instrs" class="anchor"></a><code>instrs : <span><a href="../IR/Sil/index.html#type-instr">IR.Sil.instr</a> list</span>;</code></td><td class="doc"><p>Instructions that need to be placed in the current CFG node being constructed, *after* <code>leaf_nodes</code>.</p></td></tr><tr id="type-control.initd_exps" class="anchored"><td class="def field"><a href="#type-control.initd_exps" class="anchor"></a><code>initd_exps : <span><a href="../IR/Exp/index.html#type-t">IR.Exp.t</a> list</span>;</code></td><td class="doc"><p>list of expressions that are initialized by the instructions</p></td></tr><tr id="type-control.cxx_temporary_markers_set" class="anchored"><td class="def field"><a href="#type-control.cxx_temporary_markers_set" class="anchor"></a><code>cxx_temporary_markers_set : <span><a href="../IR/Pvar/index.html#type-t">IR.Pvar.t</a> list</span>;</code></td><td class="doc"><p>markers for C++ temporaries that have been set during the translation; used to avoid adding the same marker several times</p></td></tr></table><code>}</code></dt><dd><p>Part of the translation result that is (loosely) related to control flow graph construction. More importantly, this is the part of a <code>trans_result</code> that some internal translation functions work on when constructing a <code>trans_result</code> before the other components of the translation result are available (such as the return expression). This is made into a separate type to make intermediate computations easier to write and easier to typecheck.</p></dd></dl><dl><dt class="spec value" id="val-pp_control"><a href="#val-pp_control" class="anchor"></a><code><span class="keyword">val</span> pp_control : <a href="index.html#module-F">F</a>.formatter <span>&#45;&gt;</span> <a href="index.html#type-control">control</a> <span>&#45;&gt;</span> unit</code></dt></dl><dl><dt class="spec type" id="type-trans_result"><a href="#type-trans_result" class="anchor"></a><code><span class="keyword">type</span> trans_result</code><code> = </code><code>{</code><table class="record"><tr id="type-trans_result.control" class="anchored"><td class="def field"><a href="#type-trans_result.control" class="anchor"></a><code>control : <a href="index.html#type-control">control</a>;</code></td></tr><tr id="type-trans_result.return" class="anchored"><td class="def field"><a href="#type-trans_result.return" class="anchor"></a><code>return : <a href="../IR/Exp/index.html#type-t">IR.Exp.t</a> * <a href="../IR/Typ/index.html#type-t">IR.Typ.t</a>;</code></td><td class="doc"><p>value returned by the translated statement</p></td></tr><tr id="type-trans_result.method_name" class="anchored"><td class="def field"><a href="#type-trans_result.method_name" class="anchor"></a><code>method_name : <span><a href="../IR/Procname/index.html#type-t">IR.Procname.t</a> option</span>;</code></td><td class="doc"><p>in the specific case of translating a method call in C++, we get the method name called at the same time we get the <code>this</code> object that contains the method. The <code>this</code> instance object is returned as the <code>return</code> field, while the method to call is filled in here. This field is <code>None</code> in all other cases.</p></td></tr><tr id="type-trans_result.is_cpp_call_virtual" class="anchored"><td class="def field"><a href="#type-trans_result.is_cpp_call_virtual" class="anchor"></a><code>is_cpp_call_virtual : bool;</code></td></tr></table><code>}</code></dt><dd><p>A translation result. It is returned by the translation function.</p></dd></dl><dl><dt class="spec value" id="val-empty_control"><a href="#val-empty_control" class="anchor"></a><code><span class="keyword">val</span> empty_control : <a href="index.html#type-control">control</a></code></dt><dt class="spec value" id="val-mk_trans_result"><a href="#val-mk_trans_result" class="anchor"></a><code><span class="keyword">val</span> mk_trans_result : <span>?&#8288;method_name:<a href="../IR/BuiltinDecl/index.html#type-t">IR.BuiltinDecl.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;is_cpp_call_virtual:bool</span> <span>&#45;&gt;</span> <span>(<a href="../IR/Exp/index.html#type-t">IR.Exp.t</a> * <a href="../IR/Typ/index.html#type-t">IR.Typ.t</a>)</span> <span>&#45;&gt;</span> <a href="index.html#type-control">control</a> <span>&#45;&gt;</span> <a href="index.html#type-trans_result">trans_result</a></code></dt><dt class="spec value" id="val-undefined_expression"><a href="#val-undefined_expression" class="anchor"></a><code><span class="keyword">val</span> undefined_expression : unit <span>&#45;&gt;</span> <a href="../IR/Exp/index.html#type-t">IR.Exp.t</a></code></dt><dt class="spec value" id="val-collect_controls"><a href="#val-collect_controls" class="anchor"></a><code><span class="keyword">val</span> collect_controls : <a href="../IR/Procdesc/index.html#type-t">IR.Procdesc.t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-control">control</a> list</span> <span>&#45;&gt;</span> <a href="index.html#type-control">control</a></code></dt><dd><p>Collect the results of translating a list of instructions, and link up the nodes created.</p></dd></dl><dl><dt class="spec value" id="val-collect_trans_results"><a href="#val-collect_trans_results" class="anchor"></a><code><span class="keyword">val</span> collect_trans_results : <a href="../IR/Procdesc/index.html#type-t">IR.Procdesc.t</a> <span>&#45;&gt;</span> <span>return:<span>(<a href="../IR/Exp/index.html#type-t">IR.Exp.t</a> * <a href="../IR/Typ/index.html#type-t">IR.Typ.t</a>)</span></span> <span>&#45;&gt;</span> <span><a href="index.html#type-trans_result">trans_result</a> list</span> <span>&#45;&gt;</span> <a href="index.html#type-trans_result">trans_result</a></code></dt><dt class="spec value" id="val-is_return_temp"><a href="#val-is_return_temp" class="anchor"></a><code><span class="keyword">val</span> is_return_temp : <span><a href="index.html#type-continuation">continuation</a> option</span> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-mk_cond_continuation"><a href="#val-mk_cond_continuation" class="anchor"></a><code><span class="keyword">val</span> mk_cond_continuation : <span><a href="index.html#type-continuation">continuation</a> option</span> <span>&#45;&gt;</span> <span><a href="index.html#type-continuation">continuation</a> option</span></code></dt><dt class="spec value" id="val-define_condition_side_effects"><a href="#val-define_condition_side_effects" class="anchor"></a><code><span class="keyword">val</span> define_condition_side_effects : <span>(<a href="../IR/Exp/index.html#type-t">IR.Exp.t</a> * <a href="../IR/Typ/index.html#type-t">IR.Typ.t</a>)</span> <span>&#45;&gt;</span> <span><a href="../IR/Sil/index.html#type-instr">IR.Sil.instr</a> list</span> <span>&#45;&gt;</span> <a href="../IBase/Location/index.html#type-t">IBase.Location.t</a> <span>&#45;&gt;</span> <span>(<a href="../IR/Exp/index.html#type-t">IR.Exp.t</a> * <a href="../IR/Typ/index.html#type-t">IR.Typ.t</a>)</span> * <span><a href="../IR/Sil/index.html#type-instr">IR.Sil.instr</a> list</span></code></dt><dt class="spec value" id="val-source_range_of_stmt"><a href="#val-source_range_of_stmt" class="anchor"></a><code><span class="keyword">val</span> source_range_of_stmt : <a href="../ATDGenerated/Clang_ast_t/index.html#type-stmt">ATDGenerated.Clang_ast_t.stmt</a> <span>&#45;&gt;</span> <a href="../ATDGenerated/Clang_ast_t/index.html#type-source_range">ATDGenerated.Clang_ast_t.source_range</a></code></dt><dt class="spec value" id="val-extract_stmt_from_singleton"><a href="#val-extract_stmt_from_singleton" class="anchor"></a><code><span class="keyword">val</span> extract_stmt_from_singleton : <span><a href="../ATDGenerated/Clang_ast_t/index.html#type-stmt">ATDGenerated.Clang_ast_t.stmt</a> list</span> <span>&#45;&gt;</span> <a href="../ATDGenerated/Clang_ast_t/index.html#type-source_range">ATDGenerated.Clang_ast_t.source_range</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="../ATDGenerated/Clang_ast_t/index.html#type-stmt">ATDGenerated.Clang_ast_t.stmt</a></code></dt><dt class="spec value" id="val-is_null_stmt"><a href="#val-is_null_stmt" class="anchor"></a><code><span class="keyword">val</span> is_null_stmt : <a href="../ATDGenerated/Clang_ast_t/index.html#type-stmt">ATDGenerated.Clang_ast_t.stmt</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-dereference_var_sil"><a href="#val-dereference_var_sil" class="anchor"></a><code><span class="keyword">val</span> dereference_var_sil : <span>(<a href="../IR/Exp/index.html#type-t">IR.Exp.t</a> * <a href="../IR/Typ/index.html#type-t">IR.Typ.t</a>)</span> <span>&#45;&gt;</span> <a href="../IBase/Location/index.html#type-t">IBase.Location.t</a> <span>&#45;&gt;</span> <a href="../IR/Sil/index.html#type-instr">IR.Sil.instr</a> * <a href="../IR/Exp/index.html#type-t">IR.Exp.t</a></code></dt><dt class="spec value" id="val-dereference_value_from_result"><a href="#val-dereference_value_from_result" class="anchor"></a><code><span class="keyword">val</span> dereference_value_from_result : <span>?&#8288;strip_pointer:bool</span> <span>&#45;&gt;</span> <a href="../ATDGenerated/Clang_ast_t/index.html#type-source_range">ATDGenerated.Clang_ast_t.source_range</a> <span>&#45;&gt;</span> <a href="../IBase/Location/index.html#type-t">IBase.Location.t</a> <span>&#45;&gt;</span> <a href="index.html#type-trans_result">trans_result</a> <span>&#45;&gt;</span> <a href="index.html#type-trans_result">trans_result</a></code></dt><dd><p>Given a <code>trans_result</code>, create a temporary variable with dereferenced value of an expression assigned to it</p></dd></dl><dl><dt class="spec value" id="val-cast_operation"><a href="#val-cast_operation" class="anchor"></a><code><span class="keyword">val</span> cast_operation : <span>?&#8288;objc_bridge_cast_kind:<a href="../ATDGenerated/Clang_ast_t/index.html#type-obj_c_bridge_cast_kind">ATDGenerated.Clang_ast_t.obj_c_bridge_cast_kind</a></span> <span>&#45;&gt;</span> <a href="../ATDGenerated/Clang_ast_t/index.html#type-cast_kind">ATDGenerated.Clang_ast_t.cast_kind</a> <span>&#45;&gt;</span> <span>(<a href="../IR/Exp/index.html#type-t">IR.Exp.t</a> * <a href="../IR/Typ/index.html#type-t">IR.Typ.t</a>)</span> <span>&#45;&gt;</span> <a href="../IR/Typ/index.html#type-t">IR.Typ.t</a> <span>&#45;&gt;</span> <a href="../IBase/Location/index.html#type-t">IBase.Location.t</a> <span>&#45;&gt;</span> <span><a href="../IR/Sil/index.html#type-instr">IR.Sil.instr</a> list</span> * <span>(<a href="../IR/Exp/index.html#type-t">IR.Exp.t</a> * <a href="../IR/Typ/index.html#type-t">IR.Typ.t</a>)</span></code></dt><dt class="spec value" id="val-trans_assertion"><a href="#val-trans_assertion" class="anchor"></a><code><span class="keyword">val</span> trans_assertion : <a href="index.html#type-trans_state">trans_state</a> <span>&#45;&gt;</span> <a href="../IBase/Location/index.html#type-t">IBase.Location.t</a> <span>&#45;&gt;</span> <a href="index.html#type-trans_result">trans_result</a></code></dt><dt class="spec value" id="val-contains_opaque_value_expr"><a href="#val-contains_opaque_value_expr" class="anchor"></a><code><span class="keyword">val</span> contains_opaque_value_expr : <a href="../ATDGenerated/Clang_ast_t/index.html#type-stmt">ATDGenerated.Clang_ast_t.stmt</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-builtin_trans"><a href="#val-builtin_trans" class="anchor"></a><code><span class="keyword">val</span> builtin_trans : <a href="index.html#type-trans_state">trans_state</a> <span>&#45;&gt;</span> <a href="../ATDGenerated/Clang_ast_t/index.html#type-source_range">ATDGenerated.Clang_ast_t.source_range</a> <span>&#45;&gt;</span> <a href="../IBase/Location/index.html#type-t">IBase.Location.t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-trans_result">trans_result</a> list</span> <span>&#45;&gt;</span> <a href="../IR/Procname/index.html#type-t">IR.Procname.t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-trans_result">trans_result</a> option</span></code></dt><dt class="spec value" id="val-cxx_method_builtin_trans"><a href="#val-cxx_method_builtin_trans" class="anchor"></a><code><span class="keyword">val</span> cxx_method_builtin_trans : <a href="index.html#type-trans_state">trans_state</a> <span>&#45;&gt;</span> <a href="../ATDGenerated/Clang_ast_t/index.html#type-source_range">ATDGenerated.Clang_ast_t.source_range</a> <span>&#45;&gt;</span> <a href="../IBase/Location/index.html#type-t">IBase.Location.t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-trans_result">trans_result</a> list</span> <span>&#45;&gt;</span> <a href="../IR/Procname/index.html#type-t">IR.Procname.t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-trans_result">trans_result</a> option</span></code></dt><dt class="spec value" id="val-new_or_alloc_trans"><a href="#val-new_or_alloc_trans" class="anchor"></a><code><span class="keyword">val</span> new_or_alloc_trans : <a href="index.html#type-trans_state">trans_state</a> <span>&#45;&gt;</span> <a href="../IBase/Location/index.html#type-t">IBase.Location.t</a> <span>&#45;&gt;</span> <a href="../ATDGenerated/Clang_ast_t/index.html#type-stmt_info">ATDGenerated.Clang_ast_t.stmt_info</a> <span>&#45;&gt;</span> <a href="../ATDGenerated/Clang_ast_t/index.html#type-qual_type">ATDGenerated.Clang_ast_t.qual_type</a> <span>&#45;&gt;</span> <span><a href="../IR/Typ/Name/index.html#type-t">IR.Typ.Name.t</a> option</span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-trans_result">trans_result</a></code></dt><dt class="spec value" id="val-cpp_new_trans"><a href="#val-cpp_new_trans" class="anchor"></a><code><span class="keyword">val</span> cpp_new_trans : <a href="../IR/Typ/IntegerWidths/index.html#type-t">IR.Typ.IntegerWidths.t</a> <span>&#45;&gt;</span> <a href="../IBase/Location/index.html#type-t">IBase.Location.t</a> <span>&#45;&gt;</span> <a href="../IR/Typ/index.html#type-t">IR.Typ.t</a> <span>&#45;&gt;</span> <span><a href="../IR/Exp/index.html#type-t">IR.Exp.t</a> option</span> <span>&#45;&gt;</span> <span><span>(<a href="../IR/Exp/index.html#type-t">IR.Exp.t</a> * <a href="../IR/Typ/index.html#type-t">IR.Typ.t</a>)</span> list</span> <span>&#45;&gt;</span> <a href="index.html#type-trans_result">trans_result</a></code></dt></dl><dl><dt class="spec module" id="module-Nodes"><a href="#module-Nodes" class="anchor"></a><code><span class="keyword">module</span> <a href="Nodes/index.html">Nodes</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Module for creating cfg nodes and other utility functions related to them.</p></dd></dl><dl><dt class="spec module" id="module-PriorityNode"><a href="#module-PriorityNode" class="anchor"></a><code><span class="keyword">module</span> <a href="PriorityNode/index.html">PriorityNode</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>priority_node is used to enforce some kind of policy for creating nodes in the cfg. Certain elements of the AST _must_ create nodes therefore there is no need for them to use priority_node. Certain elements instead need or need not to create a node depending of certain factors. When an element of the latter kind wants to create a node it must claim priority first (like taking a lock). priority can be claimes only when it is free. If an element of AST succedes in claiming priority its id (pointer) is recorded in priority. After an element has finished it frees the priority. In general an AST element E checks if an ancestor has claimed priority. If priority is already claimed E does not have to create a node. If priority is free then it means E has to create the node. Then E claims priority and release it afterward.</p></dd></dl><dl><dt class="spec module" id="module-GotoLabel"><a href="#module-GotoLabel" class="anchor"></a><code><span class="keyword">module</span> <a href="GotoLabel/index.html">GotoLabel</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Module for translating goto instructions by keeping a map of labels.</p></dd></dl><dl><dt class="spec module" id="module-Loops"><a href="#module-Loops" class="anchor"></a><code><span class="keyword">module</span> <a href="Loops/index.html">Loops</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Module that provides utility functions for translating different types of loops.</p></dd></dl><dl><dt class="spec module" id="module-Self"><a href="#module-Self" class="anchor"></a><code><span class="keyword">module</span> <a href="Self/index.html">Self</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>This module handles the translation of the variable self which is challenging because self is used both as a variable in instance method calls and also as a type in class method calls.</p></dd></dl><dl><dt class="spec value" id="val-is_logical_negation_of_int"><a href="#val-is_logical_negation_of_int" class="anchor"></a><code><span class="keyword">val</span> is_logical_negation_of_int : <a href="../IR/Tenv/index.html#type-t">IR.Tenv.t</a> <span>&#45;&gt;</span> <a href="../ATDGenerated/Clang_ast_t/index.html#type-expr_info">ATDGenerated.Clang_ast_t.expr_info</a> <span>&#45;&gt;</span> <a href="../ATDGenerated/Clang_ast_t/index.html#type-unary_operator_info">ATDGenerated.Clang_ast_t.unary_operator_info</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-mk_fresh_void_exp_typ"><a href="#val-mk_fresh_void_exp_typ" class="anchor"></a><code><span class="keyword">val</span> mk_fresh_void_exp_typ : unit <span>&#45;&gt;</span> <a href="../IR/Exp/index.html#type-t">IR.Exp.t</a> * <a href="../IR/Typ/index.html#type-t">IR.Typ.t</a></code></dt><dt class="spec value" id="val-mk_fresh_void_id_typ"><a href="#val-mk_fresh_void_id_typ" class="anchor"></a><code><span class="keyword">val</span> mk_fresh_void_id_typ : unit <span>&#45;&gt;</span> <a href="../IR/Ident/index.html#type-t">IR.Ident.t</a> * <a href="../IR/Typ/index.html#type-t">IR.Typ.t</a></code></dt><dt class="spec value" id="val-mk_fresh_void_return"><a href="#val-mk_fresh_void_return" class="anchor"></a><code><span class="keyword">val</span> mk_fresh_void_return : unit <span>&#45;&gt;</span> <span>(<a href="../IR/Ident/index.html#type-t">IR.Ident.t</a> * <a href="../IR/Typ/index.html#type-t">IR.Typ.t</a>)</span> * <span>(<a href="../IR/Exp/index.html#type-t">IR.Exp.t</a> * <a href="../IR/Typ/index.html#type-t">IR.Typ.t</a>)</span></code></dt><dt class="spec value" id="val-last_or_mk_fresh_void_exp_typ"><a href="#val-last_or_mk_fresh_void_exp_typ" class="anchor"></a><code><span class="keyword">val</span> last_or_mk_fresh_void_exp_typ : <span><span>(<a href="../IR/Exp/index.html#type-t">IR.Exp.t</a> * <a href="../IR/Typ/index.html#type-t">IR.Typ.t</a>)</span> list</span> <span>&#45;&gt;</span> <a href="../IR/Exp/index.html#type-t">IR.Exp.t</a> * <a href="../IR/Typ/index.html#type-t">IR.Typ.t</a></code></dt><dt class="spec value" id="val-should_remove_first_param"><a href="#val-should_remove_first_param" class="anchor"></a><code><span class="keyword">val</span> should_remove_first_param : <a href="index.html#type-trans_state">trans_state</a> <span>&#45;&gt;</span> <a href="../ATDGenerated/Clang_ast_t/index.html#type-stmt">ATDGenerated.Clang_ast_t.stmt</a> <span>&#45;&gt;</span> <span><a href="../IR/Typ/index.html#type-name">IR.Typ.name</a> option</span></code></dt><dd><p>Return a class name when the first parameter should be removed according to its context, for example, when <code>self</code> or <code>[x class]</code> is given as the first parameter for a class method.</p></dd></dl></div></body></html>