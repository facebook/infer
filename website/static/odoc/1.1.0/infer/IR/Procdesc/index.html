<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Procdesc (infer.IR.Procdesc)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">infer</a> &#x00BB; <a href="../index.html">IR</a> &#x00BB; Procdesc</nav><h1>Module <code>IR.Procdesc</code></h1><nav class="toc"><ul><li><a href="#per-procedure-cfg">Per-procedure CFG</a></li></ul></nav></header><section><header><h2 id="per-procedure-cfg"><a href="#per-procedure-cfg" class="anchor"></a>Per-procedure CFG</h2></header><div class="spec module" id="module-NodeKey"><a href="#module-NodeKey" class="anchor"></a><code><span class="keyword">module</span> <a href="NodeKey/index.html">NodeKey</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec module" id="module-Node"><a href="#module-Node" class="anchor"></a><code><span class="keyword">module</span> <a href="Node/index.html">Node</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>node of the control flow graph</p></dd></dl><dl><dt class="spec module" id="module-IdMap"><a href="#module-IdMap" class="anchor"></a><code><span class="keyword">module</span> IdMap : <a href="../../IStdlib/PrettyPrintable/index.html#module-type-PPMap">IStdlib.PrettyPrintable.PPMap</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="../../IStdlib/PrettyPrintable/index.html#module-type-PPMap">PPMap</a>.key = <a href="Node/index.html#type-id">Node.id</a></code></dt><dd><p>Map with node id keys.</p></dd></dl><dl><dt class="spec module" id="module-NodeHash"><a href="#module-NodeHash" class="anchor"></a><code><span class="keyword">module</span> NodeHash : <a href="../../IStdlib/index.html#module-IStd">IStdlib.IStd</a>.Caml.Hashtbl.S <span class="keyword">with</span> <span class="keyword">type</span> <a href="index.html#module-NodeHash">NodeHash</a>.key = <a href="Node/index.html#type-t">Node.t</a></code></dt><dd><p>Hash table with nodes as keys.</p></dd></dl><dl><dt class="spec module" id="module-NodeMap"><a href="#module-NodeMap" class="anchor"></a><code><span class="keyword">module</span> NodeMap : <a href="../../IStdlib/index.html#module-IStd">IStdlib.IStd</a>.Caml.Map.S <span class="keyword">with</span> <span class="keyword">type</span> <a href="index.html#module-NodeMap">NodeMap</a>.key = <a href="Node/index.html#type-t">Node.t</a></code></dt><dd><p>Map over nodes.</p></dd></dl><dl><dt class="spec module" id="module-NodeSet"><a href="#module-NodeSet" class="anchor"></a><code><span class="keyword">module</span> NodeSet : <a href="../../IStdlib/index.html#module-IStd">IStdlib.IStd</a>.Caml.Set.S <span class="keyword">with</span> <span class="keyword">type</span> <a href="index.html#module-NodeSet">NodeSet</a>.elt = <a href="Node/index.html#type-t">Node.t</a></code></dt><dd><p>Set of nodes.</p></dd></dl><aside><p>procedure descriptions</p></aside><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code></dt><dd><p>proc description</p></dd></dl><dl><dt class="spec value" id="val-append_locals"><a href="#val-append_locals" class="anchor"></a><code><span class="keyword">val</span> append_locals : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="../ProcAttributes/index.html#type-var_data">ProcAttributes.var_data</a> list</span> <span>&#45;&gt;</span> unit</code></dt><dd><p>append a list of new local variables to the existing list of local variables</p></dd></dl><dl><dt class="spec value" id="val-compute_distance_to_exit_node"><a href="#val-compute_distance_to_exit_node" class="anchor"></a><code><span class="keyword">val</span> compute_distance_to_exit_node : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Compute the distance of each node to the exit node, if not computed already</p></dd></dl><dl><dt class="spec value" id="val-create_node"><a href="#val-create_node" class="anchor"></a><code><span class="keyword">val</span> create_node : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../IBase/Location/index.html#type-t">IBase.Location.t</a> <span>&#45;&gt;</span> <a href="Node/index.html#type-nodekind">Node.nodekind</a> <span>&#45;&gt;</span> <span><a href="../Sil/index.html#type-instr">Sil.instr</a> list</span> <span>&#45;&gt;</span> <a href="Node/index.html#type-t">Node.t</a></code></dt><dd><p>Create a new cfg node with the given location, kind, list of instructions, and add it to the procdesc.</p></dd></dl><dl><dt class="spec value" id="val-create_node_from_not_reversed"><a href="#val-create_node_from_not_reversed" class="anchor"></a><code><span class="keyword">val</span> create_node_from_not_reversed : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../IBase/Location/index.html#type-t">IBase.Location.t</a> <span>&#45;&gt;</span> <a href="Node/index.html#type-nodekind">Node.nodekind</a> <span>&#45;&gt;</span> <a href="../Instrs/index.html#type-not_reversed_t">Instrs.not_reversed_t</a> <span>&#45;&gt;</span> <a href="Node/index.html#type-t">Node.t</a></code></dt><dt class="spec value" id="val-fold_instrs"><a href="#val-fold_instrs" class="anchor"></a><code><span class="keyword">val</span> fold_instrs : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>init:<span class="type-var">'accum</span></span> <span>&#45;&gt;</span> <span>f:<span>(<span class="type-var">'accum</span> <span>&#45;&gt;</span> <a href="Node/index.html#type-t">Node.t</a> <span>&#45;&gt;</span> <a href="../Sil/index.html#type-instr">Sil.instr</a> <span>&#45;&gt;</span> <span class="type-var">'accum</span>)</span></span> <span>&#45;&gt;</span> <span class="type-var">'accum</span></code></dt><dd><p>fold over all nodes and their instructions</p></dd></dl><dl><dt class="spec value" id="val-find_map_instrs"><a href="#val-find_map_instrs" class="anchor"></a><code><span class="keyword">val</span> find_map_instrs : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>f:<span>(<a href="../Sil/index.html#type-instr">Sil.instr</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> option</span>)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> option</span></code></dt><dt class="spec value" id="val-from_proc_attributes"><a href="#val-from_proc_attributes" class="anchor"></a><code><span class="keyword">val</span> from_proc_attributes : <a href="../ProcAttributes/index.html#type-t">ProcAttributes.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Use <code>Cfg.create_proc_desc</code> if you are adding a proc desc to a cfg</p></dd></dl><dl><dt class="spec value" id="val-get_access"><a href="#val-get_access" class="anchor"></a><code><span class="keyword">val</span> get_access : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../ProcAttributes/index.html#type-access">ProcAttributes.access</a></code></dt><dd><p>Return the visibility attribute</p></dd></dl><dl><dt class="spec value" id="val-get_attributes"><a href="#val-get_attributes" class="anchor"></a><code><span class="keyword">val</span> get_attributes : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../ProcAttributes/index.html#type-t">ProcAttributes.t</a></code></dt><dd><p>Get the attributes of the procedure.</p></dd></dl><dl><dt class="spec value" id="val-set_attributes"><a href="#val-set_attributes" class="anchor"></a><code><span class="keyword">val</span> set_attributes : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../ProcAttributes/index.html#type-t">ProcAttributes.t</a> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-get_captured"><a href="#val-get_captured" class="anchor"></a><code><span class="keyword">val</span> get_captured : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="../CapturedVar/index.html#type-t">CapturedVar.t</a> list</span></code></dt><dd><p>Return name and type of block's captured variables</p></dd></dl><dl><dt class="spec value" id="val-get_exit_node"><a href="#val-get_exit_node" class="anchor"></a><code><span class="keyword">val</span> get_exit_node : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="Node/index.html#type-t">Node.t</a></code></dt><dt class="spec value" id="val-get_formals"><a href="#val-get_formals" class="anchor"></a><code><span class="keyword">val</span> get_formals : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><span>(<a href="../Mangled/index.html#type-t">Mangled.t</a> * <a href="../Typ/index.html#type-t">Typ.t</a>)</span> list</span></code></dt><dd><p>Return name and type of formal parameters</p></dd></dl><dl><dt class="spec value" id="val-get_pvar_formals"><a href="#val-get_pvar_formals" class="anchor"></a><code><span class="keyword">val</span> get_pvar_formals : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><span>(<a href="../Pvar/index.html#type-t">Pvar.t</a> * <a href="../Typ/index.html#type-t">Typ.t</a>)</span> list</span></code></dt><dd><p>Return pvar and type of formal parameters</p></dd></dl><dl><dt class="spec value" id="val-get_loc"><a href="#val-get_loc" class="anchor"></a><code><span class="keyword">val</span> get_loc : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../../IBase/Location/index.html#type-t">IBase.Location.t</a></code></dt><dd><p>Return loc information for the procedure</p></dd></dl><dl><dt class="spec value" id="val-get_locals"><a href="#val-get_locals" class="anchor"></a><code><span class="keyword">val</span> get_locals : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="../ProcAttributes/index.html#type-var_data">ProcAttributes.var_data</a> list</span></code></dt><dd><p>Return name and type and attributes of local variables</p></dd></dl><dl><dt class="spec value" id="val-get_nodes"><a href="#val-get_nodes" class="anchor"></a><code><span class="keyword">val</span> get_nodes : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="Node/index.html#type-t">Node.t</a> list</span></code></dt><dt class="spec value" id="val-get_proc_name"><a href="#val-get_proc_name" class="anchor"></a><code><span class="keyword">val</span> get_proc_name : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../Procname/index.html#type-t">Procname.t</a></code></dt><dt class="spec value" id="val-get_ret_type"><a href="#val-get_ret_type" class="anchor"></a><code><span class="keyword">val</span> get_ret_type : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../Typ/index.html#type-t">Typ.t</a></code></dt><dd><p>Return the return type of the procedure and type string</p></dd></dl><dl><dt class="spec value" id="val-has_added_return_param"><a href="#val-has_added_return_param" class="anchor"></a><code><span class="keyword">val</span> has_added_return_param : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-is_ret_type_pod"><a href="#val-is_ret_type_pod" class="anchor"></a><code><span class="keyword">val</span> is_ret_type_pod : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-get_ret_var"><a href="#val-get_ret_var" class="anchor"></a><code><span class="keyword">val</span> get_ret_var : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../Pvar/index.html#type-t">Pvar.t</a></code></dt><dt class="spec value" id="val-get_ret_param_var"><a href="#val-get_ret_param_var" class="anchor"></a><code><span class="keyword">val</span> get_ret_param_var : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../Pvar/index.html#type-t">Pvar.t</a></code></dt><dt class="spec value" id="val-get_start_node"><a href="#val-get_start_node" class="anchor"></a><code><span class="keyword">val</span> get_start_node : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="Node/index.html#type-t">Node.t</a></code></dt><dt class="spec value" id="val-get_static_callees"><a href="#val-get_static_callees" class="anchor"></a><code><span class="keyword">val</span> get_static_callees : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="../Procname/index.html#type-t">Procname.t</a> list</span></code></dt><dd><p>get a list of unique static callees excluding self</p></dd></dl><dl><dt class="spec value" id="val-is_defined"><a href="#val-is_defined" class="anchor"></a><code><span class="keyword">val</span> is_defined : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Return <code>true</code> iff the procedure is defined, and not just declared</p></dd></dl><dl><dt class="spec value" id="val-is_java_synchronized"><a href="#val-is_java_synchronized" class="anchor"></a><code><span class="keyword">val</span> is_java_synchronized : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Return <code>true</code> if the procedure signature has the Java synchronized keyword</p></dd></dl><dl><dt class="spec value" id="val-is_objc_arc_on"><a href="#val-is_objc_arc_on" class="anchor"></a><code><span class="keyword">val</span> is_objc_arc_on : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Return <code>true</code> iff the ObjC procedure is compiled with ARC</p></dd></dl><dl><dt class="spec value" id="val-iter_instrs"><a href="#val-iter_instrs" class="anchor"></a><code><span class="keyword">val</span> iter_instrs : <span>(<a href="Node/index.html#type-t">Node.t</a> <span>&#45;&gt;</span> <a href="../Sil/index.html#type-instr">Sil.instr</a> <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>iterate over all nodes and their instructions</p></dd></dl><dl><dt class="spec value" id="val-replace_instrs"><a href="#val-replace_instrs" class="anchor"></a><code><span class="keyword">val</span> replace_instrs : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>f:<span>(<a href="Node/index.html#type-t">Node.t</a> <span>&#45;&gt;</span> <a href="../Sil/index.html#type-instr">Sil.instr</a> <span>&#45;&gt;</span> <a href="../Sil/index.html#type-instr">Sil.instr</a>)</span></span> <span>&#45;&gt;</span> bool</code></dt><dd><p>Map and replace the instructions to be executed. Returns true if at least one substitution occured.</p></dd></dl><dl><dt class="spec value" id="val-replace_instrs_using_context"><a href="#val-replace_instrs_using_context" class="anchor"></a><code><span class="keyword">val</span> replace_instrs_using_context : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>f:<span>(<a href="Node/index.html#type-t">Node.t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="../Sil/index.html#type-instr">Sil.instr</a> <span>&#45;&gt;</span> <a href="../Sil/index.html#type-instr">Sil.instr</a>)</span></span> <span>&#45;&gt;</span> <span>update_context:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="../Sil/index.html#type-instr">Sil.instr</a> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span></span> <span>&#45;&gt;</span> <span>context_at_node:<span>(<a href="Node/index.html#type-t">Node.t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span></span> <span>&#45;&gt;</span> bool</code></dt><dd><p>Map and replace the instructions to be executed using a context that we built with previous instructions in the node. Returns true if at least one substitution occured.</p></dd></dl><dl><dt class="spec value" id="val-replace_instrs_by_using_context"><a href="#val-replace_instrs_by_using_context" class="anchor"></a><code><span class="keyword">val</span> replace_instrs_by_using_context : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>f:<span>(<a href="Node/index.html#type-t">Node.t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="../Sil/index.html#type-instr">Sil.instr</a> <span>&#45;&gt;</span> <span><a href="../Sil/index.html#type-instr">Sil.instr</a> array</span>)</span></span> <span>&#45;&gt;</span> <span>update_context:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="../Sil/index.html#type-instr">Sil.instr</a> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span></span> <span>&#45;&gt;</span> <span>context_at_node:<span>(<a href="Node/index.html#type-t">Node.t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span></span> <span>&#45;&gt;</span> bool</code></dt><dd><p>Like <code>replace_instrs_using_context</code>, but slower, and each instruction may be replaced by 0, 1, or more instructions.</p></dd></dl><dl><dt class="spec value" id="val-iter_nodes"><a href="#val-iter_nodes" class="anchor"></a><code><span class="keyword">val</span> iter_nodes : <span>(<a href="Node/index.html#type-t">Node.t</a> <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>iterate over all the nodes of a procedure</p></dd></dl><dl><dt class="spec value" id="val-fold_nodes"><a href="#val-fold_nodes" class="anchor"></a><code><span class="keyword">val</span> fold_nodes : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>init:<span class="type-var">'accum</span></span> <span>&#45;&gt;</span> <span>f:<span>(<span class="type-var">'accum</span> <span>&#45;&gt;</span> <a href="Node/index.html#type-t">Node.t</a> <span>&#45;&gt;</span> <span class="type-var">'accum</span>)</span></span> <span>&#45;&gt;</span> <span class="type-var">'accum</span></code></dt><dd><p>fold over all the nodes of a procedure</p></dd></dl><dl><dt class="spec value" id="val-fold_slope_range"><a href="#val-fold_slope_range" class="anchor"></a><code><span class="keyword">val</span> fold_slope_range : <a href="Node/index.html#type-t">Node.t</a> <span>&#45;&gt;</span> <a href="Node/index.html#type-t">Node.t</a> <span>&#45;&gt;</span> <span>init:<span class="type-var">'accum</span></span> <span>&#45;&gt;</span> <span>f:<span>(<span class="type-var">'accum</span> <span>&#45;&gt;</span> <a href="Node/index.html#type-t">Node.t</a> <span>&#45;&gt;</span> <span class="type-var">'accum</span>)</span></span> <span>&#45;&gt;</span> <span class="type-var">'accum</span></code></dt><dd><p>fold between two nodes or until we reach a branching structure</p></dd></dl><dl><dt class="spec value" id="val-set_succs"><a href="#val-set_succs" class="anchor"></a><code><span class="keyword">val</span> set_succs : <a href="Node/index.html#type-t">Node.t</a> <span>&#45;&gt;</span> <span>normal:<span><span><a href="Node/index.html#type-t">Node.t</a> list</span> option</span></span> <span>&#45;&gt;</span> <span>exn:<span><span><a href="Node/index.html#type-t">Node.t</a> list</span> option</span></span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Set the successor nodes and exception nodes, if given, and update predecessor links</p></dd></dl><dl><dt class="spec value" id="val-node_set_succs"><a href="#val-node_set_succs" class="anchor"></a><code><span class="keyword">val</span> node_set_succs : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="Node/index.html#type-t">Node.t</a> <span>&#45;&gt;</span> <span>normal:<span><a href="Node/index.html#type-t">Node.t</a> list</span></span> <span>&#45;&gt;</span> <span>exn:<span><a href="Node/index.html#type-t">Node.t</a> list</span></span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Set the successor nodes and exception nodes, and update predecessor links</p></dd></dl><dl><dt class="spec value" id="val-set_exit_node"><a href="#val-set_exit_node" class="anchor"></a><code><span class="keyword">val</span> set_exit_node : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="Node/index.html#type-t">Node.t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Set the exit node of the procedure</p></dd></dl><dl><dt class="spec value" id="val-set_start_node"><a href="#val-set_start_node" class="anchor"></a><code><span class="keyword">val</span> set_start_node : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="Node/index.html#type-t">Node.t</a> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-get_wto"><a href="#val-get_wto" class="anchor"></a><code><span class="keyword">val</span> get_wto : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="Node/index.html#type-t">Node.t</a> <a href="../WeakTopologicalOrder/Partition/index.html#type-t">WeakTopologicalOrder.Partition.t</a></span></code></dt><dt class="spec value" id="val-is_loop_head"><a href="#val-is_loop_head" class="anchor"></a><code><span class="keyword">val</span> is_loop_head : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="Node/index.html#type-t">Node.t</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-pp_signature"><a href="#val-pp_signature" class="anchor"></a><code><span class="keyword">val</span> pp_signature : Stdlib.Format.formatter <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-pp_local"><a href="#val-pp_local" class="anchor"></a><code><span class="keyword">val</span> pp_local : Stdlib.Format.formatter <span>&#45;&gt;</span> <a href="../ProcAttributes/index.html#type-var_data">ProcAttributes.var_data</a> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-is_specialized"><a href="#val-is_specialized" class="anchor"></a><code><span class="keyword">val</span> is_specialized : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-is_captured_pvar"><a href="#val-is_captured_pvar" class="anchor"></a><code><span class="keyword">val</span> is_captured_pvar : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../Pvar/index.html#type-t">Pvar.t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>true if pvar is a captured variable of a cpp lambda or obcj block</p></dd></dl><dl><dt class="spec value" id="val-is_captured_var"><a href="#val-is_captured_var" class="anchor"></a><code><span class="keyword">val</span> is_captured_var : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../Var/index.html#type-t">Var.t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>true if var is a captured variable of a cpp lambda or obcj block</p></dd></dl><dl><dt class="spec value" id="val-has_modify_in_block_attr"><a href="#val-has_modify_in_block_attr" class="anchor"></a><code><span class="keyword">val</span> has_modify_in_block_attr : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="../Pvar/index.html#type-t">Pvar.t</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-shallow_copy_code_from_pdesc"><a href="#val-shallow_copy_code_from_pdesc" class="anchor"></a><code><span class="keyword">val</span> shallow_copy_code_from_pdesc : <span>orig_pdesc:<a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>dest_pdesc:<a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> unit</code></dt></dl><dl><dt class="spec module" id="module-SQLite"><a href="#module-SQLite" class="anchor"></a><code><span class="keyword">module</span> <a href="SQLite/index.html">SQLite</a> : <a href="../../IBase/SqliteUtils/index.html#module-type-Data">IBase.SqliteUtils.Data</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="../../IBase/SqliteUtils/module-type-Data/index.html#type-t">t</a> = <span><a href="index.html#type-t">t</a> option</span></code></dt><dd><p>per-procedure CFGs are stored in the SQLite &quot;procedures&quot; table as NULL if the procedure has no CFG</p></dd></dl><dl><dt class="spec value" id="val-load"><a href="#val-load" class="anchor"></a><code><span class="keyword">val</span> load : <a href="../Procname/index.html#type-t">Procname.t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> option</span></code></dt></dl></section></div></body></html>