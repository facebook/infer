<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Match (infer.Biabduction.Match)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">infer</a> &#x00BB; <a href="../index.html">Biabduction</a> &#x00BB; Match</nav><h1>Module <code>Biabduction.Match</code></h1></header><aside><p>Implementation of &quot;Smart&quot; Pattern Matching for higher order singly-linked list predicate.</p><p>Used for detecting on a given program if some data scructures are matching some predefined higher-order list predicates. When it is the case, these predicates can be used as possible candidates for abstracting the data-structures. See <a href="http://dx.doi.org/10.1007/978-3-540-73368-3_22">CAV 2007</a> for the therory involved.</p></aside><dl><dt class="spec value" id="val-hpara_match_with_impl"><a href="#val-hpara_match_with_impl" class="anchor"></a><code><span class="keyword">val</span> hpara_match_with_impl : <a href="../../IR/Tenv/index.html#type-t">IR.Tenv.t</a> <span>&#45;&gt;</span> bool <span>&#45;&gt;</span> <a href="../Predicates/index.html#type-hpara">Predicates.hpara</a> <span>&#45;&gt;</span> <a href="../Predicates/index.html#type-hpara">Predicates.hpara</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-hpara_dll_match_with_impl"><a href="#val-hpara_dll_match_with_impl" class="anchor"></a><code><span class="keyword">val</span> hpara_dll_match_with_impl : <a href="../../IR/Tenv/index.html#type-t">IR.Tenv.t</a> <span>&#45;&gt;</span> bool <span>&#45;&gt;</span> <a href="../Predicates/index.html#type-hpara_dll">Predicates.hpara_dll</a> <span>&#45;&gt;</span> <a href="../Predicates/index.html#type-hpara_dll">Predicates.hpara_dll</a> <span>&#45;&gt;</span> bool</code></dt></dl><dl><dt class="spec type" id="type-hpred_pat"><a href="#type-hpred_pat" class="anchor"></a><code><span class="keyword">type</span> hpred_pat</code><code> = </code><code>{</code><table class="record"><tr id="type-hpred_pat.hpred" class="anchored"><td class="def field"><a href="#type-hpred_pat.hpred" class="anchor"></a><code>hpred : <a href="../Predicates/index.html#type-hpred">Predicates.hpred</a>;</code></td></tr><tr id="type-hpred_pat.flag" class="anchored"><td class="def field"><a href="#type-hpred_pat.flag" class="anchor"></a><code>flag : bool;</code></td></tr></table><code>}</code></dt><dd><p>Type for a hpred pattern. <code>flag=false</code> means that the implication between hpreds is not considered, and <code>flag = true</code> means that it is considered during pattern matching.</p></dd></dl><dl><dt class="spec type" id="type-sidecondition"><a href="#type-sidecondition" class="anchor"></a><code><span class="keyword">type</span> sidecondition</code><code> = <span><a href="../Prop/index.html#type-normal">Prop.normal</a> <a href="../Prop/index.html#type-t">Prop.t</a></span> <span>&#45;&gt;</span> <a href="../Predicates/index.html#type-subst">Predicates.subst</a> <span>&#45;&gt;</span> bool</code></dt></dl><dl><dt class="spec value" id="val-prop_match_with_impl"><a href="#val-prop_match_with_impl" class="anchor"></a><code><span class="keyword">val</span> prop_match_with_impl : <a href="../../IR/Tenv/index.html#type-t">IR.Tenv.t</a> <span>&#45;&gt;</span> <span><a href="../Prop/index.html#type-normal">Prop.normal</a> <a href="../Prop/index.html#type-t">Prop.t</a></span> <span>&#45;&gt;</span> <a href="index.html#type-sidecondition">sidecondition</a> <span>&#45;&gt;</span> <span><a href="../../IR/Ident/index.html#type-t">IR.Ident.t</a> list</span> <span>&#45;&gt;</span> <a href="index.html#type-hpred_pat">hpred_pat</a> <span>&#45;&gt;</span> <span><a href="index.html#type-hpred_pat">hpred_pat</a> list</span> <span>&#45;&gt;</span> <span><span>(<a href="../Predicates/index.html#type-subst">Predicates.subst</a> * <span><a href="../Prop/index.html#type-normal">Prop.normal</a> <a href="../Prop/index.html#type-t">Prop.t</a></span>)</span> option</span></code></dt><dd><p><code>prop_match_with_impl p condition vars hpat hpats</code> returns <code>(subst, p_leftover)</code> such that</p><ol><li><code>dom(subst) = vars</code></li><li><code>p |- (hpat.hpred * hpats.hpred)[subst] * p_leftover</code>.</li></ol><p>Using the flag <code>field</code>, we can control the strength of |-.</p></dd></dl><dl><dt class="spec value" id="val-find_partial_iso"><a href="#val-find_partial_iso" class="anchor"></a><code><span class="keyword">val</span> find_partial_iso : <a href="../../IR/Tenv/index.html#type-t">IR.Tenv.t</a> <span>&#45;&gt;</span> <span>(<a href="../../IR/Exp/index.html#type-t">IR.Exp.t</a> <span>&#45;&gt;</span> <a href="../../IR/Exp/index.html#type-t">IR.Exp.t</a> <span>&#45;&gt;</span> bool)</span> <span>&#45;&gt;</span> <span><span>(<a href="../../IR/Exp/index.html#type-t">IR.Exp.t</a> * <a href="../../IR/Exp/index.html#type-t">IR.Exp.t</a>)</span> list</span> <span>&#45;&gt;</span> <span><span>(<a href="../../IR/Exp/index.html#type-t">IR.Exp.t</a> * <a href="../../IR/Exp/index.html#type-t">IR.Exp.t</a>)</span> list</span> <span>&#45;&gt;</span> <span><a href="../Predicates/index.html#type-hpred">Predicates.hpred</a> list</span> <span>&#45;&gt;</span> <span><span>(<span><span>(<a href="../../IR/Exp/index.html#type-t">IR.Exp.t</a> * <a href="../../IR/Exp/index.html#type-t">IR.Exp.t</a>)</span> list</span> * <span><a href="../Predicates/index.html#type-hpred">Predicates.hpred</a> list</span> * <span><a href="../Predicates/index.html#type-hpred">Predicates.hpred</a> list</span> * <span><a href="../Predicates/index.html#type-hpred">Predicates.hpred</a> list</span>)</span> option</span></code></dt><dd><p><code>find_partial_iso</code> finds disjoint isomorphic sub-sigmas inside a given sigma. The first argument is an equality checker. The function returns a partial iso and three sigmas. The first sigma is the first copy of the two isomorphic sigmas, so it uses expressions in the domain of the returned isomorphism. The second is the second copy of the two isomorphic sigmas, and it uses expressions in the range of the isomorphism. The third is the unused part of the input sigma.</p></dd></dl><dl><dt class="spec value" id="val-hpara_iso"><a href="#val-hpara_iso" class="anchor"></a><code><span class="keyword">val</span> hpara_iso : <a href="../../IR/Tenv/index.html#type-t">IR.Tenv.t</a> <span>&#45;&gt;</span> <a href="../Predicates/index.html#type-hpara">Predicates.hpara</a> <span>&#45;&gt;</span> <a href="../Predicates/index.html#type-hpara">Predicates.hpara</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>hpara_iso</code> soundly checks whether two hparas are isomorphic.</p></dd></dl><dl><dt class="spec value" id="val-hpara_dll_iso"><a href="#val-hpara_dll_iso" class="anchor"></a><code><span class="keyword">val</span> hpara_dll_iso : <a href="../../IR/Tenv/index.html#type-t">IR.Tenv.t</a> <span>&#45;&gt;</span> <a href="../Predicates/index.html#type-hpara_dll">Predicates.hpara_dll</a> <span>&#45;&gt;</span> <a href="../Predicates/index.html#type-hpara_dll">Predicates.hpara_dll</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>hpara_dll_iso</code> soundly checks whether two hpara_dlls are isomorphic.</p></dd></dl><dl><dt class="spec value" id="val-hpara_create"><a href="#val-hpara_create" class="anchor"></a><code><span class="keyword">val</span> hpara_create : <a href="../../IR/Tenv/index.html#type-t">IR.Tenv.t</a> <span>&#45;&gt;</span> <span><span>(<a href="../../IR/Exp/index.html#type-t">IR.Exp.t</a> * <a href="../../IR/Exp/index.html#type-t">IR.Exp.t</a>)</span> list</span> <span>&#45;&gt;</span> <span><a href="../Predicates/index.html#type-hpred">Predicates.hpred</a> list</span> <span>&#45;&gt;</span> <a href="../../IR/Exp/index.html#type-t">IR.Exp.t</a> <span>&#45;&gt;</span> <a href="../../IR/Exp/index.html#type-t">IR.Exp.t</a> <span>&#45;&gt;</span> <a href="../Predicates/index.html#type-hpara">Predicates.hpara</a> * <span><a href="../../IR/Exp/index.html#type-t">IR.Exp.t</a> list</span></code></dt><dd><p><code>hpara_create</code> takes a correspondence, and a sigma, a root and a next for the first part of this correspondence. Then, it creates a hpara and discovers a list of shared expressions that are passed as arguments to hpara. Both of them are returned as a result.</p></dd></dl><dl><dt class="spec value" id="val-hpara_dll_create"><a href="#val-hpara_dll_create" class="anchor"></a><code><span class="keyword">val</span> hpara_dll_create : <a href="../../IR/Tenv/index.html#type-t">IR.Tenv.t</a> <span>&#45;&gt;</span> <span><span>(<a href="../../IR/Exp/index.html#type-t">IR.Exp.t</a> * <a href="../../IR/Exp/index.html#type-t">IR.Exp.t</a>)</span> list</span> <span>&#45;&gt;</span> <span><a href="../Predicates/index.html#type-hpred">Predicates.hpred</a> list</span> <span>&#45;&gt;</span> <a href="../../IR/Exp/index.html#type-t">IR.Exp.t</a> <span>&#45;&gt;</span> <a href="../../IR/Exp/index.html#type-t">IR.Exp.t</a> <span>&#45;&gt;</span> <a href="../../IR/Exp/index.html#type-t">IR.Exp.t</a> <span>&#45;&gt;</span> <a href="../Predicates/index.html#type-hpara_dll">Predicates.hpara_dll</a> * <span><a href="../../IR/Exp/index.html#type-t">IR.Exp.t</a> list</span></code></dt><dd><p><code>hpara_dll_create</code> takes a correspondence, and a sigma, a root, a blink and a flink for the first part of this correspondence. Then, it creates a hpara_dll and discovers a list of shared expressions that are passed as arguments to hpara. Both of them are returned as a result.</p></dd></dl></div></body></html>