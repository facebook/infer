<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>HilInstr (infer.Absint.HilInstr)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">infer</a> &#x00BB; <a href="../index.html">Absint</a> &#x00BB; HilInstr</nav><h1>Module <code>Absint.HilInstr</code></h1></header><div class="spec module" id="module-F"><a href="#module-F" class="anchor"></a><code><span class="keyword">module</span> F = Stdlib.Format</code></div><dl><dt class="spec type" id="type-call"><a href="#type-call" class="anchor"></a><code><span class="keyword">type</span> call</code><code> = </code><table class="variant"><tr id="type-call.Direct" class="anchored"><td class="def constructor"><a href="#type-call.Direct" class="anchor"></a><code>| </code><code><span class="constructor">Direct</span> <span class="keyword">of</span> <a href="../../IR/Procname/index.html#type-t">IR.Procname.t</a></code></td></tr><tr id="type-call.Indirect" class="anchored"><td class="def constructor"><a href="#type-call.Indirect" class="anchor"></a><code>| </code><code><span class="constructor">Indirect</span> <span class="keyword">of</span> <a href="../HilExp/index.html#type-t">HilExp.t</a></code></td></tr></table></dt><dd><p>type of a procedure call; either direct or via function pointer</p></dd></dl><div><div class="spec include"><div class="doc"><dl><dt class="spec value" id="val-compare_call"><a href="#val-compare_call" class="anchor"></a><code><span class="keyword">val</span> compare_call : <a href="index.html#type-call">call</a> <span>&#45;&gt;</span> <a href="index.html#type-call">call</a> <span>&#45;&gt;</span> int</code></dt></dl></div></div></div><dl><dt class="spec value" id="val-pp_call"><a href="#val-pp_call" class="anchor"></a><code><span class="keyword">val</span> pp_call : <a href="index.html#module-F">F</a>.formatter <span>&#45;&gt;</span> <a href="index.html#type-call">call</a> <span>&#45;&gt;</span> unit</code></dt></dl><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code><code> = </code><table class="variant"><tr id="type-t.Assign" class="anchored"><td class="def constructor"><a href="#type-t.Assign" class="anchor"></a><code>| </code><code><span class="constructor">Assign</span> <span class="keyword">of</span> <a href="../HilExp/AccessExpression/index.html#type-t">HilExp.AccessExpression.t</a> * <a href="../HilExp/index.html#type-t">HilExp.t</a> * <a href="../../IBase/Location/index.html#type-t">IBase.Location.t</a></code></td><td class="doc"><p>LHS access expression, RHS expression</p></td></tr><tr id="type-t.Assume" class="anchored"><td class="def constructor"><a href="#type-t.Assume" class="anchor"></a><code>| </code><code><span class="constructor">Assume</span> <span class="keyword">of</span> <a href="../HilExp/index.html#type-t">HilExp.t</a> * <span>[ `Then <span>| `Else</span> ]</span> * <a href="../../IR/Sil/index.html#type-if_kind">IR.Sil.if_kind</a> * <a href="../../IBase/Location/index.html#type-t">IBase.Location.t</a></code></td><td class="doc"><p>Assumed expression, true_branch boolean, source of the assume (conditional, ternary, etc.)</p></td></tr><tr id="type-t.Call" class="anchored"><td class="def constructor"><a href="#type-t.Call" class="anchor"></a><code>| </code><code><span class="constructor">Call</span> <span class="keyword">of</span> <a href="../AccessPath/index.html#type-base">AccessPath.base</a> * <a href="index.html#type-call">call</a> * <span><a href="../HilExp/index.html#type-t">HilExp.t</a> list</span> * <a href="../../IR/CallFlags/index.html#type-t">IR.CallFlags.t</a> * <a href="../../IBase/Location/index.html#type-t">IBase.Location.t</a></code></td><td class="doc"><p>Var to hold the return, call expression, formals</p></td></tr><tr id="type-t.Metadata" class="anchored"><td class="def constructor"><a href="#type-t.Metadata" class="anchor"></a><code>| </code><code><span class="constructor">Metadata</span> <span class="keyword">of</span> <a href="../../IR/Sil/index.html#type-instr_metadata">IR.Sil.instr_metadata</a></code></td><td class="doc"><p>see <span class="xref-unresolved" title="unresolved reference to &quot;Sil.instr_metadata&quot;"><code>Sil</code>.instr_metadata</span></p></td></tr></table></dt></dl><div><div class="spec include"><div class="doc"><dl><dt class="spec value" id="val-compare"><a href="#val-compare" class="anchor"></a><code><span class="keyword">val</span> compare : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt></dl></div></div></div><dl><dt class="spec value" id="val-pp"><a href="#val-pp" class="anchor"></a><code><span class="keyword">val</span> pp : <a href="index.html#module-F">F</a>.formatter <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt></dl><dl><dt class="spec type" id="type-translation"><a href="#type-translation" class="anchor"></a><code><span class="keyword">type</span> translation</code><code> = </code><table class="variant"><tr id="type-translation.Instr" class="anchored"><td class="def constructor"><a href="#type-translation.Instr" class="anchor"></a><code>| </code><code><span class="constructor">Instr</span> <span class="keyword">of</span> <a href="index.html#type-t">t</a></code></td><td class="doc"><p>HIL instruction to execute</p></td></tr><tr id="type-translation.Bind" class="anchored"><td class="def constructor"><a href="#type-translation.Bind" class="anchor"></a><code>| </code><code><span class="constructor">Bind</span> <span class="keyword">of</span> <a href="../../IR/Var/index.html#type-t">IR.Var.t</a> * <a href="../HilExp/AccessExpression/index.html#type-t">HilExp.AccessExpression.t</a></code></td><td class="doc"><p>add binding to identifier map</p></td></tr></table></dt><dd><p>Result of translating an SIL instruction</p></dd></dl><dl><dt class="spec value" id="val-of_sil"><a href="#val-of_sil" class="anchor"></a><code><span class="keyword">val</span> of_sil : <span>include_array_indexes:bool</span> <span>&#45;&gt;</span> <span>f_resolve_id:<span>(<a href="../../IR/Var/index.html#type-t">IR.Var.t</a> <span>&#45;&gt;</span> <span><a href="../HilExp/AccessExpression/index.html#type-t">HilExp.AccessExpression.t</a> option</span>)</span></span> <span>&#45;&gt;</span> <a href="../../IR/Sil/index.html#type-instr">IR.Sil.instr</a> <span>&#45;&gt;</span> <a href="index.html#type-translation">translation</a></code></dt><dd><p>convert an SIL instruction into an HIL instruction. The <code>f_resolve_id</code> function should map an SSA temporary variable to the access path it represents. Evaluating the HIL instruction should produce the same result as evaluating the SIL instruction and replacing the temporary variables using <code>f_resolve_id</code>.</p></dd></dl></div></body></html>