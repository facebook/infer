<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>AbstractAddress (infer.Concurrency.AbstractAddress)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">infer</a> &#x00BB; <a href="../index.html">Concurrency</a> &#x00BB; AbstractAddress</nav><h1>Module <code>Concurrency.AbstractAddress</code></h1></header><div class="spec module" id="module-F"><a href="#module-F" class="anchor"></a><code><span class="keyword">module</span> F = Stdlib.Format</code></div><aside><p>Type meant to represent abstract addresses based on access paths. It currently distinguishes between paths</p><ul><li>rooted at formal parameters (these are identified by the parameter index and the path without the root variable, though that variable is kept for pretty printing);</li><li>rooted at global variables;</li><li>non access-path expressions representing class objects (java only).</li></ul><p>Notably, there are no addresses rooted at locals (because proving aliasing between those is difficult).</p><p>There are two notions of equality:</p><ul><li>Equality for comparing two addresses within the same thread/process/trace. Under this, identical globals and identical class objects compare equal. Parameter-rooted paths compare equal if their parameter indices, types and lists of accesses are equal.</li><li>Equality for comparing two addresses in two distinct threads/traces. Globals and class objects are compared in the same way, but parameter-rooted paths need only have equal access lists (ie <code>x.f.g == y.f.g</code>). This allows demonically aliasing parameters in *distinct* threads.</li></ul></aside><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="../../IStdlib/PrettyPrintable/index.html#module-type-PrintableOrderedType">IStdlib.PrettyPrintable.PrintableOrderedType</a></code></span></summary><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="../../IStdlib/index.html#module-IStd">IStdlib.IStd</a>.Caml.Set.OrderedType</code></span></summary><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code></dt></dl><dl><dt class="spec value" id="val-compare"><a href="#val-compare" class="anchor"></a><code><span class="keyword">val</span> compare : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt></dl></details></div></div></div><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="../../IStdlib/PrettyPrintable/index.html#module-type-PrintableType">IStdlib.PrettyPrintable.PrintableType</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="../../IStdlib/PrettyPrintable/module-type-PrintableType/index.html#type-t">t</a> := <a href="index.html#type-t">t</a></code></span></summary><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code></dt></dl><dl><dt class="spec value" id="val-pp"><a href="#val-pp" class="anchor"></a><code><span class="keyword">val</span> pp : <a href="../../IStdlib/PrettyPrintable/index.html#module-F">IStdlib.PrettyPrintable.F</a>.formatter <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt></dl></details></div></div></div></details></div></div></div><dl><dt class="spec value" id="val-describe"><a href="#val-describe" class="anchor"></a><code><span class="keyword">val</span> describe : <a href="index.html#module-F">F</a>.formatter <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>human readable description</p></dd></dl><dl><dt class="spec value" id="val-equal"><a href="#val-equal" class="anchor"></a><code><span class="keyword">val</span> equal : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-equal_across_threads"><a href="#val-equal_across_threads" class="anchor"></a><code><span class="keyword">val</span> equal_across_threads : <a href="../../IR/Tenv/index.html#type-t">IR.Tenv.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dt class="spec value" id="val-root_class"><a href="#val-root_class" class="anchor"></a><code><span class="keyword">val</span> root_class : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="../../IR/Typ/index.html#type-name">IR.Typ.name</a> option</span></code></dt><dd><p>Class of the root variable of the expression representing the address</p></dd></dl><dl><dt class="spec value" id="val-get_typ"><a href="#val-get_typ" class="anchor"></a><code><span class="keyword">val</span> get_typ : <a href="../../IR/Tenv/index.html#type-t">IR.Tenv.t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="../../IR/Typ/index.html#type-t">IR.Typ.t</a> option</span></code></dt><dt class="spec value" id="val-make"><a href="#val-make" class="anchor"></a><code><span class="keyword">val</span> make : <a href="../../Absint/FormalMap/index.html#type-t">Absint.FormalMap.t</a> <span>&#45;&gt;</span> <a href="../../Absint/HilExp/index.html#type-t">Absint.HilExp.t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> option</span></code></dt><dd><p>convert an expression to a canonical form for an address</p></dd></dl><dl><dt class="spec value" id="val-is_class_object"><a href="#val-is_class_object" class="anchor"></a><code><span class="keyword">val</span> is_class_object : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>is the address a Java class object such as in <code>synchronized(MyClass.class){}</code> or <code>static synchronized void foo()</code></p></dd></dl><dl><dt class="spec type" id="type-subst"><a href="#type-subst" class="anchor"></a><code><span class="keyword">type</span> subst</code></dt><dd><p>A substitution from formal position indices to address options. <code>None</code> is used to for actuals that cannot be resolved to an address (eg local-rooted paths or arithmetic expressions).</p></dd></dl><dl><dt class="spec value" id="val-pp_subst"><a href="#val-pp_subst" class="anchor"></a><code><span class="keyword">val</span> pp_subst : <a href="index.html#module-F">F</a>.formatter <span>&#45;&gt;</span> <a href="index.html#type-subst">subst</a> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-make_subst"><a href="#val-make_subst" class="anchor"></a><code><span class="keyword">val</span> make_subst : <a href="../../Absint/FormalMap/index.html#type-t">Absint.FormalMap.t</a> <span>&#45;&gt;</span> <span><a href="../../Absint/HilExp/index.html#type-t">Absint.HilExp.t</a> list</span> <span>&#45;&gt;</span> <a href="index.html#type-subst">subst</a></code></dt><dt class="spec value" id="val-apply_subst"><a href="#val-apply_subst" class="anchor"></a><code><span class="keyword">val</span> apply_subst : <a href="index.html#type-subst">subst</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> option</span></code></dt></dl></div></body></html>