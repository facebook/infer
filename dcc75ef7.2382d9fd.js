(window.webpackJsonp=window.webpackJsonp||[]).push([[43],{179:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return o})),n.d(t,"metadata",(function(){return l})),n.d(t,"rightToc",(function(){return c})),n.d(t,"default",(function(){return s}));var a=n(1),r=n(9),i=(n(0),n(190)),o={id:"linters",title:"Infer : AL"},l={id:"linters",title:"Infer : AL",description:"For C/C++ and Objective-C languages, we provide a linters framework. These are",source:"@site/docs/01-linters.md",permalink:"/docs/linters",sidebar:"docs",previous:{title:"Infer : Eradicate",permalink:"/docs/eradicate"},next:{title:"Infer : RacerD",permalink:"/docs/racerd"}},c=[{value:"AL: A declarative language for writing linters in Infer",id:"al-a-declarative-language-for-writing-linters-in-infer",children:[]},{value:"Getting the clang AST",id:"getting-the-clang-ast",children:[]},{value:"Using AL to write linters",id:"using-al-to-write-linters",children:[]},{value:"Defining Paths",id:"defining-paths",children:[]},{value:"Defining Macros",id:"defining-macros",children:[]},{value:"AL Predicates",id:"al-predicates",children:[]},{value:"AL Formulas",id:"al-formulas",children:[]},{value:"Example checks",id:"example-checks",children:[]},{value:"AST info in messages",id:"ast-info-in-messages",children:[]},{value:"Testing your rule",id:"testing-your-rule",children:[]},{value:"Debugging",id:"debugging",children:[]},{value:"Demo",id:"demo",children:[]},{value:"Command line options for linters",id:"command-line-options-for-linters",children:[]}],b={rightToc:c};function s(e){var t=e.components,n=Object(r.a)(e,["components"]);return Object(i.b)("wrapper",Object(a.a)({},b,n,{components:t,mdxType:"MDXLayout"}),Object(i.b)("p",null,"For C/C++ and Objective-C languages, we provide a linters framework. These are\nchecks about the syntax of the program; it could be about a property, or about\ncode inside one method, or that a class or method have certain properties. We\nprovide ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"/docs/linters-bug-types"}),"a few checks")," and we have developed a domain\nspecific language (DSL) to make it easier to write checks."),Object(i.b)("h2",{id:"al-a-declarative-language-for-writing-linters-in-infer"},"AL: A declarative language for writing linters in Infer"),Object(i.b)("p",null,"One of the major advantage of Infer when compared with other static analyzers is\nthe fact it performs sophisticated inter-procedural/inter-file analysis. That\nis, Infer can detect bugs which involve tracking values through many procedure\ncalls and the procedures may live in different files. These may be very subtle\nbugs and designing static analyses to do that is quite involved and normally\nrequires deep static analysis expertise."),Object(i.b)("p",null,"However, there are many important software bugs that are confined in the code of\na single procedure (called intra-procedural). To detect these bugs simpler\nanalyses may suffice which do not require deep technical expertise in static\nanalysis. Often these bugs can be expressed by referring to the syntax of the\nprogram, or the types of certain expressions. We have defined a new language to\neasily design checkers which identify these kind of bugs. The language is called\nAL (AST Language) and its main feature is the ability to reason about the\nAbstract Syntax Tree of a program in a concise declarative way. AL's checkers\nare interpreted by Infer to analyze programs. Thus, to detect new kind of bugs\nin Infer one can just write a check in AL. We will see in more detail later,\nthat for writing AL formulas we also need predicates: simple functions that\ncheck a property of the AST. Predicates are written in OCaml inside Infer, thus\nit requires a bit of OCaml knowledge and getting familiar with the OCaml data\nstructure for the clang AST."),Object(i.b)("h2",{id:"getting-the-clang-ast"},"Getting the clang AST"),Object(i.b)("p",null,"When you write a linter that traverses the AST of some programs to check some\nproperty, you probably need to understand what the AST looks like. You can get\nthe AST of programs using clang directly, or using Infer."),Object(i.b)("p",null,"If you have a clang command ",Object(i.b)("inlineCode",{parentName:"p"},"clang <clang arguments> File.m")," then you can get\nthe AST with"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-bash"}),"clang <clang arguments> -Xclang -ast-dump -fsyntax-only File.m\n")),Object(i.b)("p",null,"You can also get the AST using Infer. One advantage of this is that you don't\nneed to know the speicifc clang command, just the general build command.\nMoreover, what you get here is exactly the form of the AST that Infer has as\ninput."),Object(i.b)("p",null,"For this you need to install an OCaml package ",Object(i.b)("inlineCode",{parentName:"p"},"biniou")," with\n",Object(i.b)("inlineCode",{parentName:"p"},"opam install biniou"),". See ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://opam.ocaml.org/"}),"the opam website")," for\ninstructions on how to install opam."),Object(i.b)("p",null,"Then, the AST can be created by Infer in debug mode. Call Infer with"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-bash"}),"infer --debug -- <build command>\n")),Object(i.b)("p",null,"This will, among other things, generate a file ",Object(i.b)("inlineCode",{parentName:"p"},"/path/to/File.m.ast.sh")," for\nevery file ",Object(i.b)("inlineCode",{parentName:"p"},"/path/to/File.m")," that is being analyzed. Run this script with\n",Object(i.b)("inlineCode",{parentName:"p"},"bash File.m.ast.sh")," and a file ",Object(i.b)("inlineCode",{parentName:"p"},"/path/to/File.m.ast.bdump")," will be generated,\nthat contains the AST of the program in ",Object(i.b)("inlineCode",{parentName:"p"},"bdump")," format (similar to json). If you\nget an error about ",Object(i.b)("inlineCode",{parentName:"p"},"bdump")," not being found you may need to run\n",Object(i.b)("inlineCode",{parentName:"p"},"eval $(opam env)")," to get the ",Object(i.b)("inlineCode",{parentName:"p"},"bdump")," executable (provided by the biniou opam\npackage) into your ",Object(i.b)("inlineCode",{parentName:"p"},"PATH"),"."),Object(i.b)("p",null,"For general info on the clang AST, you can check out\n",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"http://clang.llvm.org/docs/IntroductionToTheClangAST.html"}),"clang's website"),"."),Object(i.b)("h2",{id:"using-al-to-write-linters"},"Using AL to write linters"),Object(i.b)("p",null,"Let's start with an example. Suppose we want to write the following\nObjective-C's linter:"),Object(i.b)("p",null,Object(i.b)("em",{parentName:"p"},"\"a property containing the word 'delegate', but not containing the word 'queue'\nshould not be declared strong\""),"."),Object(i.b)("p",null,"We can write this property in the following way:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-bash"}),'DEFINE-CHECKER STRONG_DELEGATE_WARNING = {\n\n    LET name_contains_delegate =\n        declaration_has_name(REGEXP("[dD]elegate"));\n\n    LET name_does_not_contain_queue =\n        NOT declaration_has_name(REGEXP("[qQ]ueue"));\n\n    SET report_when =\n        WHEN\n           name_contains_delegate\n           AND name_does_not_contain_queue\n           AND is_strong_property()\n        HOLDS-IN-NODE ObjCPropertyDecl;\n\n    SET message = "Property or ivar %decl_name% declared strong";\n    SET suggestion = "In general delegates should be declared weak or assign";\n    SET severity = "WARNING"\n  };\n')),Object(i.b)("p",null,"The linter definition starts with the keyword ",Object(i.b)("inlineCode",{parentName:"p"},"DEFINE-CHECKER")," followed by the\nchecker's name. The first ",Object(i.b)("inlineCode",{parentName:"p"},"LET")," clause defines the ",Object(i.b)("em",{parentName:"p"},"formula variable"),"\n",Object(i.b)("inlineCode",{parentName:"p"},"name_contains_delegate")," using the predicate ",Object(i.b)("inlineCode",{parentName:"p"},"declaration_has_name")," which return\ntrue/false depending whether the property's name contains a word in the language\nof the regular expression ",Object(i.b)("inlineCode",{parentName:"p"},"[dD]elegate"),". In general a predicate is a simple\natomic formula evaluated on an AST node. The list of available predicates is in\nthe module\n",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/facebook/infer/blob/master/infer/src/clang/cPredicates.mli"}),Object(i.b)("inlineCode",{parentName:"a"},"cPredicates.mli")),"\n(this list is continuously growing and if you need a new predicate you can add\nit in ocaml). Formula variables can be used to simplify other definitions. The\n",Object(i.b)("inlineCode",{parentName:"p"},"SET report_when")," is mandatory and defines a formula that, when evaluates to\ntrue, will tell Infer to report an error. In the case above, the formula is\nsaying that we should report when visiting an ",Object(i.b)("inlineCode",{parentName:"p"},"ObjCPropertyDecl"),' (that is the\nAST node declaring a property in Objective-C) where it holds that: the name\ncontains "delegate/Delegate" (',Object(i.b)("inlineCode",{parentName:"p"},"name_contains_delegate"),') and the name doesn\'t\ncontain "queue/Queue" (',Object(i.b)("inlineCode",{parentName:"p"},"name_does_not_contain_queue"),') and the node is defining a\n"strong" property (',Object(i.b)("inlineCode",{parentName:"p"},"is_strong_property()"),")."),Object(i.b)("p",null,"The ",Object(i.b)("inlineCode",{parentName:"p"},"SET message")," clause defines the error message that will be displayed to the\nuser. Notice that the message can include placeholders like ",Object(i.b)("inlineCode",{parentName:"p"},"%decl_name%"),".\nPlaceholders are evaluated by Infer and substituted by their current value when\nthe error message is reported. In this case the name of the declaration. The\n",Object(i.b)("inlineCode",{parentName:"p"},"SET suggestion")," clause define an optional hint to give to programmer on how to\nfix the problem."),Object(i.b)("p",null,"The general structure of a checker is the following:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-bash"}),"DEFINE-CHECKER id_of_the_checker = {\n\n     LET formula = <formula definition>;\n     LET \u2026.\n\n     SET report_when = <formula definition>;\n\n     SET name = <optional name>;\n     SET message = <error message to show the user>;\n     SET suggestion = <optional suggestion to the user>;\n     SET doc_url = <optional URL to documentation of the issue>;\n     SET severity = INFO | LIKE | ADVICE | WARNING | ERROR;\n     SET mode = ON | OFF\n     SET whitelist_path = {path1, path2, ..., pathn };\n     SET blacklist_path = {path1, path2, ..., pathn };\n  };\n")),Object(i.b)("p",null,"The default severity is ",Object(i.b)("inlineCode",{parentName:"p"},"WARNING")," and the default mode is ",Object(i.b)("inlineCode",{parentName:"p"},"ON"),", so these are\noptional. If the check is ",Object(i.b)("inlineCode",{parentName:"p"},"OFF")," it will only be available in debug mode (flags\n",Object(i.b)("inlineCode",{parentName:"p"},"--debug")," or ",Object(i.b)("inlineCode",{parentName:"p"},"--linters-developer-mode"),"). ",Object(i.b)("inlineCode",{parentName:"p"},"INFOs")," are generally also not\nreported, except with some specialzed flags. ",Object(i.b)("inlineCode",{parentName:"p"},"name")," and ",Object(i.b)("inlineCode",{parentName:"p"},"doc_url")," are used only\nfor CI comments at the moment (in Phabricator)."),Object(i.b)("h2",{id:"defining-paths"},"Defining Paths"),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"whitelist_path")," and ",Object(i.b)("inlineCode",{parentName:"p"},"blacklist_path")," are optional, by default the rule is\nenabled everywhere. For specifying paths, one can use either string constants\n(",Object(i.b)("inlineCode",{parentName:"p"},'"File.m"'),") or regexes (",Object(i.b)("inlineCode",{parentName:"p"},'REGEXP("path/to/.*")'),") or variables. The variables\nstand for a list of paths, and are defined in a separate block:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-bash"}),' GLOBAL-PATHS {\n     path1 = {"A.m", REGEXP("path/to/.*")};\n  };\n')),Object(i.b)("h2",{id:"defining-macros"},"Defining Macros"),Object(i.b)("p",null,"It is possible to define macros that can be used in several checkers. This is\ndone in the following way:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-bash"}),"GLOBAL-MACROS {\n  LET is_subclass_of(x) =\n        is_class(x) HOLDS-IN-SOME-SUPERCLASS-OF ObjCInterfaceDecl;\n };\n")),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"GLOBAL-MACROS")," is the section of an AL specification where one can define a\nlist of global macros. In the example we are defining the macro ",Object(i.b)("inlineCode",{parentName:"p"},"is_subclass(x)"),"\nwhich can now be used in checkers instead of its complex definition."),Object(i.b)("p",null,"It is possible to import a library of macros and paths with the following\ncommand:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{}),"#IMPORT <library.al>\n")),Object(i.b)("p",null,"In an AL file, the command above import and make available all the macros and\npaths defined in the ",Object(i.b)("inlineCode",{parentName:"p"},"library.al")," file."),Object(i.b)("h2",{id:"al-predicates"},"AL Predicates"),Object(i.b)("p",null,"The simplest formulas we can write are predicates. They are defined inside\nInfer. We provide a\n",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/facebook/infer/blob/master/infer/src/clang/cPredicates.mli"}),"library"),",\nbut if the predicate that you require is not available, you will need to extend\nthe library. Here are the some of the currently defined predicates:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{}),'call_class_method ("class_name", "method_name")\ncall_function ("method_name")\ncall_instance_method ("class_name", "method_name")\ncall_method ("method_name")\ncaptures_cxx_references ()\ncontext_in_synchronized_block ()\ndeclaration_has_name ("decl_name")\ndeclaration_ref_name ("decl_ref_name")\ndecl_unavailable_in_supported_ios_sdk ()\nhas_cast_kind("cast_kind") // useful in a cast node\nhas_type ("type") // only builtin types, pointers and Objective-C classes available at the moment\nisa ("class_name")\nis_assign_property ()\nis_binop_with_kind ("kind")\nis_class ("class_name")\nis_const_var ()\nis_global_var ()\nis_ivar_atomic ()\nis_method_property_accessor_of_ivar ()\nis_node ("node_name")\nis_objc_constructor ()\nis_objc_dealloc ()\nis_objc_extension ()\nis_objc_interface_named ("name")\nis_property_pointer_type ()\nis_strong_property ()\nis_weak_property ()\nis_unop_with_kind ("kind")\nmethod_return_type ("type") // only builtin type, pointers, and Objective-C classes available at the moment\nobjc_method_has_nth_parameter_of_type("type")\nusing_namespace("namespace")\nwithin_responds_to_selector_block ()\n')),Object(i.b)("p",null,"In general, the parameters of predicates can be constants, or variables, or\nregular expressions. Variables are used in macros, see below. The syntax for\nusing regexes is ",Object(i.b)("inlineCode",{parentName:"p"},'REGEX("your_reg_exp_here")'),"."),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"NOTE:")," The predicates that expect types, such as ",Object(i.b)("inlineCode",{parentName:"p"},"has_type")," or\n",Object(i.b)("inlineCode",{parentName:"p"},"method_return_type")," or ",Object(i.b)("inlineCode",{parentName:"p"},"objc_method_has_nth_parameter_of_type")," also accept\nregexes, but the syntax is a bit different: ",Object(i.b)("inlineCode",{parentName:"p"},"REGEX('your_reg_exp_here')"),", and\nthis regex can be embedded inside another string, for example:\n",Object(i.b)("inlineCode",{parentName:"p"},"has_type(\"REGEXP('NS.+')*\" )")," which stands for pointer to a class of name\nstarting with NS."),Object(i.b)("p",null,"If you need to add a new predicate, write the predicate in\n",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/facebook/infer/blob/master/infer/src/clang/cPredicates.ml"}),"cPredicates.ml"),"\nand then register it in\n",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/facebook/infer/blob/master/infer/src/clang/cTL.ml#L728"}),"CTL.ml"),"."),Object(i.b)("h2",{id:"al-formulas"},"AL Formulas"),Object(i.b)("p",null,"Formulas are defined using a variation of the\n",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://en.wikipedia.org/wiki/Computation_tree_logic"}),Object(i.b)("em",{parentName:"a"},"CTL temporal logic")),".\nCTL is a logic expressing properties of a tree model. In the case of AL, the\ntree is the AST of the program. Formulas are defined according to the following\ngrammar:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{}),"formula ::= predicate\n          | NOT formula\n          | formula1 OR formula2\n          | formula1 AND formula2\n          | formula1 IMPLIES formula2\n          | formula1 HOLDS-UNTIL formula2\n          | formula1 HOLDS-EVERYWHERE-UNTIL formula2\n          | formula HOLDS-EVENTUALLY\n          | formula HOLDS-EVERYWHERE-EVENTUALLY\n          | formula HOLDS-NEXT\n          | formula HOLDS-EVERYWHERE-NEXT\n          | formula HOLDS-ALWAYS\n          | formula HOLDS-EVERYWHERE-ALWAYS\n          | WHEN formula HOLDS-IN-NODE node-name-list\n          | IN-NODE node-name-list WITH-TRANSITION transition-name\n               formula HOLDS-EVENTUALLY\n")),Object(i.b)("p",null,"The first four cases (",Object(i.b)("inlineCode",{parentName:"p"},"NOT"),", ",Object(i.b)("inlineCode",{parentName:"p"},"OR"),", ",Object(i.b)("inlineCode",{parentName:"p"},"AND"),", ",Object(i.b)("inlineCode",{parentName:"p"},"IMPLIES"),") are classic boolean\noperators with the usual semantics. The others are temporal operators describing\nhow the truth-value of a formula is evaluated in a tree. Let's consider case by\ncase."),Object(i.b)("table",null,Object(i.b)("thead",{parentName:"table"},Object(i.b)("tr",{parentName:"thead"},Object(i.b)("th",Object(a.a)({parentName:"tr"},{align:null}),"Formula"),Object(i.b)("th",Object(a.a)({parentName:"tr"},{align:"center"}),"Semantic meaning"))),Object(i.b)("tbody",{parentName:"table"},Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"F1 ",Object(i.b)("em",{parentName:"td"},"HOLDS-UNTIL")," F2"),Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),"from the current node, there exists a path where F1 holds at every node until F2 becomes true")))),Object(i.b)("p",null,"An example is depicted in the following tree. When ",Object(i.b)("inlineCode",{parentName:"p"},"F1")," or ",Object(i.b)("inlineCode",{parentName:"p"},"F2")," hold in a node\nthis is indicated between square brackets. The formula ",Object(i.b)("inlineCode",{parentName:"p"},"F1 HOLDS-UNTIL F2")," holds\nin the green nodes."),Object(i.b)("p",null,Object(i.b)("img",Object(a.a)({parentName:"p"},{src:"/img/AL/holds_until.jpeg",alt:null}))),Object(i.b)("hr",null),Object(i.b)("table",null,Object(i.b)("thead",{parentName:"table"},Object(i.b)("tr",{parentName:"thead"},Object(i.b)("th",Object(a.a)({parentName:"tr"},{align:null}),"Formula"),Object(i.b)("th",Object(a.a)({parentName:"tr"},{align:"center"}),"Semantic meaning"))),Object(i.b)("tbody",{parentName:"table"},Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"F ",Object(i.b)("em",{parentName:"td"},"HOLDS-EVENTUALLY")),Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),"from the current node there exists a path where at some point F becomes true")))),Object(i.b)("p",null,"In the picture below, as ",Object(i.b)("inlineCode",{parentName:"p"},"F")," holds in ",Object(i.b)("inlineCode",{parentName:"p"},"n10"),", then ",Object(i.b)("inlineCode",{parentName:"p"},"F HOLDS-EVENTUALLY")," holds in\nthe green nodes ",Object(i.b)("inlineCode",{parentName:"p"},"n1"),", ",Object(i.b)("inlineCode",{parentName:"p"},"n7"),", ",Object(i.b)("inlineCode",{parentName:"p"},"n10"),". This is because from these nodes there is a\npath reaching ",Object(i.b)("inlineCode",{parentName:"p"},"n10")," where ",Object(i.b)("inlineCode",{parentName:"p"},"F")," holds. Note that it holds for ",Object(i.b)("inlineCode",{parentName:"p"},"n10")," as well\nbecause there exists a trivial path of length 0 from ",Object(i.b)("inlineCode",{parentName:"p"},"n1")," to itself."),Object(i.b)("p",null,Object(i.b)("img",Object(a.a)({parentName:"p"},{src:"/img/AL/holds_eventually.jpeg",alt:null}))),Object(i.b)("hr",null),Object(i.b)("table",null,Object(i.b)("thead",{parentName:"table"},Object(i.b)("tr",{parentName:"thead"},Object(i.b)("th",Object(a.a)({parentName:"tr"},{align:null}),"Formula"),Object(i.b)("th",Object(a.a)({parentName:"tr"},{align:"center"}),"Semantic meaning"))),Object(i.b)("tbody",{parentName:"table"},Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"F HOLDS-EVERYWHERE-EVENTUALLY"),Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),"in every path starting from the current node at some point F becomes true")))),Object(i.b)("p",null,"For example, in the tree below, the formula holds in every green node because\nevery paths starting from each of them eventually reaches a node where F holds."),Object(i.b)("p",null,Object(i.b)("img",Object(a.a)({parentName:"p"},{src:"/img/AL/holds_everywhere_eventually.jpeg",alt:null}))),Object(i.b)("hr",null),Object(i.b)("table",null,Object(i.b)("thead",{parentName:"table"},Object(i.b)("tr",{parentName:"thead"},Object(i.b)("th",Object(a.a)({parentName:"tr"},{align:null}),"Formula"),Object(i.b)("th",Object(a.a)({parentName:"tr"},{align:"center"}),"Semantic meaning"))),Object(i.b)("tbody",{parentName:"table"},Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"F HOLDS-NEXT"),Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),"from the current node (we are visiting) there exists a child where F is true")))),Object(i.b)("p",null,"In the tree below, the formula ",Object(i.b)("inlineCode",{parentName:"p"},"F HOLDS-NEXT")," it is true only in n1 as it's the\nonly node with a child where ",Object(i.b)("inlineCode",{parentName:"p"},"F")," holds (node n3). In AL, ",Object(i.b)("inlineCode",{parentName:"p"},"NEXT")," is synonym of\nchild as, in terms of a path in the tree, a child is the next node."),Object(i.b)("p",null,Object(i.b)("img",Object(a.a)({parentName:"p"},{src:"/img/AL/holds_next.jpeg",alt:null}))),Object(i.b)("hr",null),Object(i.b)("table",null,Object(i.b)("thead",{parentName:"table"},Object(i.b)("tr",{parentName:"thead"},Object(i.b)("th",Object(a.a)({parentName:"tr"},{align:null}),"Formula"),Object(i.b)("th",Object(a.a)({parentName:"tr"},{align:"center"}),"Semantic meaning"))),Object(i.b)("tbody",{parentName:"table"},Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"F HOLDS-EVERYWHERE-NEXT"),Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),"from the current node in every existing child F is true")))),Object(i.b)("p",null,"In the tree below, the formula ",Object(i.b)("inlineCode",{parentName:"p"},"F HOLDS-EVERYWHERE-NEXT")," it is true in n1 as\nit's the only node for which in every child ",Object(i.b)("inlineCode",{parentName:"p"},"F")," holds (node n2, n3, and n7)."),Object(i.b)("p",null,Object(i.b)("img",Object(a.a)({parentName:"p"},{src:"/img/AL/holds_everywhere_next.jpeg",alt:null}))),Object(i.b)("hr",null),Object(i.b)("table",null,Object(i.b)("thead",{parentName:"table"},Object(i.b)("tr",{parentName:"thead"},Object(i.b)("th",Object(a.a)({parentName:"tr"},{align:null}),"Formula"),Object(i.b)("th",Object(a.a)({parentName:"tr"},{align:"center"}),"Semantic meaning"))),Object(i.b)("tbody",{parentName:"table"},Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"F HOLDS-ALWAYS"),Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),"from the current node there exists a path where F holds at every node")))),Object(i.b)("p",null,"In the tree below ",Object(i.b)("inlineCode",{parentName:"p"},"F HOLDS-ALWAYS")," holds in ",Object(i.b)("inlineCode",{parentName:"p"},"n1"),", ",Object(i.b)("inlineCode",{parentName:"p"},"n2"),", ",Object(i.b)("inlineCode",{parentName:"p"},"n8")," because for each of\nthese nodes there exists a path where ",Object(i.b)("inlineCode",{parentName:"p"},"F")," holds at each node in the path."),Object(i.b)("p",null,Object(i.b)("img",Object(a.a)({parentName:"p"},{src:"/img/AL/always_holds.jpeg",alt:null}))),Object(i.b)("hr",null),Object(i.b)("table",null,Object(i.b)("thead",{parentName:"table"},Object(i.b)("tr",{parentName:"thead"},Object(i.b)("th",Object(a.a)({parentName:"tr"},{align:null}),"Formula"),Object(i.b)("th",Object(a.a)({parentName:"tr"},{align:"center"}),"Semantic meaning"))),Object(i.b)("tbody",{parentName:"table"},Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"F HOLDS-EVERYWHERE-ALWAYS"),Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),"from the current node, in every path F holds at every node")))),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"F HOLDS-EVERYWHERE-ALWAYS")," holds in ",Object(i.b)("inlineCode",{parentName:"p"},"n2"),", ",Object(i.b)("inlineCode",{parentName:"p"},"n4"),", ",Object(i.b)("inlineCode",{parentName:"p"},"n5"),", and ",Object(i.b)("inlineCode",{parentName:"p"},"n8")," because when we\nvisit those nodes in every path that start from them ",Object(i.b)("inlineCode",{parentName:"p"},"F")," holds in every node."),Object(i.b)("p",null,Object(i.b)("img",Object(a.a)({parentName:"p"},{src:"/img/AL/always_holds_everywhere.jpeg",alt:null}))),Object(i.b)("hr",null),Object(i.b)("table",null,Object(i.b)("thead",{parentName:"table"},Object(i.b)("tr",{parentName:"thead"},Object(i.b)("th",Object(a.a)({parentName:"tr"},{align:null}),"Formula"),Object(i.b)("th",Object(a.a)({parentName:"tr"},{align:"center"}),"Semantic meaning"))),Object(i.b)("tbody",{parentName:"table"},Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"WHEN F HOLDS-IN-NODE node1,\u2026,nodeK"),Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),"we are in a node among node1,\u2026,nodeK and F holds")))),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"WHEN F HOLDS-IN-NODE")," ",Object(i.b)("inlineCode",{parentName:"p"},"n2"),", ",Object(i.b)("inlineCode",{parentName:"p"},"n7"),", ",Object(i.b)("inlineCode",{parentName:"p"},"n6")," holds only in node ",Object(i.b)("inlineCode",{parentName:"p"},"n2")," as it is the\nonly node in the list ",Object(i.b)("inlineCode",{parentName:"p"},"n2"),", ",Object(i.b)("inlineCode",{parentName:"p"},"n7"),", ",Object(i.b)("inlineCode",{parentName:"p"},"n6")," where F holds."),Object(i.b)("p",null,Object(i.b)("img",Object(a.a)({parentName:"p"},{src:"/img/AL/holds_in_node.jpeg",alt:null}))),Object(i.b)("p",null,"Let's consider an example of checker using formula\n",Object(i.b)("inlineCode",{parentName:"p"},"WHEN F HOLDS-IN-NODE node1,\u2026,nodeK")," for checking that a property with pointer\ntype should not be declared ",Object(i.b)("em",{parentName:"p"},'"assign"'),":"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{}),'DEFINE-CHECKER ASSIGN_POINTER_WARNING = {\n\n      SET report_when =\n          WHEN\n            is_assign_property() AND is_property_pointer_type()\n          HOLDS-IN-NODE ObjCPropertyDecl;\n\n      SET message = "Property `%decl_name%` is a pointer type marked with the `assign` attribute";\n      SET suggestion = "Use a different attribute like `strong` or `weak`.";\n      SET severity = "WARNING";\n  };\n')),Object(i.b)("p",null,"The checker uses two predefined predicates ",Object(i.b)("inlineCode",{parentName:"p"},"is_assign_property()")," and\n",Object(i.b)("inlineCode",{parentName:"p"},"is_property_pointer_type()")," which are true if the property being declared is\nassign and has a pointer type respectively. We want to check both conditions\nonly on nodes declaring properties, i.e., ",Object(i.b)("inlineCode",{parentName:"p"},"ObjCPropertyDecl"),"."),Object(i.b)("hr",null),Object(i.b)("table",null,Object(i.b)("thead",{parentName:"table"},Object(i.b)("tr",{parentName:"thead"},Object(i.b)("th",Object(a.a)({parentName:"tr"},{align:null}),"Formula"),Object(i.b)("th",Object(a.a)({parentName:"tr"},{align:"center"}),"Semantic meaning"))),Object(i.b)("tbody",{parentName:"table"},Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"IN-NODE node1,\u2026, nodeK WITH-TRANSITION t F HOLDS-EVENTUALLY"),Object(i.b)("td",Object(a.a)({parentName:"tr"},{align:"center"}),"from the current node there exists a path which eventually reaches a node among \u201cnode1,\u2026,nodeK\u201d with a transition t reaching a child where F holds")))),Object(i.b)("p",null,"The following tree explain the concept:"),Object(i.b)("p",null,Object(i.b)("img",Object(a.a)({parentName:"p"},{src:"/img/AL/in_node_with_transition.jpeg",alt:null}))),Object(i.b)("p",null,"The concept of transition is needed because of the special structure of the\nclang AST. Certain kind of nodes, for example statements, have a list of\nchildren that are statements as well. In this case there is no special tag\nattached to the edge between the node and the children. Other nodes have\nrecords, where some of the fields point to other nodes. For example a node\nrepresenting a function declaration will have a record where one of the fields\nis body. This is pointing to a statement representing the function's body. For\nrecords, sometimes we need to specify that we need a particular node reachable\nvia a particular field (i.e., a transition)."),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Hint")," A good way to learn how to write checkers is looking at existing\ncheckers in the file\n",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/facebook/infer/blob/master/infer/lib/linter_rules/linters.al"}),"linters.al"),"."),Object(i.b)("h2",{id:"example-checks"},"Example checks"),Object(i.b)("p",null,"In the following we show a few examples of simple checks you may wish to write\nand the corresponding formulas:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"A check for flagging a Objective-C class that inherits from a class that\nshouldn't be subclassed.")),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{}),'DEFINE-CHECKER SUBCLASSING_TEST_EXAMPLE = {\n   SET report_when = is_class("A") HOLDS-IN-SOME-SUPERCLASS-OF ObjCInterfaceDecl;\n   SET message = "This is subclassing A. Class A should not be subclassed.";\n};\n')),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"A check for flagging an Objective-C instance method call:")),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{}),'DEFINE-CHECKER CALL_INSTANCE_METHOD = {\n  SET report_when = call_instance_method("A", "foo:");\n  SET message = "Do not call this method";\n};\n')),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"A check for flagging an Objective-C instance method call of any method of a\nclass:")),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{}),'DEFINE-CHECKER CALL_ANY_INSTANCE_METHODS = {\n  SET report_when = call_instance_method(A, REGEXP("*"));\n  SET message = "Do not call any method of class A";\n};\n')),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"A check for flagging an Objective-C class method call:")),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{}),'DEFINE-CHECKER CALL_CLASS_METHOD = {\n  SET report_when = call_class_method("A", "foo:");\n  SET message = "Do not call this method";\n};\n')),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"A check for flagging an Objective-C method call of a method with int return\ntype:")),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{}),'DEFINE-CHECKER TEST_RETURN_METHOD = {\n  SET report_when = WHEN method_return_type("int")\n        HOLDS-IN-NODE ObjCMethodDecl;\n  SET message = "Method return int";\n};\n')),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"A check for flagging a variable declaration with type long")),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{}),'DEFINE-CHECKER TEST_VAR_TYPE_CHECK = {\n  SET report_when = WHEN has_type("long")\n        HOLDS-IN-NODE VarDecl;\n  SET message = "Var %name% has type long";\n};\n')),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"A check for flagging a method that has a parameter of type A","*")),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{}),'DEFINE-CHECKER TEST_PARAM_TYPE_CHECK = {\n  LET method_has_a_parameter_with_type(x) =\n        WHEN HOLDS-NEXT WITH-TRANSITION Parameters (has_type(x))\n        HOLDS-IN-NODE ObjCMethodDecl;\n  SET report_when =\n           method_has_a_parameter_with_type("A*" );\n  SET message = "Found a method with a parameter of type A";\n};\n')),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"A check for flagging a method that has all the parameters of type A","*"," (and at\nleast one)")),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{}),'DEFINE-CHECKER TEST_PARAM_TYPE_CHECK2 = {\n  LET method_has_at_least_a_parameter =\n      WHEN HOLDS-NEXT WITH-TRANSITION Parameters (TRUE)\n       HOLDS-IN-NODE ObjCMethodDecl;\n\n   LET method_has_all_parameter_with_type(x) =\n        WHEN HOLDS-EVERYWHERE-NEXT WITH-TRANSITION Parameters (has_type(x))\n        HOLDS-IN-NODE ObjCMethodDecl;\n\n  SET report_when = method_has_at_least_a_parameter AND\n                    method_has_all_parameter_with_type("int");\n  SET message = "All the parameters of the method have type int";\n};\n')),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"A check for flagging a method that has the 2nd parameter of type A","*")),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{}),'DEFINE-CHECKER TEST_NTH_PARAM_TYPE_CHECK = {\n  SET report_when =\n    WHEN objc_method_has_nth_parameter_of_type("2", "A*")\n    HOLDS-IN-NODE ObjCMethodDecl;\n  SET message = "Found a method with the 2nd parameter of type A*";\n  SET severity = "LIKE";\n};\n')),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"A check for flagging a protocol that inherits from a given protocol.\n",Object(i.b)("inlineCode",{parentName:"li"},"HOLDS-EVENTUALLY WITH-TRANSITION Protocol")," means follow the ",Object(i.b)("inlineCode",{parentName:"li"},"Protocol")," branch\nin the AST until the condition holds.")),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{}),'DEFINE-CHECKER TEST_PROTOCOL_DEF_INHERITANCE = {\n  LET is_subprotocol_of(x) = declaration_has_name(x) HOLDS-EVENTUALLY WITH-TRANSITION Protocol;\n  SET report_when =\n    WHEN is_subprotocol_of("P")\n    HOLDS-IN-NODE ObjCProtocolDecl;\n  SET message = "Do not inherit from Protocol P";\n};\n')),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"A check for flagging when a constructor is defined with a parameter of a type\nthat implements a given protocol (or that inherits from it).\n",Object(i.b)("inlineCode",{parentName:"li"},"HOLDS-NEXT WITH-TRANSITION Parameters")," means, starting in the\n",Object(i.b)("inlineCode",{parentName:"li"},"ObjCMethodDecl")," node, follow the ",Object(i.b)("inlineCode",{parentName:"li"},"Parameters")," branch in the AST and check\nthat the condition holds there.")),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{}),'DEFINE-CHECKER TEST_PROTOCOL_TYPE_INHERITANCE = {\n\n  LET method_has_parameter_subprotocol_of(x) =\n            WHEN\n             HOLDS-NEXT WITH-TRANSITION Parameters\n                (has_type_subprotocol_of(x))\n             HOLDS-IN-NODE ObjCMethodDecl;\n\n  SET report_when =\n      WHEN\n        declaration_has_name(REGEXP("^newWith.*:$")) AND\n        method_has_parameter_subprotocol_of("P")\n      HOLDS-IN-NODE ObjCMethodDecl;\n\n  SET message = "Do not define parameters of type P.";\n};\n')),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"A check for flagging a variable declaration of type NSArray applied to A.")),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{}),'DEFINE-CHECKER TEST_GENERICS_TYPE = {\n  SET report_when =\n      WHEN has_type("NSArray<A>*")\n      HOLDS-IN-NODE VarDecl;\n  SET message = "Do not create arrays of type A";\n};\n')),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"A check for flagging using a property or variable that is not available in the\nsupported API. decl_unavailable_in_supported_ios_sdk is a predicate that works\non a declaration, checks the available attribute from the declaration and\ncompares it with the supported iOS SDK. Notice that we flag the occurrence of\nthe variable or property, but the attribute is in the declaration, so we need\nthe transition ",Object(i.b)("inlineCode",{parentName:"li"},"PointerToDecl")," that follows the pointer from the usage to the\ndeclaration.")),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{}),'DEFINE-CHECKER UNAVAILABLE_API_IN_SUPPORTED_IOS_SDK = {\n  SET report_when =\n    WHEN HOLDS-NEXT WITH-TRANSITION PointerToDecl\n     (decl_unavailable_in_supported_ios_sdk() AND\n    HOLDS-IN-NODE DeclRefExpr;\n  SET message = "%name% is not available in the required iOS SDK version";\n};\n')),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"A check for flagging using a given namespace")),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{}),'DEFINE-CHECKER TEST_USING_NAMESPACE = {\n  SET report_when = using_namespace("N");\n  SET message = "Do not use namespace N";\n};\n')),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"A check for flagging the use of given enum constants")),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{}),'DEFINE-CHECKER ENUM_CONSTANTS = {\n  SET report_when = is_enum_constant(REGEXP("MyName.*"));\n  SET message = "Do not use the enum MyName";\n};\n')),Object(i.b)("h2",{id:"ast-info-in-messages"},"AST info in messages"),Object(i.b)("p",null,"When you write the message of your rule, you may want to specify which\nparticular AST items were involved in the issue, such as a type or a variable\nname. We have a mechanism for that, we specified a few placeholders that can be\nused in rules with the syntax ",Object(i.b)("inlineCode",{parentName:"p"},"%placeholder%")," and it will be substituted by the\ncorrect AST info. At the moment we have ",Object(i.b)("inlineCode",{parentName:"p"},"%type%"),", ",Object(i.b)("inlineCode",{parentName:"p"},"%child_type%")," and ",Object(i.b)("inlineCode",{parentName:"p"},"%name%"),"\nthat print the type of the node, the type of the node's child, and a string\nrepresentation of the node, respectively. As with predicates, we can add more as\nneeded."),Object(i.b)("h2",{id:"testing-your-rule"},"Testing your rule"),Object(i.b)("p",null,"To test your rule you need to run it with Infer. If you are adding a new linter\nyou can test it in a separate al file that you can pass to Infer with the option\n",Object(i.b)("inlineCode",{parentName:"p"},"--linters-def-file file.al"),". Pass the option\n",Object(i.b)("inlineCode",{parentName:"p"},"--linters-developer-mode --linter <LINTER_NAME>")," to Infer to print debug\ninformation and only run the linter you are developing, so it will be faster and\nthe debug info will be only about your linter."),Object(i.b)("p",null,"To test your code, write a small example that triggers the rule. Then, run your\ncode with"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{}),"infer --linters-developer-mode --linters-def-file file.al -- clang -c Test.m\n")),Object(i.b)("p",null,"the bug should be printed in the screen, like, for instance:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{}),"infer/tests/codetoanalyze/objcpp/linters/global-var/B.mm:34: warning: GLOBAL_VARIABLE_INITIALIZED_WITH_FUNCTION_OR_METHOD_CALL\n  Global variable kLineSize is initialized using a function or method call at line 34, column 1. If the function/method call is expensive,\n  it can affect the starting time of the app.\n  32.   static float kPadding = [A bar] ? 10.0 : 11.0; // Error\n  33.\n  34. > static const float kLineSize = 1 / [A scale]; // Error\n  35.\n  36.   static const float ok = 37;\n  37.\n")),Object(i.b)("p",null,"Moreover, the bug can be found in the file ",Object(i.b)("inlineCode",{parentName:"p"},"infer-out/report.json")," where\n",Object(i.b)("inlineCode",{parentName:"p"},"infer-out")," is the results directory where Infer operates, that is created in\nthe current directory. You can specify a different directory with the option\n",Object(i.b)("inlineCode",{parentName:"p"},"-o"),"."),Object(i.b)("h2",{id:"debugging"},"Debugging"),Object(i.b)("p",null,"If there are syntax errors or other parsing errors with your al file, you will\nget an error message when testing the rule, remember to use\n",Object(i.b)("inlineCode",{parentName:"p"},"linters-developer-mode")," when you are developing a rule. If the rule gets parsed\nbut still doesn't behave as you expect, you can debug it, by adding the\nfollowing line to a test source file in the line where you want to debug the\nrule: ",Object(i.b)("inlineCode",{parentName:"p"},"//INFER_BREAKPOINT"),". Then run infer again in linters developer mode, and\nit will stop the execution of the linter on the line of the breakpoint. Then you\ncan follow the execution step by step. It shows the current formula that is\nbeing evaluated, and the current part of the AST that is being checked. A red\nnode means that the formula failed, a green node means that it succeeded."),Object(i.b)("h2",{id:"demo"},"Demo"),Object(i.b)("iframe",{src:"https://www.facebook.com/plugins/video.php?href=https%3A%2F%2Fwww.facebook.com%2Finferstaticanalyzer%2Fvideos%2F810308939133850%2F&show_text=0&width=400",width:"500",height:"500",scrolling:"no",frameborder:"0",allowTransparency:"true",allowFullScreen:"true"}),Object(i.b)("h2",{id:"command-line-options-for-linters"},"Command line options for linters"),Object(i.b)("p",null,"The linters are run by default when you run Infer. However, there is a way of\nrunning only the linters, which is faster than also running Infer. This is by\nadding the option ",Object(i.b)("inlineCode",{parentName:"p"},"-a linters")," to the analysis command as in this example:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-bash"}),"infer run -a linters -- clang -c Test.m\n")),Object(i.b)("p",null,"There are a few other command line options that are useful for using or\ndeveloping new linters in Infer. You can get those options with the command\n",Object(i.b)("inlineCode",{parentName:"p"},"infer-capture --help"),":"),Object(i.b)("p",null,Object(i.b)("img",Object(a.a)({parentName:"p"},{src:"/img/AL/linters_help.png",alt:null}))))}s.isMDXComponent=!0},190:function(e,t,n){"use strict";n.d(t,"a",(function(){return p})),n.d(t,"b",(function(){return m}));var a=n(0),r=n.n(a);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var b=r.a.createContext({}),s=function(e){var t=r.a.useContext(b),n=t;return e&&(n="function"==typeof e?e(t):l({},t,{},e)),n},p=function(e){var t=s(e.components);return r.a.createElement(b.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},h=Object(a.forwardRef)((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,o=e.parentName,b=c(e,["components","mdxType","originalType","parentName"]),p=s(n),h=a,m=p["".concat(o,".").concat(h)]||p[h]||d[h]||i;return n?r.a.createElement(m,l({ref:t},b,{components:n})):r.a.createElement(m,l({ref:t},b))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=h;var l={};for(var c in t)hasOwnProperty.call(t,c)&&(l[c]=t[c]);l.originalType=e,l.mdxType="string"==typeof e?e:a,o[1]=l;for(var b=2;b<i;b++)o[b]=n[b];return r.a.createElement.apply(null,o)}return r.a.createElement.apply(null,n)}h.displayName="MDXCreateElement"}}]);