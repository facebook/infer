<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>BufferOverrunDomain (infer.BO.BufferOverrunDomain)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">infer</a> &#x00BB; <a href="../index.html">BO</a> &#x00BB; BufferOverrunDomain</nav><h1>Module <code>BO.BufferOverrunDomain</code></h1></header><dl><dt class="spec module" id="module-ItvThresholds"><a href="#module-ItvThresholds" class="anchor"></a><code><span class="keyword">module</span> ItvThresholds : <a href="../../Absint/AbstractDomain/index.html#module-type-FiniteSetS">Absint.AbstractDomain.FiniteSetS</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="../../Absint/AbstractDomain/index.html#module-type-FiniteSetS">FiniteSetS</a>.elt = Z.t</code></dt><dd><p>Set of integers for threshold widening</p></dd></dl><dl><dt class="spec module" id="module-ItvUpdatedBy"><a href="#module-ItvUpdatedBy" class="anchor"></a><code><span class="keyword">module</span> <a href="ItvUpdatedBy/index.html">ItvUpdatedBy</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Domain for recording which operations are used for evaluating interval values</p></dd></dl><dl><dt class="spec module" id="module-ModeledRange"><a href="#module-ModeledRange" class="anchor"></a><code><span class="keyword">module</span> <a href="ModeledRange/index.html">ModeledRange</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p><code>ModeledRange</code> represents how many times the interval value can be updated by modeled functions. This domain is to support the case where there are mismatches between value of a control variable and actual number of loop iterations. For example,</p></dd></dl><dl><dt class="spec type" id="type-eval_sym_trace"><a href="#type-eval_sym_trace" class="anchor"></a><code><span class="keyword">type</span> eval_sym_trace</code><code> = </code><code>{</code><table class="record"><tr id="type-eval_sym_trace.eval_sym" class="anchored"><td class="def field"><a href="#type-eval_sym_trace.eval_sym" class="anchor"></a><code>eval_sym : <a href="../Bounds/Bound/index.html#type-eval_sym">Bounds.Bound.eval_sym</a>;</code></td><td class="doc"><p>evaluating symbol</p></td></tr><tr id="type-eval_sym_trace.eval_locpath" class="anchored"><td class="def field"><a href="#type-eval_sym_trace.eval_locpath" class="anchor"></a><code>eval_locpath : <a href="../AbsLoc/PowLoc/index.html#type-eval_locpath">AbsLoc.PowLoc.eval_locpath</a>;</code></td><td class="doc"><p>evaluating path</p></td></tr><tr id="type-eval_sym_trace.eval_func_ptrs" class="anchored"><td class="def field"><a href="#type-eval_sym_trace.eval_func_ptrs" class="anchor"></a><code>eval_func_ptrs : <a href="../FuncPtr/Set/index.html#type-eval_func_ptrs">FuncPtr.Set.eval_func_ptrs</a>;</code></td><td class="doc"><p>evaluating function pointers</p></td></tr><tr id="type-eval_sym_trace.trace_of_sym" class="anchored"><td class="def field"><a href="#type-eval_sym_trace.trace_of_sym" class="anchor"></a><code>trace_of_sym : <a href="../Symb/Symbol/index.html#type-t">Symb.Symbol.t</a> <span>&#45;&gt;</span> <a href="../BufferOverrunTrace/Set/index.html#type-t">BufferOverrunTrace.Set.t</a>;</code></td><td class="doc"><p>getting traces of symbol</p></td></tr></table><code>}</code></dt><dd><p>type for on-demand symbol evaluation in Inferbo</p></dd></dl><div class="spec module" id="module-Val"><a href="#module-Val" class="anchor"></a><code><span class="keyword">module</span> <a href="Val/index.html">Val</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec module" id="module-KeyRhs"><a href="#module-KeyRhs" class="anchor"></a><code><span class="keyword">module</span> <a href="KeyRhs/index.html">KeyRhs</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Right hand side of the alias domain. See <code>AliasTarget</code>.</p></dd></dl><div class="spec module" id="module-AliasTarget"><a href="#module-AliasTarget" class="anchor"></a><code><span class="keyword">module</span> <a href="AliasTarget/index.html">AliasTarget</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module" id="module-AliasTargets"><a href="#module-AliasTargets" class="anchor"></a><code><span class="keyword">module</span> <a href="AliasTargets/index.html">AliasTargets</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec module" id="module-AliasRet"><a href="#module-AliasRet" class="anchor"></a><code><span class="keyword">module</span> <a href="AliasRet/index.html">AliasRet</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Alias domain for return values of callees</p></dd></dl><dl><dt class="spec module" id="module-CoreVal"><a href="#module-CoreVal" class="anchor"></a><code><span class="keyword">module</span> <a href="CoreVal/index.html">CoreVal</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p><code>CoreVal</code> is similar to <code>Val</code>, but its compare function is defined only on core parts, interval, pointers, and array blocks, of abstract value. This domain is to keep pruned values, where we do not need to care about the other fields in the abstract values.</p></dd></dl><dl><dt class="spec module" id="module-PruningExp"><a href="#module-PruningExp" class="anchor"></a><code><span class="keyword">module</span> <a href="PruningExp/index.html">PruningExp</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Domain to keep assumed expressions</p></dd></dl><dl><dt class="spec module" id="module-PrunedVal"><a href="#module-PrunedVal" class="anchor"></a><code><span class="keyword">module</span> <a href="PrunedVal/index.html">PrunedVal</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Domain to keep pruned history, which are pairs of a pruned value and an assumed expression</p></dd></dl><dl><dt class="spec module" id="module-PrunePairs"><a href="#module-PrunePairs" class="anchor"></a><code><span class="keyword">module</span> <a href="PrunePairs/index.html">PrunePairs</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p><code>PrunePairs</code> is a map from abstract locations to abstract values that represents pruned results in the latest pruning. It uses <code>InvertedMap</code> because more pruning means smaller abstract states.</p></dd></dl><dl><dt class="spec module" id="module-LatestPrune"><a href="#module-LatestPrune" class="anchor"></a><code><span class="keyword">module</span> <a href="LatestPrune/index.html">LatestPrune</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Domain to keep latest pruned values</p></dd></dl><dl><dt class="spec module" id="module-Reachability"><a href="#module-Reachability" class="anchor"></a><code><span class="keyword">module</span> <a href="Reachability/index.html">Reachability</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Domain for reachability check</p></dd></dl><div class="spec module" id="module-LoopHeadLoc"><a href="#module-LoopHeadLoc" class="anchor"></a><code><span class="keyword">module</span> <a href="LoopHeadLoc/index.html">LoopHeadLoc</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec module" id="module-MemReach"><a href="#module-MemReach" class="anchor"></a><code><span class="keyword">module</span> <a href="MemReach/index.html">MemReach</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Domain for memory of reachable node</p></dd></dl><div class="spec module" id="module-Mem"><a href="#module-Mem" class="anchor"></a><code><span class="keyword">module</span> <a href="Mem/index.html">Mem</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></div></body></html>