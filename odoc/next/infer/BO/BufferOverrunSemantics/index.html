<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>BufferOverrunSemantics (infer.BO.BufferOverrunSemantics)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">infer</a> &#x00BB; <a href="../index.html">BO</a> &#x00BB; BufferOverrunSemantics</nav><header class="odoc-preamble"><h1>Module <code><span>BO.BufferOverrunSemantics</span></code></h1></header><div class="odoc-content"><div class="odoc-spec"><div class="spec value anchored" id="val-is_stack_exp"><a href="#val-is_stack_exp" class="anchor"></a><code><span><span class="keyword">val</span> is_stack_exp : <span><a href="../../IR/Exp/index.html#type-t">IR.Exp.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../BufferOverrunDomain/Mem/index.html#type-t">BufferOverrunDomain.Mem.t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Check if an expression is a stack variable such as <code>n$0</code> or local variable for C array</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-eval"><a href="#val-eval" class="anchor"></a><code><span><span class="keyword">val</span> eval : 
  <span><a href="../../IR/IntegerWidths/index.html#type-t">IR.IntegerWidths.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../IR/Exp/index.html#type-t">IR.Exp.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../BufferOverrunDomain/Mem/index.html#type-t">BufferOverrunDomain.Mem.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="../BufferOverrunDomain/Val/index.html#type-t">BufferOverrunDomain.Val.t</a></span></code></div><div class="spec-doc"><p>Evalute an expression</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-eval_locs"><a href="#val-eval_locs" class="anchor"></a><code><span><span class="keyword">val</span> eval_locs : <span><a href="../../IR/Exp/index.html#type-t">IR.Exp.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../BufferOverrunDomain/Mem/index.html#type-t">BufferOverrunDomain.Mem.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="../AbsLoc/PowLoc/index.html#type-t">AbsLoc.PowLoc.t</a></span></code></div><div class="spec-doc"><p><code>eval_locs exp mem</code> is like <code>eval exp mem |&gt; Val.get_all_locs</code> but takes some shortcuts to avoid computing useless and/or problematic intermediate values</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-eval_arr"><a href="#val-eval_arr" class="anchor"></a><code><span><span class="keyword">val</span> eval_arr : 
  <span><a href="../../IR/IntegerWidths/index.html#type-t">IR.IntegerWidths.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../IR/Exp/index.html#type-t">IR.Exp.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../BufferOverrunDomain/Mem/index.html#type-t">BufferOverrunDomain.Mem.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="../BufferOverrunDomain/Val/index.html#type-t">BufferOverrunDomain.Val.t</a></span></code></div><div class="spec-doc"><p>Return the array value of the input expression. For example, when <code>x</code> is a program variable, <code>eval_arr x</code> returns array blocks the <code>x</code> is pointing to, on the other hand, <code>eval x</code> returns the abstract location of <code>x</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-eval_lindex"><a href="#val-eval_lindex" class="anchor"></a><code><span><span class="keyword">val</span> eval_lindex : 
  <span><a href="../../IR/IntegerWidths/index.html#type-t">IR.IntegerWidths.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../IR/Exp/index.html#type-t">IR.Exp.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../IR/Exp/index.html#type-t">IR.Exp.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../BufferOverrunDomain/Mem/index.html#type-t">BufferOverrunDomain.Mem.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="../BufferOverrunDomain/Val/index.html#type-t">BufferOverrunDomain.Val.t</a></span></code></div><div class="spec-doc"><p>Evaluate array location with index, i.e., <code>eval_lindex integer_type_widths array_exp index_exp mem</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-eval_array_locs_length"><a href="#val-eval_array_locs_length" class="anchor"></a><code><span><span class="keyword">val</span> eval_array_locs_length : 
  <span><a href="../AbsLoc/PowLoc/index.html#type-t">AbsLoc.PowLoc.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">_</span> <a href="../BufferOverrunDomain/Mem/index.html#type-t0">BufferOverrunDomain.Mem.t0</a></span> <span class="arrow">&#45;&gt;</span></span>
  <a href="../BufferOverrunDomain/Val/index.html#type-t">BufferOverrunDomain.Val.t</a></span></code></div><div class="spec-doc"><p>Evaluate length of array locations</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-eval_string_len"><a href="#val-eval_string_len" class="anchor"></a><code><span><span class="keyword">val</span> eval_string_len : 
  <span><a href="../../IR/Exp/index.html#type-t">IR.Exp.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../BufferOverrunDomain/Mem/index.html#type-t">BufferOverrunDomain.Mem.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="../BufferOverrunDomain/Val/index.html#type-t">BufferOverrunDomain.Val.t</a></span></code></div><div class="spec-doc"><p>Evaluate length of C string</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-conservative_array_length"><a href="#val-conservative_array_length" class="anchor"></a><code><span><span class="keyword">val</span> conservative_array_length : 
  <span><span class="optlabel">?traces</span>:<a href="../BufferOverrunTrace/Set/index.html#type-t">BufferOverrunTrace.Set.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../AbsLoc/PowLoc/index.html#type-t">AbsLoc.PowLoc.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">_</span> <a href="../BufferOverrunDomain/Mem/index.html#type-t0">BufferOverrunDomain.Mem.t0</a></span> <span class="arrow">&#45;&gt;</span></span>
  <a href="../BufferOverrunDomain/Val/index.html#type-t">BufferOverrunDomain.Val.t</a></span></code></div><div class="spec-doc"><p>Evaluate the array length conservatively, which is useful when there are multiple array locations and their lengths are joined to top. For example, if the <code>arr_locs</code> points to two arrays <code>a</code> and <code>b</code> and if their lengths are <code>a.length</code> and <code>b.length</code>, this function evaluates its length as <code>[0, a.length.ub + b.length.ub]</code>.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-eval_mode"><a href="#type-eval_mode" class="anchor"></a><code><span><span class="keyword">type</span> eval_mode</span><span> = </span></code><ol><li id="type-eval_mode.EvalNormal" class="def variant constructor anchored"><a href="#type-eval_mode.EvalNormal" class="anchor"></a><code><span>| </span><span><span class="constructor">EvalNormal</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Given a symbolic value of an unknown function <code>Symb.SymbolPath.Callsite</code>, it returns a symbolic interval value.</p><span class="comment-delim">*)</span></div></li><li id="type-eval_mode.EvalPOCond" class="def variant constructor anchored"><a href="#type-eval_mode.EvalPOCond" class="anchor"></a><code><span>| </span><span><span class="constructor">EvalPOCond</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Given a symbolic value of an unknown function, it returns the top interval value. This is used when substituting condition expressions of proof obligations.</p><span class="comment-delim">*)</span></div></li><li id="type-eval_mode.EvalPOReachability" class="def variant constructor anchored"><a href="#type-eval_mode.EvalPOReachability" class="anchor"></a><code><span>| </span><span><span class="constructor">EvalPOReachability</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>This is similar to <code>EvalPOCond</code>, but it returns the bottom location, instead of the unknown location, when a location to substitute is not found. This is used when substituting reachabilities of proof obligations.</p><span class="comment-delim">*)</span></div></li><li id="type-eval_mode.EvalCost" class="def variant constructor anchored"><a href="#type-eval_mode.EvalCost" class="anchor"></a><code><span>| </span><span><span class="constructor">EvalCost</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>This is similar to <code>EvalNormal</code>, but it is designed to be used in substitutions of the cost results, avoiding precision loss by joining of symbolic values. Normal join of two different symbolic values, <code>s1</code> and <code>s2</code>, becomes top due to the limitation of our domain. On the other hand, in this mode, it returns an upperbound <code>s1+s2</code> for the case, because the cost values only care about the upperbounds.</p><span class="comment-delim">*)</span></div></li></ol></div><div class="spec-doc"><p>Several modes of ondemand evaluations</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-mk_eval_sym_trace"><a href="#val-mk_eval_sym_trace" class="anchor"></a><code><span><span class="keyword">val</span> mk_eval_sym_trace : 
  <span><span class="optlabel">?is_args_ref</span>:bool <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../IR/IntegerWidths/index.html#type-t">IR.IntegerWidths.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<a href="../../IR/Pvar/index.html#type-t">IR.Pvar.t</a> * <a href="../../IR/Typ/index.html#type-t">IR.Typ.t</a>)</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<a href="../../IR/Exp/index.html#type-t">IR.Exp.t</a> * <a href="../../IR/Typ/index.html#type-t">IR.Typ.t</a>)</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<a href="../../IR/Exp/index.html#type-t">IR.Exp.t</a> * <a href="../../IR/Pvar/index.html#type-t">IR.Pvar.t</a> * <a href="../../IR/Typ/index.html#type-t">IR.Typ.t</a> * <a href="../../IR/CapturedVar/index.html#type-capture_mode">IR.CapturedVar.capture_mode</a>)</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../BufferOverrunDomain/Mem/index.html#type-t">BufferOverrunDomain.Mem.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">mode</span>:<a href="#type-eval_mode">eval_mode</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="../BufferOverrunDomain/index.html#type-eval_sym_trace">BufferOverrunDomain.eval_sym_trace</a></span></code></div><div class="spec-doc"><p>Make <code>eval_sym</code> function for on-demand symbol evaluation</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-mk_eval_sym_cost"><a href="#val-mk_eval_sym_cost" class="anchor"></a><code><span><span class="keyword">val</span> mk_eval_sym_cost : 
  <span><a href="../../IR/IntegerWidths/index.html#type-t">IR.IntegerWidths.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<a href="../../IR/Pvar/index.html#type-t">IR.Pvar.t</a> * <a href="../../IR/Typ/index.html#type-t">IR.Typ.t</a>)</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<a href="../../IR/Exp/index.html#type-t">IR.Exp.t</a> * <a href="../../IR/Typ/index.html#type-t">IR.Typ.t</a>)</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<a href="../../IR/Exp/index.html#type-t">IR.Exp.t</a> * <a href="../../IR/Pvar/index.html#type-t">IR.Pvar.t</a> * <a href="../../IR/Typ/index.html#type-t">IR.Typ.t</a> * <a href="../../IR/CapturedVar/index.html#type-capture_mode">IR.CapturedVar.capture_mode</a>)</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../BufferOverrunDomain/Mem/index.html#type-t">BufferOverrunDomain.Mem.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="../BufferOverrunDomain/index.html#type-eval_sym_trace">BufferOverrunDomain.eval_sym_trace</a></span></code></div><div class="spec-doc"><p>Make <code>eval_sym</code> function of <code>EvalCost</code> mode for on-demand symbol evaluation</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Prune"><a href="#module-Prune" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Prune/index.html">Prune</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div></div></body></html>
