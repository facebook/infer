"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[1847],{5676:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>a,toc:()=>l});var s=n(4848),t=n(8453);const r={title:"Purity",description:'Detects pure (side-effect-free) functions. A different implementation of "impurity".'},o=void 0,a={id:"checker-purity",title:"Purity",description:'Detects pure (side-effect-free) functions. A different implementation of "impurity".',source:"@site/versioned_docs/version-1.2.0/checker-purity.md",sourceDirName:".",slug:"/checker-purity",permalink:"/docs/checker-purity",draft:!1,unlisted:!1,tags:[],version:"1.2.0",frontMatter:{title:"Purity",description:'Detects pure (side-effect-free) functions. A different implementation of "impurity".'},sidebar:"docs",previous:{title:"Pulse",permalink:"/docs/checker-pulse"},next:{title:"Quandary",permalink:"/docs/checker-quandary"}},c={},l=[{value:"Weaknesses",id:"weaknesses",level:2},{value:"List of Issue Types",id:"list-of-issue-types",level:2}];function d(e){const i={a:"a",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(i.p,{children:'Detects pure (side-effect-free) functions. A different implementation of "impurity".'}),"\n",(0,s.jsxs)(i.p,{children:["Activate with ",(0,s.jsx)(i.code,{children:"--purity"}),"."]}),"\n",(0,s.jsx)(i.p,{children:"Supported languages:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"C/C++/ObjC: Experimental"}),"\n",(0,s.jsx)(i.li,{children:"C#/.Net: No"}),"\n",(0,s.jsx)(i.li,{children:"Erlang: No"}),"\n",(0,s.jsx)(i.li,{children:"Hack: No"}),"\n",(0,s.jsx)(i.li,{children:"Java: Experimental"}),"\n",(0,s.jsx)(i.li,{children:"Python: No"}),"\n"]}),"\n",(0,s.jsx)(i.p,{children:"This is an experimental inter-procedural analysis that detects pure (side-effect free) functions. For each function, purity analysis keeps track of not only the purity of the function but also some additional information such as whether the function modifies a global variable or which of the parameters are modified. It models functions with no summary/model as modifying the global state (hence impure)."}),"\n",(0,s.jsxs)(i.p,{children:["If the function is pure (i.e. doesn't modify any global state or its parameters and doesn't call any unknown functions), then it reports an ",(0,s.jsx)(i.a,{href:"/docs/all-issue-types#pure_function",children:(0,s.jsx)(i.code,{children:"PURE_FUNCTION"})})," issue."]}),"\n",(0,s.jsx)(i.h2,{id:"weaknesses",children:"Weaknesses"}),"\n",(0,s.jsx)(i.p,{children:"There are two issues with the existing purity analysis:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"In order to detect which parameters are modified, we need an alias analysis which is difficult to get right."}),"\n",(0,s.jsx)(i.li,{children:"Just keeping track of modified arguments doesn't suffice."}),"\n"]}),"\n",(0,s.jsx)(i.p,{children:"Too see the issue with the first point, consider the following simple program:"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-java",children:"void foo(Foo a){\n  Foo b = a;\n  b.x = 10; \n}\n"})}),"\n",(0,s.jsxs)(i.p,{children:["in order to determine that ",(0,s.jsx)(i.code,{children:"foo"})," is impure, we need to know that the write to ",(0,s.jsx)(i.code,{children:"b"}),"'s field is actually changing the function parameter ",(0,s.jsx)(i.code,{children:"a"}),", i.e. we need to check if ",(0,s.jsx)(i.code,{children:"b"})," is aliasing ",(0,s.jsx)(i.code,{children:"a"}),". This is known as alias analysis and is hard to get right in a scalable manner. When this analysis was being developed, Infer didn't have a unified alias analysis and using biabduction seemed like a too daunting task at the time. Hence, we relied on ",(0,s.jsx)(i.a,{href:"/docs/checker-bufferoverrun",children:"InferBo"}),"'s aliasing mechanism which was easy to invoke and integrate with. However, InferBo's aliasing analysis is far from perfect and causes issues for purity.\nTo see the issue with the second point, consider the following program:"]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-java",children:"boolean contains(Integer i, ArrayList<Integer> list){\n  Iterator<Integer> listIterator = list.iterator();\n  while(listIterator.hasNext()) {\n    Integer el = listIterator.next();\n    if (i.equals(el)){\n      return true;\n    }\n  }\n  return false;\n }\n"})}),"\n",(0,s.jsxs)(i.p,{children:["The existing purity analysis concludes that the above function ",(0,s.jsx)(i.code,{children:"contains"})," is impure because it calls an impure function ",(0,s.jsx)(i.code,{children:"next()"})," which modifies the iterator (hence it thinks it also modifies the ",(0,s.jsx)(i.code,{children:"list"}),"). However, notice that ",(0,s.jsx)(i.code,{children:"contains"})," doesn't have an observable side-effect: ",(0,s.jsx)(i.code,{children:"list.iterator()"})," returns a new object, ",(0,s.jsx)(i.code,{children:"hasNext()"})," and ",(0,s.jsx)(i.code,{children:"equals()"})," are pure, and ",(0,s.jsx)(i.code,{children:"next()"})," only modifies the fields of the fresh object ",(0,s.jsx)(i.code,{children:"listIterator"}),".  Therefore, ",(0,s.jsx)(i.code,{children:"contains"})," should be considered as pure."]}),"\n",(0,s.jsxs)(i.p,{children:["To alleviate this problem, we have developed an ",(0,s.jsx)(i.a,{href:"/docs/checker-impurity",children:"Impurity"})," analysis which uses ",(0,s.jsx)(i.a,{href:"/docs/checker-pulse",children:"pulse"})," which can successfully analyze this program as pure \\o/"]}),"\n",(0,s.jsx)(i.p,{children:"The analysis is used by:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.a,{href:"/docs/checker-loop-hoisting",children:"Loop-hoisting"})," analysis which identifies loop-invariant function calls, i.e. functions that are pure and have loop-invariant arguments."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.a,{href:"/docs/checker-cost",children:"Cost"})," analysis which identifies control variables in the loop that affect how many times a loop is executed. In this computation, we need to prune control variables that do not affect how many times a loop is executed. In this pruning step, we need to compute loop-invariant variables (which requires the above analysis)."]}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"list-of-issue-types",children:"List of Issue Types"}),"\n",(0,s.jsx)(i.p,{children:"The following issue types are reported by this checker:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:(0,s.jsx)(i.a,{href:"/docs/all-issue-types#pure_function",children:"PURE_FUNCTION"})}),"\n"]})]})}function h(e={}){const{wrapper:i}={...(0,t.R)(),...e.components};return i?(0,s.jsx)(i,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,i,n)=>{n.d(i,{R:()=>o,x:()=>a});var s=n(6540);const t={},r=s.createContext(t);function o(e){const i=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function a(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),s.createElement(r.Provider,{value:i},e.children)}}}]);