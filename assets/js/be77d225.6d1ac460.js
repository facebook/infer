"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[1463],{2064:(e,n,r)=>{r.d(n,{A:()=>a});const a=r.p+"assets/files/pldi17-infer-ai-tutorial-0bf9edf257df128281cb6a20bb6309bf.pdf"},7462:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>o,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"absint-framework","title":"Building checkers with the Infer.AI framework","description":"Infer.AI is a framework for quickly developing abstract interpretation-based","source":"@site/versioned_docs/version-1.1.0/04-absint-framework.md","sourceDirName":".","slug":"/absint-framework","permalink":"/docs/1.1.0/absint-framework","draft":false,"unlisted":false,"tags":[],"version":"1.1.0","sidebarPosition":4,"frontMatter":{"id":"absint-framework","title":"Building checkers with the Infer.AI framework"},"sidebar":"docs","previous":{"title":"Separation logic and bi-abduction","permalink":"/docs/1.1.0/separation-logic-and-bi-abduction"},"next":{"title":"Infer Internal OCaml Modules API","permalink":"/docs/1.1.0/internal-API"}}');var s=r(4848),t=r(8453);const o={id:"absint-framework",title:"Building checkers with the Infer.AI framework"},i=void 0,c={},l=[{value:"By example: intraprocedural analysis",id:"by-example-intraprocedural-analysis",level:2},{value:"Error reporting",id:"error-reporting",level:2},{value:"By example: interprocedural analysis",id:"by-example-interprocedural-analysis",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"Infer.AI is a framework for quickly developing abstract interpretation-based\ncheckers (intraprocedural or interprocedural). You define only:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["An abstract domain (type of abstract state plus ",(0,s.jsx)(n.code,{children:"<="}),", ",(0,s.jsx)(n.code,{children:"join"}),", and ",(0,s.jsx)(n.code,{children:"widen"}),"\noperations)"]}),"\n",(0,s.jsx)(n.li,{children:"Transfer functions (a transformer that takes an abstract state as input and\nproduces an abstract state as output)"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"What you get in exchange is an analysis that can run on all of the\nlanguages Infer supports (C, Objective-C, C++, and Java)!"}),"\n",(0,s.jsxs)(n.p,{children:["This guide covers how to use the framework. For background on why we built the\nframework and how it works, check out these\n",(0,s.jsx)(n.a,{target:"_blank","data-noBrokenLinkCheck":!0,href:r(2064).A+"",children:"slides"})," from a PLDI\n2017 tutorial and this\n",(0,s.jsx)(n.a,{href:"https://atscaleconference.com/videos/getting-the-most-out-of-static-analyzers",children:"talk"}),"\nfrom @Scale2016."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsxs)(n.strong,{children:["If you feel like coding instead of reading, a great way to get started with\nInfer.AI is to go through the lab exercise\n",(0,s.jsx)(n.a,{href:"https://github.com/facebook/infer/blob/main/infer/src/labs/README.md",children:"here"}),"."]})}),"\n",(0,s.jsx)(n.h2,{id:"by-example-intraprocedural-analysis",children:"By example: intraprocedural analysis"}),"\n",(0,s.jsxs)(n.p,{children:["This section helps you get started ASAP if you already understand\n",(0,s.jsx)(n.a,{href:"http://www.di.ens.fr/~cousot/AI/IntroAbsInt.html",children:"abstract interpretation"})," (or\ndon't, but are feeling bold)."]}),"\n",(0,s.jsxs)(n.p,{children:["Take a look at\n",(0,s.jsx)(n.a,{href:"https://github.com/facebook/infer/blob/main/infer/src/checkers/liveness.ml",children:"liveness.ml"}),".\nThis code is performing a compilers-101 style liveness analysis over\nSIL, Infer's intermediate\nlanguage. Since this code is fairly small and you should already understand what\nit's trying to do, it's a fairly good place to look in order to understand both\nhow to use the abstract interpretation framework and what SIL is."]}),"\n",(0,s.jsx)(n.p,{children:"There are basically three important bits here: defining the domain, defining the\ntransfer functions, and then passing the pieces to the framework to create an\nanalysis. Let's break down the third bit:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-OCaml",children:"module CFG = ProcCfg.OneInstrPerNode (ProcCfg.Backward (ProcCfg.Exceptional))\nmodule CheckerAnalyzer =\n  AbstractInterpreter.MakeRPO (TransferFunctions (CheckerMode) (CFG))\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"ProcCfg.Backward (ProcCfg.Exceptional)"}),' part says: "I want the direction of\niteration to be backward" (since liveness is a backward analysis), and "I want\nthe analysis to follow exceptional edges". For a forward analysis that ignores\nexceptional edges, you would do ',(0,s.jsx)(n.code,{children:"ProcCfg.Normal"})," instead (and many other\ncombinations are possible; take a look at\n",(0,s.jsx)(n.a,{href:"https://github.com/facebook/infer/blob/main/infer/src/absint/ProcCfg.mli",children:"ProcCfg.mli"}),"\nfor more). And finally, the ",(0,s.jsx)(n.code,{children:"TransferFunctions"}),' part says "Use the transfer\nfunctions I defined above".']}),"\n",(0,s.jsxs)(n.p,{children:["Now you have a ",(0,s.jsx)(n.code,{children:"CheckerAnalyzer"})," module that exposes useful functions\nlike\n",(0,s.jsx)(n.a,{href:"https://github.com/facebook/infer/blob/main/infer/src/absint/AbstractInterpreter.mli#L30",children:(0,s.jsx)(n.code,{children:"compute_post"})}),"\n(take a procedure as input and compute a postcondition) and\n",(0,s.jsx)(n.a,{href:"https://github.com/facebook/infer/blob/main/infer/src/absint/AbstractInterpreter.mli#L36",children:(0,s.jsx)(n.code,{children:"exec_pdesc"})}),"\n(take a procedure and compute an invariant map from node id's to the\npre/post at each node). The next step is to hook your checker up to\nthe Infer command-line interface (CLI). For the liveness analysis, you\nwould do this by exposing a function for running the checker on a\nsingle procedure:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-OCaml",children:'let checker ({IntraproceduralAnalysis.proc_desc; err_log} as analysis_data) =\n  match Analyzer.compute_post analysis_data ~initial:Domain.empty with\n  | Some post ->\n      Logging.progress "Computed post %a for %a"\n        Domain.pp post Procname.pp (Procdesc.get_proc_name proc_desc);\n  | None -> ()\n'})}),"\n",(0,s.jsxs)(n.p,{children:["and then adding ",(0,s.jsx)(n.code,{children:"Liveness.checker"})," to the list of registered checkers\nin\n",(0,s.jsx)(n.a,{href:"https://github.com/facebook/infer/blob/main/infer/src/backend/registerCheckers.ml",children:"registerCheckers.ml"}),'\n(search for "Liveness").']}),"\n",(0,s.jsxs)(n.p,{children:["you can then run ",(0,s.jsx)(n.code,{children:"infer run --liveness-only -- <your_build_command>"})," to run your\nchecker on real code. See ",(0,s.jsx)(n.a,{href:"/docs/1.1.0/analyzing-apps-or-projects",children:"here"})," for more\ndetails on the build systems supported by Infer."]}),"\n",(0,s.jsxs)(n.p,{children:["Other examples of simple intraprocedural checkers are\n",(0,s.jsx)(n.a,{href:"https://github.com/facebook/infer/blob/main/infer/src/checkers/addressTaken.ml",children:"addressTaken.ml"}),"\nand\n",(0,s.jsx)(n.a,{href:"https://github.com/facebook/infer/blob/main/infer/src/checkers/Siof.ml",children:"Siof.ml"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"error-reporting",children:"Error reporting"}),"\n",(0,s.jsxs)(n.p,{children:["Useful analyses have output. Basic printing to stderr or stderr is\ngood for debugging, but to report a programmer-readable error that is\ntied to a source code location, you'll want to use\n",(0,s.jsx)(n.a,{href:"pathname:///odoc/1.1.0/infer/Absint/Reporting/index.html#val-log_issue",children:(0,s.jsx)(n.code,{children:"Reporting.log_issue"})}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"by-example-interprocedural-analysis",children:"By example: interprocedural analysis"}),"\n",(0,s.jsxs)(n.p,{children:['Let\'s assume you have already read and understood the "intraprocedural analysis"\nsection and have an intraprocedural checker. The abstract interpretation\nframework makes it easy to convert your intraprocedural analysis into a\n',(0,s.jsx)(n.em,{children:"modular"})," interprocedural analysis. Let me emphasize the ",(0,s.jsx)(n.em,{children:"modular"})," point once\nmore; global analyses cannot be expressed in this framework."]}),"\n",(0,s.jsx)(n.p,{children:"To make your checker interprocedural, you need to:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Define the type of procedure summaries for your analysis and let\nregisterCheckers.ml know that your checker is interprocedural"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Add logic for (a) using summaries in your transfer functions and (b)\nconverting your intraprocedural abstract state to a summary."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["A good example to look at here is\n",(0,s.jsx)(n.a,{href:"https://github.com/facebook/infer/blob/main/infer/src/checkers/Siof.ml",children:"Siof.ml"}),".\nStep (1) is just:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-OCaml",children:"(* in src/checkers/SiofDomain.ml *)\n(* note that as a result the type of summaries is the same as the type of domain\n   elements *)\nmodule Summary = ...\ninclude Summary\n\n\n(* in src/backend/Payloads.ml: register the payload of the analyzer *)\ntype t =\n  { ...\n  ; siof: SiofDomain.Summary.t option\n  ... }\n\n\n(* in src/backend/registerCheckers.ml *)\nlet all_checkers = [ ...\n  ; {checker= SIOF; callbacks= [(interprocedural Payloads.Fields.siof Siof.checker, Clang)]}\n  ... ]\n"})}),"\n",(0,s.jsx)(n.p,{children:"Here, the type of the abstract state and the type of the summary are the same,\nwhich makes things easier for us (no logic to convert an abstract state to a\nsummary)."}),"\n",(0,s.jsxs)(n.p,{children:["Part (2a) is\n",(0,s.jsx)(n.a,{href:"https://github.com/facebook/infer/blob/be4ddc48f6330b7b788d899ce12ca51b4d673530/infer/src/checkers/Siof.ml#L168",children:"here"}),"\nand uses the ",(0,s.jsx)(n.code,{children:"analyze_dependency"})," callback provided by the framework:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"match analyze_dependency callee_pname with\n"})}),"\n",(0,s.jsxs)(n.p,{children:['This says: "read the summary for ',(0,s.jsx)(n.code,{children:"callee_pname"}),', possibly computing it\nfirst". You must then add logic for applying the summary to the\ncurrent abstract state (often, this is as simple as doing a join).']}),"\n",(0,s.jsxs)(n.p,{children:["Because our summary type is the same as the abstract state, part (2b)\nhere simply consists in return the post computed by the analysis as\nthe procedure's summary, using ",(0,s.jsx)(n.code,{children:"Analyzer.compute_post"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"That's it! We now have an interprocedural analysis."}),"\n",(0,s.jsxs)(n.p,{children:["To go deeper, jump to the ",(0,s.jsx)(n.a,{href:"https://github.com/facebook/infer/blob/main/infer/src/labs/README.md",children:"lab\nexercise"}),"\nand to the ",(0,s.jsx)(n.a,{href:"internal-API/",children:"API documentation"}),", e.g. for the\n",(0,s.jsx)(n.a,{href:"pathname:///odoc/1.1.0/infer/Absint.html",children:"Absint"})," and\n",(0,s.jsx)(n.a,{href:"pathname:///odoc/1.1.0/infer/IR.html",children:"IR"})," modules."]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>o,x:()=>i});var a=r(6540);const s={},t=a.createContext(s);function o(e){const n=a.useContext(t);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),a.createElement(t.Provider,{value:n},e.children)}}}]);