codetoanalyze/java/nullsafe/AlternativeRecommendations.java, Linters_dummy_method, 17, ERADICATE_META_CLASS_NEEDS_IMPROVEMENT, no_bucket, INFO, [], AlternativeRecommendations, codetoanalyze.java.nullsafe, issues: 5, curr_mode: "Default"
codetoanalyze/java/nullsafe/AlternativeRecommendations.java, codetoanalyze.java.nullsafe.AlternativeRecommendations.assigningField_ShouldSuggestAlternative(android.view.View):void, 1, ERADICATE_FIELD_NOT_NULLABLE, no_bucket, WARNING, [`field` is declared non-nullable but is assigned a nullable: call to View.findViewById(...) at line 34 (nullable according to nullsafe internal models). If you don't expect null, use `androidx.core.view.ViewCompat.requireViewById()` instead.], AlternativeRecommendations, codetoanalyze.java.nullsafe, nullable_methods:android.view.View.findViewById at 34, field:codetoanalyze.java.nullsafe.AlternativeRecommendations.field
codetoanalyze/java/nullsafe/AlternativeRecommendations.java, codetoanalyze.java.nullsafe.AlternativeRecommendations.dereference_ShouldSuggestAlternative(android.view.View):void, 1, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`view.findViewById(...)` is nullable and is not locally checked for null when calling `setId(...)`: call to View.findViewById(...) at line 22 (nullable according to nullsafe internal models). If this is intentional, use `androidx.core.view.ViewCompat.requireViewById()` instead.], AlternativeRecommendations, codetoanalyze.java.nullsafe, nullable_methods:android.view.View.findViewById at 22
codetoanalyze/java/nullsafe/AlternativeRecommendations.java, codetoanalyze.java.nullsafe.AlternativeRecommendations.passingParam_ShouldSuggestAlternative(android.view.View):void, 1, ERADICATE_PARAMETER_NOT_NULLABLE, no_bucket, WARNING, [`AlternativeRecommendations.acceptsNonnullView(...)`: parameter #1(`view`) is declared non-nullable but the argument `view.findViewById(...)` is nullable: call to View.findViewById(...) at line 26 (nullable according to nullsafe internal models). If you don't expect null, use `androidx.core.view.ViewCompat.requireViewById()` instead.], AlternativeRecommendations, codetoanalyze.java.nullsafe, nullable_methods:android.view.View.findViewById at 26
codetoanalyze/java/nullsafe/AlternativeRecommendations.java, codetoanalyze.java.nullsafe.AlternativeRecommendations.returnValue_ShouldSuggestAlternative(android.view.View):android.view.View, 0, ERADICATE_RETURN_NOT_NULLABLE, no_bucket, WARNING, [`returnValue_ShouldSuggestAlternative(...)`: return type is declared non-nullable but the method returns a nullable value: call to View.findViewById(...) at line 30 (nullable according to nullsafe internal models). If you don't expect null, use `androidx.core.view.ViewCompat.requireViewById()` instead.], AlternativeRecommendations, codetoanalyze.java.nullsafe, nullable_methods:android.view.View.findViewById at 30
codetoanalyze/java/nullsafe/ButterKnife.java, Linters_dummy_method, 15, ERADICATE_META_CLASS_NEEDS_IMPROVEMENT, no_bucket, INFO, [], ButterKnife, codetoanalyze.java.nullsafe, issues: 5, curr_mode: "Default"
codetoanalyze/java/nullsafe/ButterKnife.java, codetoanalyze.java.nullsafe.ButterKnife$TestNotInitialized.<init>(codetoanalyze.java.nullsafe.ButterKnife), 0, ERADICATE_FIELD_NOT_INITIALIZED, no_bucket, WARNING, [Field `notInitializedNormalIsBAD` is declared non-nullable, so it should be initialized in the constructor], ButterKnife$TestNotInitialized, codetoanalyze.java.nullsafe, field:codetoanalyze.java.nullsafe.ButterKnife$TestNotInitialized.notInitializedNormalIsBAD
codetoanalyze/java/nullsafe/ButterKnife.java, codetoanalyze.java.nullsafe.ButterKnife.<init>(), 0, ERADICATE_FIELD_OVER_ANNOTATED, no_bucket, ADVICE, [Field `ButterKnife.nullable` is always initialized in the constructor but is declared `@Nullable`], ButterKnife, codetoanalyze.java.nullsafe, field:codetoanalyze.java.nullsafe.ButterKnife.nullable
codetoanalyze/java/nullsafe/ButterKnife.java, codetoanalyze.java.nullsafe.ButterKnife.assignNullToNormalIsBAD():void, 1, ERADICATE_FIELD_NOT_NULLABLE, no_bucket, WARNING, [`normal` is declared non-nullable but is assigned `null`: null constant at line 76.], ButterKnife, codetoanalyze.java.nullsafe, field:codetoanalyze.java.nullsafe.ButterKnife.normal
codetoanalyze/java/nullsafe/ButterKnife.java, codetoanalyze.java.nullsafe.ButterKnife.convertingToNotNullableForNullableIsBAD():java.lang.String, 0, ERADICATE_RETURN_NOT_NULLABLE, no_bucket, WARNING, [`convertingToNotNullableForNullableIsBAD()`: return type is declared non-nullable but the method returns a nullable value: field nullable at line 47.], ButterKnife, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/ButterKnife.java, codetoanalyze.java.nullsafe.ButterKnife.dereferencingNullableIsBAD():void, 1, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`ButterKnife.nullable` is nullable and is not locally checked for null when calling `length()`.], ButterKnife, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/ButterKnife.java, codetoanalyze.java.nullsafe.ButterKnife.passingToNullableForNullableIsBAD():void, 1, ERADICATE_PARAMETER_NOT_NULLABLE, no_bucket, WARNING, [`ButterKnife.f(...)`: parameter #1(`nonNullable`) is declared non-nullable but the argument `ButterKnife.nullable` is nullable.], ButterKnife, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/CapturedParam.java, Linters_dummy_method, 13, ERADICATE_META_CLASS_NEEDS_IMPROVEMENT, no_bucket, INFO, [], CapturedParam, codetoanalyze.java.nullsafe, issues: 1, curr_mode: "Default"
codetoanalyze/java/nullsafe/CapturedParam.java, codetoanalyze.java.nullsafe.CapturedParam.dereferencingNullableIsBAD(java.lang.Object):void, 1, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`parameter` is nullable and is not locally checked for null when calling `toString()`.], CapturedParam, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/ConditionRedundant.java, Linters_dummy_method, 13, ERADICATE_META_CLASS_CAN_BE_NULLSAFE, no_bucket, ADVICE, [Congrats! `ConditionRedundant` is free of nullability issues. Mark it `@Nullsafe(Nullsafe.Mode.LOCAL)` to prevent regressions.], ConditionRedundant, codetoanalyze.java.nullsafe, issues: 0, curr_mode: "Default", promote_mode: "Strict"
codetoanalyze/java/nullsafe/ConditionRedundant.java, codetoanalyze.java.nullsafe.ConditionRedundant.<init>(), 0, ERADICATE_FIELD_OVER_ANNOTATED, no_bucket, ADVICE, [Field `ConditionRedundant.fieldNullable` is always initialized in the constructor but is declared `@Nullable`], ConditionRedundant, codetoanalyze.java.nullsafe, field:codetoanalyze.java.nullsafe.ConditionRedundant.fieldNullable
codetoanalyze/java/nullsafe/ConditionRedundant.java, codetoanalyze.java.nullsafe.ConditionRedundant.FP_ternary_NonnullInOneBranch_SecondBranch_ShouldBeOK(java.lang.String,java.lang.String,int):void, 2, ERADICATE_CONDITION_REDUNDANT, no_bucket, ADVICE, [The condition s2 might be always false according to the existing annotations.], ConditionRedundant, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/ConditionRedundant.java, codetoanalyze.java.nullsafe.ConditionRedundant.assertNotNull_NonnullIsBAD(java.lang.String):void, 1, ERADICATE_CONDITION_REDUNDANT, no_bucket, ADVICE, [The condition (s!=null) might be always true according to the existing annotations.], ConditionRedundant, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/ConditionRedundant.java, codetoanalyze.java.nullsafe.ConditionRedundant.checkArgument_NonnullIsBAd(java.lang.String):void, 1, ERADICATE_CONDITION_REDUNDANT, no_bucket, ADVICE, [The condition s might be always true according to the existing annotations.], ConditionRedundant, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/ConditionRedundant.java, codetoanalyze.java.nullsafe.ConditionRedundant.checkNotNull_NonnullIsBAD(java.lang.String):void, 1, ERADICATE_CONDITION_REDUNDANT, no_bucket, ADVICE, [The condition (s!=null) might be always true according to the existing annotations.], ConditionRedundant, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/ConditionRedundant.java, codetoanalyze.java.nullsafe.ConditionRedundant.compareEQ_NonnullIsBAD(java.lang.String):void, 1, ERADICATE_CONDITION_REDUNDANT, no_bucket, ADVICE, [The condition s might be always false according to the existing annotations.], ConditionRedundant, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/ConditionRedundant.java, codetoanalyze.java.nullsafe.ConditionRedundant.compareNEQ_NonnullIsBAD(java.lang.String):void, 1, ERADICATE_CONDITION_REDUNDANT, no_bucket, ADVICE, [The condition s might be always true according to the existing annotations.], ConditionRedundant, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/ConditionRedundant.java, codetoanalyze.java.nullsafe.ConditionRedundant.comparingNonnullFieldIsBAD():void, 1, ERADICATE_CONDITION_REDUNDANT, no_bucket, ADVICE, [The condition ConditionRedundant.fieldNonnull might be always true according to the existing annotations.], ConditionRedundant, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/ConditionRedundant.java, codetoanalyze.java.nullsafe.ConditionRedundant.comparingNonnullFunctionIsBAD():void, 1, ERADICATE_CONDITION_REDUNDANT, no_bucket, ADVICE, [The condition lang.String(this)V might be always true: `ConditionRedundant.getNonnull()` is not annotated as `@Nullable`.], ConditionRedundant, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/ConditionRedundant.java, codetoanalyze.java.nullsafe.ConditionRedundant.comparingNullableFieldThatIsAlreadyCheckedIsBAD():void, 2, ERADICATE_CONDITION_REDUNDANT, no_bucket, ADVICE, [The condition ConditionRedundant.fieldNullable might be always true according to the existing annotations.], ConditionRedundant, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/ConditionRedundant.java, codetoanalyze.java.nullsafe.ConditionRedundant.comparingWithNullIfAssignedBeforeThrowableIsBAD():void, 6, ERADICATE_CONDITION_REDUNDANT, no_bucket, ADVICE, [The condition s might be always true according to the existing annotations.], ConditionRedundant, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/ConditionRedundant.java, codetoanalyze.java.nullsafe.ConditionRedundant.conjunctionBothNonnullIsBAD(java.lang.String,java.lang.String):void, 1, ERADICATE_CONDITION_REDUNDANT, no_bucket, ADVICE, [The condition s2 might be always true according to the existing annotations.], ConditionRedundant, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/ConditionRedundant.java, codetoanalyze.java.nullsafe.ConditionRedundant.conjunctionBothNonnullIsBAD(java.lang.String,java.lang.String):void, 1, ERADICATE_CONDITION_REDUNDANT, no_bucket, ADVICE, [The condition s1 might be always true according to the existing annotations.], ConditionRedundant, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/ConditionRedundant.java, codetoanalyze.java.nullsafe.ConditionRedundant.conjunctionOneNonnullIsBAD(java.lang.String,java.lang.String):void, 1, ERADICATE_CONDITION_REDUNDANT, no_bucket, ADVICE, [The condition s2 might be always true according to the existing annotations.], ConditionRedundant, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/ConditionRedundant.java, codetoanalyze.java.nullsafe.ConditionRedundant.disjunctionBothNonnullIsBAD(java.lang.String,java.lang.String):void, 1, ERADICATE_CONDITION_REDUNDANT, no_bucket, ADVICE, [The condition s1 might be always false according to the existing annotations.], ConditionRedundant, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/ConditionRedundant.java, codetoanalyze.java.nullsafe.ConditionRedundant.disjunctionBothNonnullIsBAD(java.lang.String,java.lang.String):void, 1, ERADICATE_CONDITION_REDUNDANT, no_bucket, ADVICE, [The condition s2 might be always true according to the existing annotations.], ConditionRedundant, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/ConditionRedundant.java, codetoanalyze.java.nullsafe.ConditionRedundant.disjunctionOneNonnullIsBAD(java.lang.String,java.lang.String):void, 1, ERADICATE_CONDITION_REDUNDANT, no_bucket, ADVICE, [The condition s2 might be always true according to the existing annotations.], ConditionRedundant, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/ConditionRedundant.java, codetoanalyze.java.nullsafe.ConditionRedundant.irrelevantConditionWithNonnullIsBAD(java.lang.String,java.lang.String,int):void, 1, ERADICATE_CONDITION_REDUNDANT, no_bucket, ADVICE, [The condition s1 might be always true according to the existing annotations.], ConditionRedundant, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/ConditionRedundant.java, codetoanalyze.java.nullsafe.ConditionRedundant.outsideOfIfCompareNonnullIsBAD(java.lang.String):void, 1, ERADICATE_CONDITION_REDUNDANT, no_bucket, ADVICE, [The condition s might be always true according to the existing annotations.], ConditionRedundant, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/ConditionRedundant.java, codetoanalyze.java.nullsafe.ConditionRedundant.ternary_NonnullInBothBranchesIsBAD(java.lang.String,java.lang.String,int):void, 2, ERADICATE_CONDITION_REDUNDANT, no_bucket, ADVICE, [The condition s2 might be always false according to the existing annotations.], ConditionRedundant, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/ConditionRedundant.java, codetoanalyze.java.nullsafe.ConditionRedundant.testFlowSensitivity(java.lang.String,java.lang.String):void, 2, ERADICATE_CONDITION_REDUNDANT, no_bucket, ADVICE, [The condition nullable1 might be always true according to the existing annotations.], ConditionRedundant, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/ConditionRedundant.java, codetoanalyze.java.nullsafe.ConditionRedundant.testFlowSensitivity(java.lang.String,java.lang.String):void, 4, ERADICATE_CONDITION_REDUNDANT, no_bucket, ADVICE, [The condition nullable1 might be always true according to the existing annotations.], ConditionRedundant, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/FieldNotInitialized.java, Linters_dummy_method, 25, ERADICATE_META_CLASS_NEEDS_IMPROVEMENT, no_bucket, INFO, [], FieldNotInitialized, codetoanalyze.java.nullsafe, issues: 32, curr_mode: "Default"
codetoanalyze/java/nullsafe/FieldNotInitialized.java, Linters_dummy_method, 236, ERADICATE_META_CLASS_NEEDS_IMPROVEMENT, no_bucket, INFO, [], TestKnownInitializers, codetoanalyze.java.nullsafe, issues: 2, curr_mode: "Default"
codetoanalyze/java/nullsafe/FieldNotInitialized.java, Linters_dummy_method, 283, ERADICATE_META_CLASS_NEEDS_IMPROVEMENT, no_bucket, INFO, [], TestInitializerAnnotation, codetoanalyze.java.nullsafe, issues: 5, curr_mode: "Default"
codetoanalyze/java/nullsafe/FieldNotInitialized.java, codetoanalyze.java.nullsafe.FieldNotInitialized$InitCircular.<init>(codetoanalyze.java.nullsafe.FieldNotInitialized), 0, ERADICATE_FIELD_NOT_INITIALIZED, no_bucket, WARNING, [Field `stillBad` is declared non-nullable, so it should be initialized in the constructor], FieldNotInitialized$InitCircular, codetoanalyze.java.nullsafe, field:codetoanalyze.java.nullsafe.FieldNotInitialized$InitCircular.stillBad
codetoanalyze/java/nullsafe/FieldNotInitialized.java, codetoanalyze.java.nullsafe.FieldNotInitialized$InitCircular.<init>(codetoanalyze.java.nullsafe.FieldNotInitialized), 0, ERADICATE_FIELD_NOT_INITIALIZED, no_bucket, WARNING, [Field `bad` is declared non-nullable, so it should be initialized in the constructor], FieldNotInitialized$InitCircular, codetoanalyze.java.nullsafe, field:codetoanalyze.java.nullsafe.FieldNotInitialized$InitCircular.bad
codetoanalyze/java/nullsafe/FieldNotInitialized.java, codetoanalyze.java.nullsafe.FieldNotInitialized$InitIfNull.<init>(codetoanalyze.java.nullsafe.FieldNotInitialized), 0, ERADICATE_FIELD_NOT_INITIALIZED, no_bucket, WARNING, [Field `shouldBeGood_FIXME` is declared non-nullable, so it should be initialized in the constructor], FieldNotInitialized$InitIfNull, codetoanalyze.java.nullsafe, field:codetoanalyze.java.nullsafe.FieldNotInitialized$InitIfNull.shouldBeGood_FIXME
codetoanalyze/java/nullsafe/FieldNotInitialized.java, codetoanalyze.java.nullsafe.FieldNotInitialized$InitWithOtherClass$OtherClass.<init>(codetoanalyze.java.nullsafe.FieldNotInitialized$InitWithOtherClass), 0, ERADICATE_FIELD_OVER_ANNOTATED, no_bucket, ADVICE, [Field `FieldNotInitialized$InitWithOtherClass$OtherClass.nullable` is always initialized in the constructor but is declared `@Nullable`], FieldNotInitialized$InitWithOtherClass$OtherClass, codetoanalyze.java.nullsafe, field:codetoanalyze.java.nullsafe.FieldNotInitialized$InitWithOtherClass$OtherClass.nullable
codetoanalyze/java/nullsafe/FieldNotInitialized.java, codetoanalyze.java.nullsafe.FieldNotInitialized$InitWithOtherClass.<init>(codetoanalyze.java.nullsafe.FieldNotInitialized,codetoanalyze.java.nullsafe.FieldNotInitialized$InitWithOtherClass$OtherClass), 1, ERADICATE_FIELD_NOT_NULLABLE, no_bucket, WARNING, [`bad` is declared non-nullable but is assigned a nullable: field nullable at line 185.], FieldNotInitialized$InitWithOtherClass, codetoanalyze.java.nullsafe, field:codetoanalyze.java.nullsafe.FieldNotInitialized$InitWithOtherClass.bad
codetoanalyze/java/nullsafe/FieldNotInitialized.java, codetoanalyze.java.nullsafe.FieldNotInitialized$InitWithTheSameClass.<init>(codetoanalyze.java.nullsafe.FieldNotInitialized,codetoanalyze.java.nullsafe.FieldNotInitialized$InitWithTheSameClass), 0, ERADICATE_FIELD_NOT_INITIALIZED, no_bucket, WARNING, [Field `bad` is declared non-nullable, so it should be initialized in the constructor], FieldNotInitialized$InitWithTheSameClass, codetoanalyze.java.nullsafe, field:codetoanalyze.java.nullsafe.FieldNotInitialized$InitWithTheSameClass.bad
codetoanalyze/java/nullsafe/FieldNotInitialized.java, codetoanalyze.java.nullsafe.FieldNotInitialized$InitializationOrder.<init>(codetoanalyze.java.nullsafe.FieldNotInitialized,int), 0, ERADICATE_FIELD_NOT_INITIALIZED, no_bucket, WARNING, [Field `o1` is declared non-nullable, so it should be initialized in the constructor], FieldNotInitialized$InitializationOrder, codetoanalyze.java.nullsafe, field:codetoanalyze.java.nullsafe.FieldNotInitialized$InitializationOrder.o1
codetoanalyze/java/nullsafe/FieldNotInitialized.java, codetoanalyze.java.nullsafe.FieldNotInitialized$OnlyRead.<init>(codetoanalyze.java.nullsafe.FieldNotInitialized), 0, ERADICATE_FIELD_NOT_INITIALIZED, no_bucket, WARNING, [Field `o` is declared non-nullable, so it should be initialized in the constructor], FieldNotInitialized$OnlyRead, codetoanalyze.java.nullsafe, field:codetoanalyze.java.nullsafe.FieldNotInitialized$OnlyRead.o
codetoanalyze/java/nullsafe/FieldNotInitialized.java, codetoanalyze.java.nullsafe.FieldNotInitialized$OnlyReadIndirect.<init>(codetoanalyze.java.nullsafe.FieldNotInitialized), 0, ERADICATE_FIELD_NOT_INITIALIZED, no_bucket, WARNING, [Field `o1` is declared non-nullable, so it should be initialized in the constructor], FieldNotInitialized$OnlyReadIndirect, codetoanalyze.java.nullsafe, field:codetoanalyze.java.nullsafe.FieldNotInitialized$OnlyReadIndirect.o1
codetoanalyze/java/nullsafe/FieldNotInitialized.java, codetoanalyze.java.nullsafe.FieldNotInitialized$ShouldInitializeInAllBranches.<init>(codetoanalyze.java.nullsafe.FieldNotInitialized,int), 0, ERADICATE_FIELD_NOT_INITIALIZED, no_bucket, WARNING, [Field `f3` is declared non-nullable, so it should be initialized in the constructor], FieldNotInitialized$ShouldInitializeInAllBranches, codetoanalyze.java.nullsafe, field:codetoanalyze.java.nullsafe.FieldNotInitialized$ShouldInitializeInAllBranches.f3
codetoanalyze/java/nullsafe/FieldNotInitialized.java, codetoanalyze.java.nullsafe.FieldNotInitialized$ShouldInitializeInAllBranches.<init>(codetoanalyze.java.nullsafe.FieldNotInitialized,int), 0, ERADICATE_FIELD_NOT_INITIALIZED, no_bucket, WARNING, [Field `f5` is declared non-nullable, so it should be initialized in the constructor], FieldNotInitialized$ShouldInitializeInAllBranches, codetoanalyze.java.nullsafe, field:codetoanalyze.java.nullsafe.FieldNotInitialized$ShouldInitializeInAllBranches.f5
codetoanalyze/java/nullsafe/FieldNotInitialized.java, codetoanalyze.java.nullsafe.FieldNotInitialized$ShouldInitializeInAllBranches.<init>(codetoanalyze.java.nullsafe.FieldNotInitialized,int), 0, ERADICATE_FIELD_NOT_INITIALIZED, no_bucket, WARNING, [Field `f2` is declared non-nullable, so it should be initialized in the constructor], FieldNotInitialized$ShouldInitializeInAllBranches, codetoanalyze.java.nullsafe, field:codetoanalyze.java.nullsafe.FieldNotInitialized$ShouldInitializeInAllBranches.f2
codetoanalyze/java/nullsafe/FieldNotInitialized.java, codetoanalyze.java.nullsafe.FieldNotInitialized$Suppression.<init>(codetoanalyze.java.nullsafe.FieldNotInitialized), 0, ERADICATE_FIELD_NOT_INITIALIZED, no_bucket, WARNING, [Field `suppressWrongLintIsBAD` is declared non-nullable, so it should be initialized in the constructor], FieldNotInitialized$Suppression, codetoanalyze.java.nullsafe, field:codetoanalyze.java.nullsafe.FieldNotInitialized$Suppression.suppressWrongLintIsBAD
codetoanalyze/java/nullsafe/FieldNotInitialized.java, codetoanalyze.java.nullsafe.FieldNotInitialized$Suppression.<init>(codetoanalyze.java.nullsafe.FieldNotInitialized), 0, ERADICATE_FIELD_NOT_INITIALIZED, no_bucket, WARNING, [Field `nonnullIsBAD` is declared non-nullable, so it should be initialized in the constructor], FieldNotInitialized$Suppression, codetoanalyze.java.nullsafe, field:codetoanalyze.java.nullsafe.FieldNotInitialized$Suppression.nonnullIsBAD
codetoanalyze/java/nullsafe/FieldNotInitialized.java, codetoanalyze.java.nullsafe.FieldNotInitialized$Suppression.<init>(codetoanalyze.java.nullsafe.FieldNotInitialized), 0, ERADICATE_FIELD_NOT_INITIALIZED, no_bucket, WARNING, [Field `notNullIsBAD` is declared non-nullable, so it should be initialized in the constructor], FieldNotInitialized$Suppression, codetoanalyze.java.nullsafe, field:codetoanalyze.java.nullsafe.FieldNotInitialized$Suppression.notNullIsBAD
codetoanalyze/java/nullsafe/FieldNotInitialized.java, codetoanalyze.java.nullsafe.FieldNotInitialized$Suppression.<init>(codetoanalyze.java.nullsafe.FieldNotInitialized), 0, ERADICATE_FIELD_NOT_INITIALIZED, no_bucket, WARNING, [Field `nonNullIsBAD` is declared non-nullable, so it should be initialized in the constructor], FieldNotInitialized$Suppression, codetoanalyze.java.nullsafe, field:codetoanalyze.java.nullsafe.FieldNotInitialized$Suppression.nonNullIsBAD
codetoanalyze/java/nullsafe/FieldNotInitialized.java, codetoanalyze.java.nullsafe.FieldNotInitialized$Suppression.testNullifyFields():void, 3, ERADICATE_FIELD_NOT_NULLABLE, no_bucket, WARNING, [`nonnullIsBAD` is declared non-nullable but is assigned `null`: null constant at line 62.], FieldNotInitialized$Suppression, codetoanalyze.java.nullsafe, field:codetoanalyze.java.nullsafe.FieldNotInitialized$Suppression.nonnullIsBAD
codetoanalyze/java/nullsafe/FieldNotInitialized.java, codetoanalyze.java.nullsafe.FieldNotInitialized$Suppression.testNullifyFields():void, 4, ERADICATE_FIELD_NOT_NULLABLE, no_bucket, WARNING, [`nonNullIsBAD` is declared non-nullable but is assigned `null`: null constant at line 63.], FieldNotInitialized$Suppression, codetoanalyze.java.nullsafe, field:codetoanalyze.java.nullsafe.FieldNotInitialized$Suppression.nonNullIsBAD
codetoanalyze/java/nullsafe/FieldNotInitialized.java, codetoanalyze.java.nullsafe.FieldNotInitialized$Suppression.testNullifyFields():void, 5, ERADICATE_FIELD_NOT_NULLABLE, no_bucket, WARNING, [`injectIsOK` is declared non-nullable but is assigned `null`: null constant at line 64.], FieldNotInitialized$Suppression, codetoanalyze.java.nullsafe, field:codetoanalyze.java.nullsafe.FieldNotInitialized$Suppression.injectIsOK
codetoanalyze/java/nullsafe/FieldNotInitialized.java, codetoanalyze.java.nullsafe.FieldNotInitialized$Suppression.testNullifyFields():void, 6, ERADICATE_FIELD_NOT_NULLABLE, no_bucket, WARNING, [`suppressAnnotationIsOK` is declared non-nullable but is assigned `null`: null constant at line 65.], FieldNotInitialized$Suppression, codetoanalyze.java.nullsafe, field:codetoanalyze.java.nullsafe.FieldNotInitialized$Suppression.suppressAnnotationIsOK
codetoanalyze/java/nullsafe/FieldNotInitialized.java, codetoanalyze.java.nullsafe.FieldNotInitialized$Suppression.testNullifyFields():void, 7, ERADICATE_FIELD_NOT_NULLABLE, no_bucket, WARNING, [`suppressLintIsOK` is declared non-nullable but is assigned `null`: null constant at line 66.], FieldNotInitialized$Suppression, codetoanalyze.java.nullsafe, field:codetoanalyze.java.nullsafe.FieldNotInitialized$Suppression.suppressLintIsOK
codetoanalyze/java/nullsafe/FieldNotInitialized.java, codetoanalyze.java.nullsafe.FieldNotInitialized$Suppressions.<init>(codetoanalyze.java.nullsafe.FieldNotInitialized,int), 0, ERADICATE_FIELD_NOT_INITIALIZED, no_bucket, WARNING, [Field `f2` is declared non-nullable, so it should be initialized in the constructor], FieldNotInitialized$Suppressions, codetoanalyze.java.nullsafe, field:codetoanalyze.java.nullsafe.FieldNotInitialized$Suppressions.f2
codetoanalyze/java/nullsafe/FieldNotInitialized.java, codetoanalyze.java.nullsafe.FieldNotInitialized$Suppressions.<init>(codetoanalyze.java.nullsafe.FieldNotInitialized,int), 2, ERADICATE_PARAMETER_NOT_NULLABLE, no_bucket, WARNING, [`FieldNotInitialized$Suppressions.f(...)`: parameter #1(`a`) is declared non-nullable but the argument is `null`.], FieldNotInitialized$Suppressions, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/FieldNotInitialized.java, codetoanalyze.java.nullsafe.FieldNotInitialized$Suppressions.<init>(codetoanalyze.java.nullsafe.FieldNotInitialized,int,int), 1, ERADICATE_PARAMETER_NOT_NULLABLE, no_bucket, WARNING, [`FieldNotInitialized$Suppressions.f(...)`: parameter #1(`a`) is declared non-nullable but the argument is `null`.], FieldNotInitialized$Suppressions, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/FieldNotInitialized.java, codetoanalyze.java.nullsafe.FieldNotInitialized$Suppressions.<init>(codetoanalyze.java.nullsafe.FieldNotInitialized,int,int,int), 1, ERADICATE_PARAMETER_NOT_NULLABLE, no_bucket, WARNING, [`FieldNotInitialized$Suppressions.f(...)`: parameter #1(`a`) is declared non-nullable but the argument is `null`.], FieldNotInitialized$Suppressions, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/FieldNotInitialized.java, codetoanalyze.java.nullsafe.FieldNotInitialized$WriteItselfIsBAD.<init>(codetoanalyze.java.nullsafe.FieldNotInitialized), 0, ERADICATE_FIELD_NOT_INITIALIZED, no_bucket, WARNING, [Field `bad` is declared non-nullable, so it should be initialized in the constructor], FieldNotInitialized$WriteItselfIsBAD, codetoanalyze.java.nullsafe, field:codetoanalyze.java.nullsafe.FieldNotInitialized$WriteItselfIsBAD.bad
codetoanalyze/java/nullsafe/FieldNotInitialized.java, codetoanalyze.java.nullsafe.TestInitializerAnnotation$TestFieldNotInitializedDerived.<init>(codetoanalyze.java.nullsafe.TestInitializerAnnotation), 0, ERADICATE_FIELD_NOT_INITIALIZED, no_bucket, WARNING, [Field `field2_BAD` is declared non-nullable, so it should be initialized in the constructor], TestInitializerAnnotation$TestFieldNotInitializedDerived, codetoanalyze.java.nullsafe, field:codetoanalyze.java.nullsafe.TestInitializerAnnotation$TestFieldNotInitializedDerived.field2_BAD
codetoanalyze/java/nullsafe/FieldNotInitialized.java, codetoanalyze.java.nullsafe.TestInitializerAnnotation$TestFieldNotInitializedDerivedDerived.<init>(codetoanalyze.java.nullsafe.TestInitializerAnnotation), 0, ERADICATE_FIELD_NOT_INITIALIZED, no_bucket, WARNING, [Field `field2_BAD` is declared non-nullable, so it should be initialized in the constructor], TestInitializerAnnotation$TestFieldNotInitializedDerivedDerived, codetoanalyze.java.nullsafe, field:codetoanalyze.java.nullsafe.TestInitializerAnnotation$TestFieldNotInitializedDerivedDerived.field2_BAD
codetoanalyze/java/nullsafe/FieldNotInitialized.java, codetoanalyze.java.nullsafe.TestInitializerAnnotation.<init>(), 0, ERADICATE_FIELD_NOT_INITIALIZED, no_bucket, WARNING, [Field `dontInitAtAllIsBAD` is declared non-nullable, so it should be initialized in the constructor], TestInitializerAnnotation, codetoanalyze.java.nullsafe, field:codetoanalyze.java.nullsafe.TestInitializerAnnotation.dontInitAtAllIsBAD
codetoanalyze/java/nullsafe/FieldNotInitialized.java, codetoanalyze.java.nullsafe.TestInitializerAnnotation.<init>(), 0, ERADICATE_FIELD_NOT_INITIALIZED, no_bucket, WARNING, [Field `initInAnyOtherMethodIsBAD` is declared non-nullable, so it should be initialized in the constructor], TestInitializerAnnotation, codetoanalyze.java.nullsafe, field:codetoanalyze.java.nullsafe.TestInitializerAnnotation.initInAnyOtherMethodIsBAD
codetoanalyze/java/nullsafe/FieldNotInitialized.java, codetoanalyze.java.nullsafe.TestInitializerAnnotation.build():java.lang.Object, 5, ERADICATE_CONDITION_REDUNDANT, no_bucket, ADVICE, [The condition TestInitializerAnnotation.initInInitilizerMethod1IsOK might be always true according to the existing annotations.], TestInitializerAnnotation, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/FieldNotInitialized.java, codetoanalyze.java.nullsafe.TestInitializerAnnotation.build():java.lang.Object, 5, ERADICATE_CONDITION_REDUNDANT, no_bucket, ADVICE, [The condition TestInitializerAnnotation.initInInitilizerMethod2IsOK might be always true according to the existing annotations.], TestInitializerAnnotation, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/FieldNotInitialized.java, codetoanalyze.java.nullsafe.TestInitializerAnnotation.set4(java.lang.String):void, 2, ERADICATE_FIELD_NOT_NULLABLE, no_bucket, WARNING, [`initByNullableInInitializedMethodIsBAD` is declared non-nullable but is assigned a nullable: method parameter value.], TestInitializerAnnotation, codetoanalyze.java.nullsafe, field:codetoanalyze.java.nullsafe.TestInitializerAnnotation.initByNullableInInitializedMethodIsBAD
codetoanalyze/java/nullsafe/FieldNotInitialized.java, codetoanalyze.java.nullsafe.TestKnownInitializers$KnownInitializers.<init>(codetoanalyze.java.nullsafe.TestKnownInitializers), 0, ERADICATE_FIELD_NOT_INITIALIZED, no_bucket, WARNING, [Field `initInUnknownMethodIsBAD` is declared non-nullable, so it should be initialized in the constructor], TestKnownInitializers$KnownInitializers, codetoanalyze.java.nullsafe, field:codetoanalyze.java.nullsafe.TestKnownInitializers$KnownInitializers.initInUnknownMethodIsBAD
codetoanalyze/java/nullsafe/FieldNotInitialized.java, codetoanalyze.java.nullsafe.TestKnownInitializers$SimplyOnCreateWontDoATrick.<init>(codetoanalyze.java.nullsafe.TestKnownInitializers), 0, ERADICATE_FIELD_NOT_INITIALIZED, no_bucket, WARNING, [Field `initInUnknownMethodIsBAD` is declared non-nullable, so it should be initialized in the constructor], TestKnownInitializers$SimplyOnCreateWontDoATrick, codetoanalyze.java.nullsafe, field:codetoanalyze.java.nullsafe.TestKnownInitializers$SimplyOnCreateWontDoATrick.initInUnknownMethodIsBAD
codetoanalyze/java/nullsafe/FieldNotNullable.java, Linters_dummy_method, 20, ERADICATE_META_CLASS_NEEDS_IMPROVEMENT, no_bucket, INFO, [], CanAssignNullInCleanupMethods, codetoanalyze.java.nullsafe, issues: 1, curr_mode: "Default"
codetoanalyze/java/nullsafe/FieldNotNullable.java, Linters_dummy_method, 48, ERADICATE_META_CLASS_NEEDS_IMPROVEMENT, no_bucket, INFO, [], FieldNotNullable, codetoanalyze.java.nullsafe, issues: 5, curr_mode: "Default"
codetoanalyze/java/nullsafe/FieldNotNullable.java, Linters_dummy_method, 98, ERADICATE_META_CLASS_NEEDS_IMPROVEMENT, no_bucket, INFO, [], SomeExternalClass, codetoanalyze.java.nullsafe, issues: 1, curr_mode: "Default"
codetoanalyze/java/nullsafe/FieldNotNullable.java, codetoanalyze.java.nullsafe.CanAssignNullInCleanupMethods.assignNullInAnyOtherMethodIsBAD():void, 1, ERADICATE_FIELD_NOT_NULLABLE, no_bucket, WARNING, [`someObject` is declared non-nullable but is assigned `null`: null constant at line 44.], CanAssignNullInCleanupMethods, codetoanalyze.java.nullsafe, field:codetoanalyze.java.nullsafe.CanAssignNullInCleanupMethods.someObject
codetoanalyze/java/nullsafe/FieldNotNullable.java, codetoanalyze.java.nullsafe.FieldNotNullable.<init>(), 0, ERADICATE_FIELD_OVER_ANNOTATED, no_bucket, ADVICE, [Field `FieldNotNullable.nullable` is always initialized in the constructor but is declared `@Nullable`], FieldNotNullable, codetoanalyze.java.nullsafe, field:codetoanalyze.java.nullsafe.FieldNotNullable.nullable
codetoanalyze/java/nullsafe/FieldNotNullable.java, codetoanalyze.java.nullsafe.FieldNotNullable.<init>(), 4, ERADICATE_FIELD_NOT_NULLABLE, no_bucket, WARNING, [`initializeNonNullableWithNullIsBAD` is declared non-nullable but is assigned `null`: null constant at line 52.], FieldNotNullable, codetoanalyze.java.nullsafe, field:codetoanalyze.java.nullsafe.FieldNotNullable.initializeNonNullableWithNullIsBAD
codetoanalyze/java/nullsafe/FieldNotNullable.java, codetoanalyze.java.nullsafe.FieldNotNullable.getNullable():java.lang.String, 0, ERADICATE_RETURN_OVER_ANNOTATED, no_bucket, ADVICE, [Method `getNullable()` is annotated with `@Nullable` but never returns null.], FieldNotNullable, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/FieldNotNullable.java, codetoanalyze.java.nullsafe.FieldNotNullable.setNullableToExternalIsBAD(java.lang.String):void, 2, ERADICATE_FIELD_NOT_NULLABLE, no_bucket, WARNING, [`externalNotNull` is declared non-nullable but is assigned a nullable: method parameter s.], FieldNotNullable, codetoanalyze.java.nullsafe, field:codetoanalyze.java.nullsafe.SomeExternalClass.externalNotNull
codetoanalyze/java/nullsafe/FieldNotNullable.java, codetoanalyze.java.nullsafe.FieldNotNullable.setNullableToNotNullableIsBAD(java.lang.String):void, 1, ERADICATE_FIELD_NOT_NULLABLE, no_bucket, WARNING, [`notNullable` is declared non-nullable but is assigned `null`: null constant at line 65.], FieldNotNullable, codetoanalyze.java.nullsafe, field:codetoanalyze.java.nullsafe.FieldNotNullable.notNullable
codetoanalyze/java/nullsafe/FieldNotNullable.java, codetoanalyze.java.nullsafe.FieldNotNullable.setNullableToNotNullableIsBAD(java.lang.String):void, 2, ERADICATE_FIELD_NOT_NULLABLE, no_bucket, WARNING, [`notNullable` is declared non-nullable but is assigned a nullable: method parameter s.], FieldNotNullable, codetoanalyze.java.nullsafe, field:codetoanalyze.java.nullsafe.FieldNotNullable.notNullable
codetoanalyze/java/nullsafe/FieldNotNullable.java, codetoanalyze.java.nullsafe.FieldNotNullable.setNullableToNotNullableIsBAD(java.lang.String):void, 3, ERADICATE_FIELD_NOT_NULLABLE, no_bucket, WARNING, [`notNullable` is declared non-nullable but is assigned a nullable: call to getNullable() at line 67.], FieldNotNullable, codetoanalyze.java.nullsafe, nullable_methods:codetoanalyze.java.nullsafe.FieldNotNullable.getNullable at 67, field:codetoanalyze.java.nullsafe.FieldNotNullable.notNullable
codetoanalyze/java/nullsafe/FieldNotNullable.java, codetoanalyze.java.nullsafe.SomeExternalClass.<init>(), 0, ERADICATE_FIELD_NOT_INITIALIZED, no_bucket, WARNING, [Field `externalNotNull` is declared non-nullable, so it should be initialized in the constructor], SomeExternalClass, codetoanalyze.java.nullsafe, field:codetoanalyze.java.nullsafe.SomeExternalClass.externalNotNull
codetoanalyze/java/nullsafe/FieldNullabilityMemoization.java, Linters_dummy_method, 27, ERADICATE_META_CLASS_NEEDS_IMPROVEMENT, no_bucket, INFO, [], FieldNullabilityMemoization, codetoanalyze.java.nullsafe, issues: 2, curr_mode: "Default"
codetoanalyze/java/nullsafe/FieldNullabilityMemoization.java, codetoanalyze.java.nullsafe.FieldNullabilityMemoization.dereferenceIsBAD():void, 1, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`FieldNullabilityMemoization.nullable` is nullable and is not locally checked for null when calling `toString()`.], FieldNullabilityMemoization, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/FieldNullabilityMemoization.java, codetoanalyze.java.nullsafe.FieldNullabilityMemoization.dereferenceViaLocalVarIsBAD():void, 2, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`a` is nullable and is not locally checked for null when calling `toString()`: field nullable at line 35.], FieldNullabilityMemoization, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/FieldOverAnnotated.java, Linters_dummy_method, 15, ERADICATE_META_CLASS_CAN_BE_NULLSAFE, no_bucket, ADVICE, [Congrats! `FieldOverAnnotated` is free of nullability issues. Mark it `@Nullsafe(Nullsafe.Mode.LOCAL)` to prevent regressions.], FieldOverAnnotated, codetoanalyze.java.nullsafe, issues: 0, curr_mode: "Default", promote_mode: "Strict"
codetoanalyze/java/nullsafe/FieldOverAnnotated.java, codetoanalyze.java.nullsafe.FieldOverAnnotated.<init>(int), 0, ERADICATE_FIELD_OVER_ANNOTATED, no_bucket, ADVICE, [Field `FieldOverAnnotated.initializedInAllConstructorsIsBAD` is always initialized in the constructor but is declared `@Nullable`], FieldOverAnnotated, codetoanalyze.java.nullsafe, field:codetoanalyze.java.nullsafe.FieldOverAnnotated.initializedInAllConstructorsIsBAD
codetoanalyze/java/nullsafe/FieldOverAnnotated.java, codetoanalyze.java.nullsafe.FieldOverAnnotated.<init>(int), 0, ERADICATE_FIELD_OVER_ANNOTATED, no_bucket, ADVICE, [Field `FieldOverAnnotated.FP_initializedInAllConstructorsButSetToNullInAPublicMethodShouldBeOK` is always initialized in the constructor but is declared `@Nullable`], FieldOverAnnotated, codetoanalyze.java.nullsafe, field:codetoanalyze.java.nullsafe.FieldOverAnnotated.FP_initializedInAllConstructorsButSetToNullInAPublicMethodShouldBeOK
codetoanalyze/java/nullsafe/FieldOverAnnotated.java, codetoanalyze.java.nullsafe.FieldOverAnnotated.<init>(int), 0, ERADICATE_FIELD_OVER_ANNOTATED, no_bucket, ADVICE, [Field `FieldOverAnnotated.initilizedInAllConstructorsAndAllBranchesIsBAD` is always initialized in the constructor but is declared `@Nullable`], FieldOverAnnotated, codetoanalyze.java.nullsafe, field:codetoanalyze.java.nullsafe.FieldOverAnnotated.initilizedInAllConstructorsAndAllBranchesIsBAD
codetoanalyze/java/nullsafe/FieldOverAnnotated.java, codetoanalyze.java.nullsafe.FieldOverAnnotated.<init>(int,int), 0, ERADICATE_FIELD_OVER_ANNOTATED, no_bucket, ADVICE, [Field `FieldOverAnnotated.initializedInAllConstructorsIsBAD` is always initialized in the constructor but is declared `@Nullable`], FieldOverAnnotated, codetoanalyze.java.nullsafe, field:codetoanalyze.java.nullsafe.FieldOverAnnotated.initializedInAllConstructorsIsBAD
codetoanalyze/java/nullsafe/FieldOverAnnotated.java, codetoanalyze.java.nullsafe.FieldOverAnnotated.<init>(int,int), 0, ERADICATE_FIELD_OVER_ANNOTATED, no_bucket, ADVICE, [Field `FieldOverAnnotated.FP_initializedInAllConstructorsButSetToNullInAPublicMethodShouldBeOK` is always initialized in the constructor but is declared `@Nullable`], FieldOverAnnotated, codetoanalyze.java.nullsafe, field:codetoanalyze.java.nullsafe.FieldOverAnnotated.FP_initializedInAllConstructorsButSetToNullInAPublicMethodShouldBeOK
codetoanalyze/java/nullsafe/FieldOverAnnotated.java, codetoanalyze.java.nullsafe.FieldOverAnnotated.<init>(int,int), 0, ERADICATE_FIELD_OVER_ANNOTATED, no_bucket, ADVICE, [Field `FieldOverAnnotated.initilizedInAllConstructorsAndAllBranchesIsBAD` is always initialized in the constructor but is declared `@Nullable`], FieldOverAnnotated, codetoanalyze.java.nullsafe, field:codetoanalyze.java.nullsafe.FieldOverAnnotated.initilizedInAllConstructorsAndAllBranchesIsBAD
codetoanalyze/java/nullsafe/InconsistentSubclassAnnotation.java, Linters_dummy_method, 39, ERADICATE_META_CLASS_NEEDS_IMPROVEMENT, no_bucket, INFO, [], ReturnValToNullBAD, codetoanalyze.java.nullsafe, issues: 1, curr_mode: "Default"
codetoanalyze/java/nullsafe/InconsistentSubclassAnnotation.java, Linters_dummy_method, 46, ERADICATE_META_CLASS_CAN_BE_NULLSAFE, no_bucket, ADVICE, [Congrats! `ReturnNullToValOK` is free of nullability issues. Mark it `@Nullsafe(Nullsafe.Mode.LOCAL)` to prevent regressions.], ReturnNullToValOK, codetoanalyze.java.nullsafe, issues: 0, curr_mode: "Default", promote_mode: "Strict"
codetoanalyze/java/nullsafe/InconsistentSubclassAnnotation.java, Linters_dummy_method, 50, ERADICATE_META_CLASS_CAN_BE_NULLSAFE, no_bucket, ADVICE, [Congrats! `ReturnValFromValAndNullFromNullOK` is free of nullability issues. Mark it `@Nullsafe(Nullsafe.Mode.LOCAL)` to prevent regressions.], ReturnValFromValAndNullFromNullOK, codetoanalyze.java.nullsafe, issues: 0, curr_mode: "Default", promote_mode: "Strict"
codetoanalyze/java/nullsafe/InconsistentSubclassAnnotation.java, Linters_dummy_method, 61, ERADICATE_META_CLASS_CAN_BE_NULLSAFE, no_bucket, ADVICE, [Congrats! `AbstractReturnValToNullFN` is free of nullability issues. Mark it `@Nullsafe(Nullsafe.Mode.LOCAL)` to prevent regressions.], AbstractReturnValToNullFN, codetoanalyze.java.nullsafe, issues: 0, curr_mode: "Default", promote_mode: "Strict"
codetoanalyze/java/nullsafe/InconsistentSubclassAnnotation.java, Linters_dummy_method, 69, ERADICATE_META_CLASS_CAN_BE_NULLSAFE, no_bucket, ADVICE, [Congrats! `ArgValToNullOK` is free of nullability issues. Mark it `@Nullsafe(Nullsafe.Mode.LOCAL)` to prevent regressions.], ArgValToNullOK, codetoanalyze.java.nullsafe, issues: 0, curr_mode: "Default", promote_mode: "Strict"
codetoanalyze/java/nullsafe/InconsistentSubclassAnnotation.java, Linters_dummy_method, 75, ERADICATE_META_CLASS_NEEDS_IMPROVEMENT, no_bucket, INFO, [], ArgNullToValBAD, codetoanalyze.java.nullsafe, issues: 1, curr_mode: "Default"
codetoanalyze/java/nullsafe/InconsistentSubclassAnnotation.java, Linters_dummy_method, 81, ERADICATE_META_CLASS_NEEDS_IMPROVEMENT, no_bucket, INFO, [], ArgNullToValForInterfaceInAnotherFileBAD, codetoanalyze.java.nullsafe, issues: 1, curr_mode: "Default"
codetoanalyze/java/nullsafe/InconsistentSubclassAnnotation.java, Linters_dummy_method, 88, ERADICATE_META_CLASS_CAN_BE_NULLSAFE, no_bucket, ADVICE, [Congrats! `ArgValToValAndNullToNullOK` is free of nullability issues. Mark it `@Nullsafe(Nullsafe.Mode.LOCAL)` to prevent regressions.], ArgValToValAndNullToNullOK, codetoanalyze.java.nullsafe, issues: 0, curr_mode: "Default", promote_mode: "Strict"
codetoanalyze/java/nullsafe/InconsistentSubclassAnnotation.java, Linters_dummy_method, 102, ERADICATE_META_CLASS_CAN_BE_NULLSAFE, no_bucket, ADVICE, [Congrats! `OverrideExistingCorrectlyOK` is free of nullability issues. Mark it `@Nullsafe(Nullsafe.Mode.LOCAL)` to prevent regressions.], OverrideExistingCorrectlyOK, codetoanalyze.java.nullsafe, issues: 0, curr_mode: "Default", promote_mode: "Strict"
codetoanalyze/java/nullsafe/InconsistentSubclassAnnotation.java, Linters_dummy_method, 120, ERADICATE_META_CLASS_NEEDS_IMPROVEMENT, no_bucket, INFO, [], NoOverrideSinceDifferentTypesOK, codetoanalyze.java.nullsafe, issues: 0, curr_mode: "Default"
codetoanalyze/java/nullsafe/InconsistentSubclassAnnotation.java, Linters_dummy_method, 137, ERADICATE_META_CLASS_NEEDS_IMPROVEMENT, no_bucket, INFO, [], OverloadExistingIncorrectBAD, codetoanalyze.java.nullsafe, issues: 1, curr_mode: "Default"
codetoanalyze/java/nullsafe/InconsistentSubclassAnnotation.java, Linters_dummy_method, 146, ERADICATE_META_CLASS_CAN_BE_NULLSAFE, no_bucket, ADVICE, [Congrats! `ConstructorsAreExcluded` is free of nullability issues. Mark it `@Nullsafe(Nullsafe.Mode.LOCAL)` to prevent regressions.], ConstructorsAreExcluded, codetoanalyze.java.nullsafe, issues: 0, curr_mode: "Default", promote_mode: "Strict"
codetoanalyze/java/nullsafe/InconsistentSubclassAnnotation.java, Linters_dummy_method, 160, ERADICATE_META_CLASS_NEEDS_IMPROVEMENT, no_bucket, INFO, [], ExtendsExternalLibrary, codetoanalyze.java.nullsafe, issues: 1, curr_mode: "Default"
codetoanalyze/java/nullsafe/InconsistentSubclassAnnotation.java, Linters_dummy_method, 177, ERADICATE_META_CLASS_NEEDS_IMPROVEMENT, no_bucket, INFO, [], JavaLangEquals, codetoanalyze.java.nullsafe, issues: 2, curr_mode: "Default"
codetoanalyze/java/nullsafe/InconsistentSubclassAnnotation.java, Linters_dummy_method, 197, ERADICATE_META_CLASS_CAN_BE_NULLSAFE, no_bucket, ADVICE, [Congrats! `NonNullableConcreteGetterOK` is free of nullability issues. Mark it `@Nullsafe(Nullsafe.Mode.LOCAL)` to prevent regressions.], NonNullableConcreteGetterOK, codetoanalyze.java.nullsafe, issues: 0, curr_mode: "Default", promote_mode: "Strict"
codetoanalyze/java/nullsafe/InconsistentSubclassAnnotation.java, Linters_dummy_method, 203, ERADICATE_META_CLASS_NEEDS_IMPROVEMENT, no_bucket, INFO, [], NullableConcreteGetterBAD, codetoanalyze.java.nullsafe, issues: 1, curr_mode: "Default"
codetoanalyze/java/nullsafe/InconsistentSubclassAnnotation.java, codetoanalyze.java.nullsafe.ArgNullToValBAD.nullableArg(java.lang.String):java.lang.String, 0, ERADICATE_INCONSISTENT_SUBCLASS_PARAMETER_ANNOTATION, no_bucket, WARNING, [First parameter `arg` of method `ArgNullToValBAD.nullableArg(...)` is missing `@Nullable` declaration when overriding `VariousMethods.nullableArg(...)`. The parent method declared it can handle `null` for this param, so the child should also declare that.], ArgNullToValBAD, codetoanalyze.java.nullsafe, inconsistent_param_index:0
codetoanalyze/java/nullsafe/InconsistentSubclassAnnotation.java, codetoanalyze.java.nullsafe.ArgNullToValForInterfaceInAnotherFileBAD.implementInAnotherFile(java.lang.String):java.lang.String, 0, ERADICATE_INCONSISTENT_SUBCLASS_PARAMETER_ANNOTATION, no_bucket, WARNING, [First parameter `s` of method `ArgNullToValForInterfaceInAnotherFileBAD.implementInAnotherFile(...)` is missing `@Nullable` declaration when overriding `InconsistentSubclassAnnotationInterface.implementInAnotherFile(...)`. The parent method declared it can handle `null` for this param, so the child should also declare that.], ArgNullToValForInterfaceInAnotherFileBAD, codetoanalyze.java.nullsafe, inconsistent_param_index:0
codetoanalyze/java/nullsafe/InconsistentSubclassAnnotation.java, codetoanalyze.java.nullsafe.ExtendsExternalLibrary.externalMethod2(java.lang.Object):void, 0, ERADICATE_INCONSISTENT_SUBCLASS_PARAMETER_ANNOTATION, no_bucket, WARNING, [First parameter `object` of method `ExtendsExternalLibrary.externalMethod2(...)` is missing `@Nullable` declaration when overriding `SomeExternalClass.externalMethod2(...)`. The parent method declared it can handle `null` for this param, so the child should also declare that.], ExtendsExternalLibrary, codetoanalyze.java.nullsafe, inconsistent_param_index:0
codetoanalyze/java/nullsafe/InconsistentSubclassAnnotation.java, codetoanalyze.java.nullsafe.JavaLangEquals.equals(java.lang.Object):boolean, 0, ERADICATE_INCONSISTENT_SUBCLASS_PARAMETER_ANNOTATION, no_bucket, WARNING, [Parameter `x` is missing `@Nullable` declaration: according to the Java Specification, for any object `x` call `x.equals(null)` should properly return false.], JavaLangEquals, codetoanalyze.java.nullsafe, inconsistent_param_index:0
codetoanalyze/java/nullsafe/InconsistentSubclassAnnotation.java, codetoanalyze.java.nullsafe.JavaLangEquals.equals(java.lang.Object):boolean, 4, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`x` is nullable and is not locally checked for null when calling `toString()`: Object.equals() should be able to accept `null`, according to the Java specification.], JavaLangEquals, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/InconsistentSubclassAnnotation.java, codetoanalyze.java.nullsafe.NullableConcreteGetterBAD.get():java.lang.String, 0, ERADICATE_INCONSISTENT_SUBCLASS_RETURN_ANNOTATION, no_bucket, WARNING, [Child method `NullableConcreteGetterBAD.get()` is not substitution-compatible with its parent: the return type is declared as nullable, but parent method `NonNullableInterfaceGetterOK.get()` is missing `@Nullable` declaration. Either mark the parent as `@Nullable` or ensure the child does not return `null`.], NullableConcreteGetterBAD, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/InconsistentSubclassAnnotation.java, codetoanalyze.java.nullsafe.OverloadExistingIncorrectBAD.overload(java.lang.String,java.lang.String):java.lang.String, 0, ERADICATE_INCONSISTENT_SUBCLASS_RETURN_ANNOTATION, no_bucket, WARNING, [Child method `OverloadExistingIncorrectBAD.overload(...)` is not substitution-compatible with its parent: the return type is declared as nullable, but parent method `Overloads.overload(...)` is missing `@Nullable` declaration. Either mark the parent as `@Nullable` or ensure the child does not return `null`.], OverloadExistingIncorrectBAD, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/InconsistentSubclassAnnotation.java, codetoanalyze.java.nullsafe.ReturnValToNullBAD.valBoth(java.lang.String):java.lang.String, 0, ERADICATE_INCONSISTENT_SUBCLASS_RETURN_ANNOTATION, no_bucket, WARNING, [Child method `ReturnValToNullBAD.valBoth(...)` is not substitution-compatible with its parent: the return type is declared as nullable, but parent method `VariousMethods.valBoth(...)` is missing `@Nullable` declaration. Either mark the parent as `@Nullable` or ensure the child does not return `null`.], ReturnValToNullBAD, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/InheritanceForStrictMode.java, Linters_dummy_method, 14, ERADICATE_META_CLASS_NEEDS_IMPROVEMENT, no_bucket, INFO, [], InheritanceForStrictMode, codetoanalyze.java.nullsafe, issues: 6, curr_mode: "Default"
codetoanalyze/java/nullsafe/InheritanceForStrictMode.java, codetoanalyze.java.nullsafe.InheritanceForStrictMode$NonStrictExtendingStrict.badToAddNullableInChildren():java.lang.String, 0, ERADICATE_INCONSISTENT_SUBCLASS_RETURN_ANNOTATION, no_bucket, WARNING, [Child method `InheritanceForStrictMode$NonStrictExtendingStrict.badToAddNullableInChildren()` is not substitution-compatible with its parent: the return type is declared as nullable, but parent method `InheritanceForStrictMode$StrictBase.badToAddNullableInChildren()` is missing `@Nullable` declaration. Either mark the parent as `@Nullable` or ensure the child does not return `null`.], InheritanceForStrictMode$NonStrictExtendingStrict, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/InheritanceForStrictMode.java, codetoanalyze.java.nullsafe.InheritanceForStrictMode$NonStrictExtendingStrict.params(java.lang.String,java.lang.String):void, 0, ERADICATE_INCONSISTENT_SUBCLASS_PARAMETER_ANNOTATION, no_bucket, WARNING, [First parameter `badToRemoveNullableInChildren` of method `InheritanceForStrictMode$NonStrictExtendingStrict.params(...)` is missing `@Nullable` declaration when overriding `InheritanceForStrictMode$StrictBase.params(...)`. The parent method declared it can handle `null` for this param, so the child should also declare that.], InheritanceForStrictMode$NonStrictExtendingStrict, codetoanalyze.java.nullsafe, inconsistent_param_index:0
codetoanalyze/java/nullsafe/InheritanceForStrictMode.java, codetoanalyze.java.nullsafe.InheritanceForStrictMode$StrictExtendingNonstrict.badToAddNullableInChildren():java.lang.String, 0, ERADICATE_INCONSISTENT_SUBCLASS_RETURN_ANNOTATION, no_bucket, ERROR, [Child method `InheritanceForStrictMode$StrictExtendingNonstrict.badToAddNullableInChildren()` is not substitution-compatible with its parent: the return type is declared as nullable, but parent method `InheritanceForStrictMode$NonStrictBase.badToAddNullableInChildren()` is missing `@Nullable` declaration. Either mark the parent as `@Nullable` or ensure the child does not return `null`.], InheritanceForStrictMode$StrictExtendingNonstrict, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/InheritanceForStrictMode.java, codetoanalyze.java.nullsafe.InheritanceForStrictMode$StrictExtendingNonstrict.params(java.lang.String,java.lang.String):void, 0, ERADICATE_INCONSISTENT_SUBCLASS_PARAMETER_ANNOTATION, no_bucket, ERROR, [First parameter `badToRemoveNullableInChildren` of method `InheritanceForStrictMode$StrictExtendingNonstrict.params(...)` is missing `@Nullable` declaration when overriding `InheritanceForStrictMode$NonStrictBase.params(...)`. The parent method declared it can handle `null` for this param, so the child should also declare that.], InheritanceForStrictMode$StrictExtendingNonstrict, codetoanalyze.java.nullsafe, inconsistent_param_index:0
codetoanalyze/java/nullsafe/InheritanceForStrictMode.java, codetoanalyze.java.nullsafe.InheritanceForStrictMode$StrictExtendingStrict.badToAddNullableInChildren():java.lang.String, 0, ERADICATE_INCONSISTENT_SUBCLASS_RETURN_ANNOTATION, no_bucket, ERROR, [Child method `InheritanceForStrictMode$StrictExtendingStrict.badToAddNullableInChildren()` is not substitution-compatible with its parent: the return type is declared as nullable, but parent method `InheritanceForStrictMode$StrictBase.badToAddNullableInChildren()` is missing `@Nullable` declaration. Either mark the parent as `@Nullable` or ensure the child does not return `null`.], InheritanceForStrictMode$StrictExtendingStrict, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/InheritanceForStrictMode.java, codetoanalyze.java.nullsafe.InheritanceForStrictMode$StrictExtendingStrict.params(java.lang.String,java.lang.String):void, 0, ERADICATE_INCONSISTENT_SUBCLASS_PARAMETER_ANNOTATION, no_bucket, ERROR, [First parameter `badToRemoveNullableInChildren` of method `InheritanceForStrictMode$StrictExtendingStrict.params(...)` is missing `@Nullable` declaration when overriding `InheritanceForStrictMode$StrictBase.params(...)`. The parent method declared it can handle `null` for this param, so the child should also declare that.], InheritanceForStrictMode$StrictExtendingStrict, codetoanalyze.java.nullsafe, inconsistent_param_index:0
codetoanalyze/java/nullsafe/JunitExample.java, Linters_dummy_method, 9, ERADICATE_META_CLASS_CAN_BE_NULLSAFE, no_bucket, ADVICE, [Congrats! `JunitExample` is free of nullability issues. Mark it `@Nullsafe(Nullsafe.Mode.LOCAL)` to prevent regressions.], JunitExample, <no package>, issues: 0, curr_mode: "Default", promote_mode: "LocalTrustAll"
codetoanalyze/java/nullsafe/Lambdas.java, Linters_dummy_method, 19, ERADICATE_META_CLASS_NEEDS_IMPROVEMENT, no_bucket, INFO, [], Lambdas, codetoanalyze.java.nullsafe, issues: 6, curr_mode: "Default"
codetoanalyze/java/nullsafe/Lambdas.java, codetoanalyze.java.nullsafe.Lambdas$Lambda$_22_0.onFailure(java.lang.Integer):void, 0, ERADICATE_INCONSISTENT_SUBCLASS_PARAMETER_ANNOTATION, no_bucket, WARNING, [First parameter `$bcvar1` of method `Lambdas$Lambda$_22_0.onFailure(...)` is missing `@Nullable` declaration when overriding `Lambdas$NullableCallbackWithDefaultMethods.onFailure(...)`. The parent method declared it can handle `null` for this param, so the child should also declare that.], Lambdas$Lambda$_22_0, codetoanalyze.java.nullsafe, inconsistent_param_index:0
codetoanalyze/java/nullsafe/Lambdas.java, codetoanalyze.java.nullsafe.Lambdas$Lambda$_27_1.apply(java.lang.Object):java.lang.Object, 0, ERADICATE_INCONSISTENT_SUBCLASS_PARAMETER_ANNOTATION, no_bucket, WARNING, [First parameter `$bcvar1` of method `Lambdas$Lambda$_27_1.apply(...)` is missing `@Nullable` declaration when overriding `Lambdas$NullableFunction.apply(...)`. The parent method declared it can handle `null` for this param, so the child should also declare that.], Lambdas$Lambda$_27_1, codetoanalyze.java.nullsafe, inconsistent_param_index:0
codetoanalyze/java/nullsafe/Lambdas.java, codetoanalyze.java.nullsafe.Lambdas$Lambda$_28_1.apply(java.lang.Object):java.lang.Object, 0, ERADICATE_INCONSISTENT_SUBCLASS_PARAMETER_ANNOTATION, no_bucket, WARNING, [First parameter `$bcvar1` of method `Lambdas$Lambda$_28_1.apply(...)` is missing `@Nullable` declaration when overriding `Lambdas$NullableFunction.apply(...)`. The parent method declared it can handle `null` for this param, so the child should also declare that.], Lambdas$Lambda$_28_1, codetoanalyze.java.nullsafe, inconsistent_param_index:0
codetoanalyze/java/nullsafe/Lambdas.java, codetoanalyze.java.nullsafe.Lambdas$Lambda$_29_1.apply(java.lang.Object):java.lang.Object, 0, ERADICATE_INCONSISTENT_SUBCLASS_PARAMETER_ANNOTATION, no_bucket, WARNING, [First parameter `$bcvar1` of method `Lambdas$Lambda$_29_1.apply(...)` is missing `@Nullable` declaration when overriding `Lambdas$NullableFunction.apply(...)`. The parent method declared it can handle `null` for this param, so the child should also declare that.], Lambdas$Lambda$_29_1, codetoanalyze.java.nullsafe, inconsistent_param_index:0
codetoanalyze/java/nullsafe/Lambdas.java, codetoanalyze.java.nullsafe.Lambdas$NullsafeClass.useJavaUtilFunction_UNSUPPORTED(java.util.function.Function):java.lang.String, 1, ERADICATE_PARAMETER_NOT_NULLABLE, no_bucket, ERROR, [Third-party `Function.apply(...)` is missing a signature that would allow passing a nullable to param #1. Actual argument `getNullableString()` is nullable. Consider adding the correct signature of `Function.apply(...)` to nullsafe/third-party-signatures/java.sig.], Lambdas$NullsafeClass, codetoanalyze.java.nullsafe, unvetted_3rd_party:[java.util.function.Function#apply(java.lang.Object)], nullable_methods:codetoanalyze.java.nullsafe.Lambdas.getNullableString at 144
codetoanalyze/java/nullsafe/Lambdas.java, codetoanalyze.java.nullsafe.Lambdas$NullsafeClass.useJavaUtilFunction_UNSUPPORTED(java.util.function.Function):java.lang.String, 1, ERADICATE_UNVETTED_THIRD_PARTY_IN_NULLSAFE, no_bucket, ERROR, [`Function.apply(...)`: `@Nullsafe` mode prohibits using values coming from not vetted third party methods without a check. Result of this call is used at line 143. Either add a local check for null or assertion, or add the correct signature to nullsafe/third-party-signatures/java.sig.], Lambdas$NullsafeClass, codetoanalyze.java.nullsafe, unvetted_3rd_party:[java.util.function.Function#apply(java.lang.Object)]
codetoanalyze/java/nullsafe/LibraryCalls.java, Linters_dummy_method, 15, ERADICATE_META_CLASS_NEEDS_IMPROVEMENT, no_bucket, INFO, [], LibraryCalls, codetoanalyze.java.nullsafe, issues: 4, curr_mode: "Default"
codetoanalyze/java/nullsafe/LibraryCalls.java, codetoanalyze.java.nullsafe.LibraryCalls.badAtomicReferenceDereference(java.util.concurrent.atomic.AtomicReference):java.lang.String, 1, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`ref.get()` is nullable and is not locally checked for null when calling `toString()`: call to AtomicReference.get() at line 31 (nullable according to nullsafe internal models).], LibraryCalls, codetoanalyze.java.nullsafe, nullable_methods:java.util.concurrent.atomic.AtomicReference.get at 31
codetoanalyze/java/nullsafe/LibraryCalls.java, codetoanalyze.java.nullsafe.LibraryCalls.badPhantomReferenceDereference(java.lang.ref.PhantomReference):java.lang.String, 1, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`ref.get()` is nullable and is not locally checked for null when calling `toString()`: call to PhantomReference.get() at line 26 (nullable according to nullsafe internal models).], LibraryCalls, codetoanalyze.java.nullsafe, nullable_methods:java.lang.ref.PhantomReference.get at 26
codetoanalyze/java/nullsafe/LibraryCalls.java, codetoanalyze.java.nullsafe.LibraryCalls.badReferenceDereference(java.lang.ref.Reference):java.lang.String, 1, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`ref.get()` is nullable and is not locally checked for null when calling `toString()`: call to Reference.get() at line 18 (nullable according to nullsafe internal models).], LibraryCalls, codetoanalyze.java.nullsafe, nullable_methods:java.lang.ref.Reference.get at 18
codetoanalyze/java/nullsafe/LibraryCalls.java, codetoanalyze.java.nullsafe.LibraryCalls.badWeakReferenceDereference(java.lang.ref.WeakReference):java.lang.String, 1, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`ref.get()` is nullable and is not locally checked for null when calling `toString()`: call to Reference.get() at line 22 (nullable according to nullsafe internal models).], LibraryCalls, codetoanalyze.java.nullsafe, nullable_methods:java.lang.ref.Reference.get at 22
codetoanalyze/java/nullsafe/MapNullability.java, Linters_dummy_method, 13, ERADICATE_META_CLASS_NEEDS_IMPROVEMENT, no_bucket, INFO, [], MapNullability, codetoanalyze.java.nullsafe, issues: 13, curr_mode: "Default"
codetoanalyze/java/nullsafe/MapNullability.java, codetoanalyze.java.nullsafe.MapNullability$TestThatGetAfterPutIsAllowed.getAfterConditionalPutWrongKeyIsBAD(java.util.Map,java.lang.String,java.lang.String):void, 5, ERADICATE_FIELD_NOT_NULLABLE, no_bucket, WARNING, [`dontAssignNull` is declared non-nullable but is assigned a nullable: call to Map.get(...) at line 137 (nullable according to nullsafe internal models).], MapNullability$TestThatGetAfterPutIsAllowed, codetoanalyze.java.nullsafe, nullable_methods:java.util.Map.get at 137, field:codetoanalyze.java.nullsafe.MapNullability$TestThatGetAfterPutIsAllowed.dontAssignNull
codetoanalyze/java/nullsafe/MapNullability.java, codetoanalyze.java.nullsafe.MapNullability$TestThatGetAfterPutIsAllowed.getAfterPutNullableIsBAD(java.util.Map,java.lang.String):void, 2, ERADICATE_PARAMETER_NOT_NULLABLE, no_bucket, WARNING, [`Map.put(...)`: parameter #2 is declared non-nullable (according to nullsafe internal models) but the argument `nullableValue` is nullable.], MapNullability$TestThatGetAfterPutIsAllowed, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/MapNullability.java, codetoanalyze.java.nullsafe.MapNullability$TestThatGetAfterPutIsAllowed.getAfterPutNullableIsBAD(java.util.Map,java.lang.String):void, 3, ERADICATE_FIELD_NOT_NULLABLE, no_bucket, WARNING, [`dontAssignNull` is declared non-nullable but is assigned a nullable: method parameter nullableValue.], MapNullability$TestThatGetAfterPutIsAllowed, codetoanalyze.java.nullsafe, field:codetoanalyze.java.nullsafe.MapNullability$TestThatGetAfterPutIsAllowed.dontAssignNull
codetoanalyze/java/nullsafe/MapNullability.java, codetoanalyze.java.nullsafe.MapNullability$TestThatGetAfterPutIsAllowed.getAfterPutSeveralKeysButGetWrongOneIsBAD(java.util.Map):void, 4, ERADICATE_FIELD_NOT_NULLABLE, no_bucket, WARNING, [`dontAssignNull` is declared non-nullable but is assigned a nullable: call to Map.get(...) at line 98 (nullable according to nullsafe internal models).], MapNullability$TestThatGetAfterPutIsAllowed, codetoanalyze.java.nullsafe, nullable_methods:java.util.Map.get at 98, field:codetoanalyze.java.nullsafe.MapNullability$TestThatGetAfterPutIsAllowed.dontAssignNull
codetoanalyze/java/nullsafe/MapNullability.java, codetoanalyze.java.nullsafe.MapNullability$TestThatGetAfterPutIsAllowed.getAfterPutWrongKeyIsBAD(java.util.Map,java.lang.String,java.lang.String):void, 3, ERADICATE_FIELD_NOT_NULLABLE, no_bucket, WARNING, [`dontAssignNull` is declared non-nullable but is assigned a nullable: call to Map.get(...) at line 79 (nullable according to nullsafe internal models).], MapNullability$TestThatGetAfterPutIsAllowed, codetoanalyze.java.nullsafe, nullable_methods:java.util.Map.get at 79, field:codetoanalyze.java.nullsafe.MapNullability$TestThatGetAfterPutIsAllowed.dontAssignNull
codetoanalyze/java/nullsafe/MapNullability.java, codetoanalyze.java.nullsafe.MapNullability$TestThatGetAfterPutIsAllowed.getWithoutPutIsBAD(java.util.Map,java.lang.String):void, 1, ERADICATE_FIELD_NOT_NULLABLE, no_bucket, WARNING, [`dontAssignNull` is declared non-nullable but is assigned a nullable: call to Map.get(...) at line 73 (nullable according to nullsafe internal models).], MapNullability$TestThatGetAfterPutIsAllowed, codetoanalyze.java.nullsafe, nullable_methods:java.util.Map.get at 73, field:codetoanalyze.java.nullsafe.MapNullability$TestThatGetAfterPutIsAllowed.dontAssignNull
codetoanalyze/java/nullsafe/MapNullability.java, codetoanalyze.java.nullsafe.MapNullability$TestThatGetAfterPutIsAllowed.overwriteKeyByNonnullIsOK(java.util.Map,java.lang.String):void, 1, ERADICATE_PARAMETER_NOT_NULLABLE, no_bucket, WARNING, [`Map.put(...)`: parameter #2 is declared non-nullable (according to nullsafe internal models) but the argument is `null`.], MapNullability$TestThatGetAfterPutIsAllowed, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/MapNullability.java, codetoanalyze.java.nullsafe.MapNullability$TestThatGetAfterPutIsAllowed.overwriteKeyByNullIsBAD(java.util.Map,java.lang.String):void, 2, ERADICATE_PARAMETER_NOT_NULLABLE, no_bucket, WARNING, [`Map.put(...)`: parameter #2 is declared non-nullable (according to nullsafe internal models) but the argument is `null`.], MapNullability$TestThatGetAfterPutIsAllowed, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/MapNullability.java, codetoanalyze.java.nullsafe.MapNullability$TestThatGetAfterPutIsAllowed.overwriteKeyByNullIsBAD(java.util.Map,java.lang.String):void, 3, ERADICATE_FIELD_NOT_NULLABLE, no_bucket, WARNING, [`dontAssignNull` is declared non-nullable but is assigned `null`: null constant at line 114.], MapNullability$TestThatGetAfterPutIsAllowed, codetoanalyze.java.nullsafe, field:codetoanalyze.java.nullsafe.MapNullability$TestThatGetAfterPutIsAllowed.dontAssignNull
codetoanalyze/java/nullsafe/MapNullability.java, codetoanalyze.java.nullsafe.MapNullability$TestThatGetIsAllowedOnlyAfterContainsKeyWasChecked.immutableMap_usingGetAfterWrongKeyWasCheckedIsBAD(com.google.common.collect.ImmutableMap):void, 3, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`m.get(...)` is nullable and is not locally checked for null when calling `isEmpty()`: call to ImmutableMap.get(...) at line 59 (nullable according to nullsafe internal models).], MapNullability$TestThatGetIsAllowedOnlyAfterContainsKeyWasChecked, codetoanalyze.java.nullsafe, nullable_methods:com.google.common.collect.ImmutableMap.get at 59
codetoanalyze/java/nullsafe/MapNullability.java, codetoanalyze.java.nullsafe.MapNullability$TestThatGetIsAllowedOnlyAfterContainsKeyWasChecked.usingGetAfterWrongKeyWasCheckedInWhileLoopIsBAD(java.util.Map):void, 3, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`m.get(...)` is nullable and is not locally checked for null when calling `isEmpty()`: call to Map.get(...) at line 44 (nullable according to nullsafe internal models).], MapNullability$TestThatGetIsAllowedOnlyAfterContainsKeyWasChecked, codetoanalyze.java.nullsafe, nullable_methods:java.util.Map.get at 44
codetoanalyze/java/nullsafe/MapNullability.java, codetoanalyze.java.nullsafe.MapNullability$TestThatGetIsAllowedOnlyAfterContainsKeyWasChecked.usingGetAfterWrongKeyWasCheckedIsBAD(java.util.Map):void, 2, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`m.get(...)` is nullable and is not locally checked for null when calling `isEmpty()`: call to Map.get(...) at line 29 (nullable according to nullsafe internal models).], MapNullability$TestThatGetIsAllowedOnlyAfterContainsKeyWasChecked, codetoanalyze.java.nullsafe, nullable_methods:java.util.Map.get at 29
codetoanalyze/java/nullsafe/MapNullability.java, codetoanalyze.java.nullsafe.MapNullability$TestThatGetIsAllowedOnlyAfterContainsKeyWasChecked.usingGetWithoutCheckingKeyIsBAD(java.util.Map):void, 1, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`m.get(...)` is nullable and is not locally checked for null when calling `isEmpty()`: call to Map.get(...) at line 24 (nullable according to nullsafe internal models).], MapNullability$TestThatGetIsAllowedOnlyAfterContainsKeyWasChecked, codetoanalyze.java.nullsafe, nullable_methods:java.util.Map.get at 24
codetoanalyze/java/nullsafe/ModePromotions.java, Linters_dummy_method, 18, ERADICATE_META_CLASS_CAN_BE_NULLSAFE, no_bucket, ADVICE, [Congrats! `Default_NoDeps_CanBePromotedToStrict` is free of nullability issues. Mark it `@Nullsafe(Nullsafe.Mode.LOCAL)` to prevent regressions.], Default_NoDeps_CanBePromotedToStrict, codetoanalyze.java.nullsafe, issues: 0, curr_mode: "Default", promote_mode: "Strict"
codetoanalyze/java/nullsafe/ModePromotions.java, Linters_dummy_method, 25, ERADICATE_META_CLASS_IS_NULLSAFE, no_bucket, INFO, [], Local_NoDeps_CanBePromotedToStrict, codetoanalyze.java.nullsafe, issues: 0, curr_mode: "LocalTrustAll", promote_mode: "Strict"
codetoanalyze/java/nullsafe/ModePromotions.java, Linters_dummy_method, 33, ERADICATE_META_CLASS_IS_NULLSAFE, no_bucket, INFO, [], Strict_NoDeps_NoPromos, codetoanalyze.java.nullsafe, issues: 0, curr_mode: "Strict"
codetoanalyze/java/nullsafe/ModePromotions.java, Linters_dummy_method, 39, ERADICATE_META_CLASS_CAN_BE_NULLSAFE, no_bucket, ADVICE, [Congrats! `Default_UsesDefault_CanBePromotedToTrustAll` is free of nullability issues. Mark it `@Nullsafe(Nullsafe.Mode.LOCAL)` to prevent regressions.], Default_UsesDefault_CanBePromotedToTrustAll, codetoanalyze.java.nullsafe, issues: 0, curr_mode: "Default", promote_mode: "LocalTrustAll"
codetoanalyze/java/nullsafe/ModePromotions.java, Linters_dummy_method, 47, ERADICATE_META_CLASS_CAN_BE_NULLSAFE, no_bucket, ADVICE, [Congrats! `Default_UsesItself_CanBePromotedToStrict` is free of nullability issues. Mark it `@Nullsafe(Nullsafe.Mode.LOCAL)` to prevent regressions.], Default_UsesItself_CanBePromotedToStrict, codetoanalyze.java.nullsafe, issues: 0, curr_mode: "Default", promote_mode: "Strict"
codetoanalyze/java/nullsafe/ModePromotions.java, Linters_dummy_method, 59, ERADICATE_META_CLASS_CAN_BE_NULLSAFE, no_bucket, ADVICE, [Congrats! `Default_UsesLocal_CanBePromotedToTrustNone` is free of nullability issues. Mark it `@Nullsafe(Nullsafe.Mode.LOCAL)` to prevent regressions.], Default_UsesLocal_CanBePromotedToTrustNone, codetoanalyze.java.nullsafe, issues: 0, curr_mode: "Default", promote_mode: "LocalTrustNone"
codetoanalyze/java/nullsafe/ModePromotions.java, Linters_dummy_method, 67, ERADICATE_META_CLASS_CAN_BE_NULLSAFE, no_bucket, ADVICE, [Congrats! `Default_UsesStrict_CanBePromotedToStrict` is free of nullability issues. Mark it `@Nullsafe(Nullsafe.Mode.LOCAL)` to prevent regressions.], Default_UsesStrict_CanBePromotedToStrict, codetoanalyze.java.nullsafe, issues: 0, curr_mode: "Default", promote_mode: "Strict"
codetoanalyze/java/nullsafe/ModePromotions.java, Linters_dummy_method, 78, ERADICATE_META_CLASS_IS_NULLSAFE, no_bucket, INFO, [], TrustSome_DoesNotUseTrusted_CanBePromotedToTrustNone, codetoanalyze.java.nullsafe, issues: 0, curr_mode: "LocalTrustSome", promote_mode: "LocalTrustNone"
codetoanalyze/java/nullsafe/ModePromotions.java, Linters_dummy_method, 87, ERADICATE_META_CLASS_IS_NULLSAFE, no_bucket, INFO, [], TrustSome_UsesTrusted_NoPromo, codetoanalyze.java.nullsafe, issues: 0, curr_mode: "LocalTrustSome"
codetoanalyze/java/nullsafe/ModePromotions.java, Linters_dummy_method, 96, ERADICATE_META_CLASS_IS_NULLSAFE, no_bucket, INFO, [], TrustSome_TrustToLocalIsNotNeeded_CanBePromotedToTrustNone, codetoanalyze.java.nullsafe, issues: 0, curr_mode: "LocalTrustSome", promote_mode: "LocalTrustNone"
codetoanalyze/java/nullsafe/ModePromotions.java, Linters_dummy_method, 105, ERADICATE_META_CLASS_IS_NULLSAFE, no_bucket, INFO, [], TrustSome_TrustStrictIsNotNeeded_CanBePromotedToStrict, codetoanalyze.java.nullsafe, issues: 0, curr_mode: "LocalTrustSome", promote_mode: "Strict"
codetoanalyze/java/nullsafe/ModePromotions.java, Linters_dummy_method, 112, ERADICATE_META_CLASS_IS_NULLSAFE, no_bucket, INFO, [], TrustNone_CanBePromotedToStrict, codetoanalyze.java.nullsafe, issues: 0, curr_mode: "LocalTrustNone", promote_mode: "Strict"
codetoanalyze/java/nullsafe/MyPreconditions.java, Linters_dummy_method, 11, ERADICATE_META_CLASS_CAN_BE_NULLSAFE, no_bucket, ADVICE, [Congrats! `MyPreconditions` is free of nullability issues. Mark it `@Nullsafe(Nullsafe.Mode.LOCAL)` to prevent regressions.], MyPreconditions, codetoanalyze.java.nullsafe, issues: 0, curr_mode: "Default", promote_mode: "Strict"
codetoanalyze/java/nullsafe/NestedFieldAccess.java, Linters_dummy_method, 12, ERADICATE_META_CLASS_NEEDS_IMPROVEMENT, no_bucket, INFO, [], NestedFieldAccess, codetoanalyze.java.nullsafe, issues: 15, curr_mode: "Default"
codetoanalyze/java/nullsafe/NestedFieldAccess.java, codetoanalyze.java.nullsafe.NestedFieldAccess$TestFunctionsIdempotent.chainOf0VsChainOf0ParamsMismatchIsBad():void, 2, ERADICATE_FIELD_NOT_NULLABLE, no_bucket, WARNING, [`dontAssignNull` is declared non-nullable but is assigned a nullable: call to nullable(...) at line 145.], NestedFieldAccess$TestFunctionsIdempotent, codetoanalyze.java.nullsafe, nullable_methods:codetoanalyze.java.nullsafe.NestedFieldAccess$TestFunctionsIdempotent.nullable at 145, field:codetoanalyze.java.nullsafe.NestedFieldAccess$TestFunctionsIdempotent.dontAssignNull
codetoanalyze/java/nullsafe/NestedFieldAccess.java, codetoanalyze.java.nullsafe.NestedFieldAccess$TestFunctionsIdempotent.chainOf0VsChainOf1IsBad():void, 2, ERADICATE_FIELD_NOT_NULLABLE, no_bucket, WARNING, [`dontAssignNull` is declared non-nullable but is assigned a nullable: call to nullable(...) at line 169.], NestedFieldAccess$TestFunctionsIdempotent, codetoanalyze.java.nullsafe, nullable_methods:codetoanalyze.java.nullsafe.NestedFieldAccess$TestFunctionsIdempotent.nullable at 169, field:codetoanalyze.java.nullsafe.NestedFieldAccess$TestFunctionsIdempotent.dontAssignNull
codetoanalyze/java/nullsafe/NestedFieldAccess.java, codetoanalyze.java.nullsafe.NestedFieldAccess$TestFunctionsIdempotent.chainOf1VsChainOf0IsBad():void, 2, ERADICATE_FIELD_NOT_NULLABLE, no_bucket, WARNING, [`dontAssignNull` is declared non-nullable but is assigned a nullable: call to nullable(...) at line 175.], NestedFieldAccess$TestFunctionsIdempotent, codetoanalyze.java.nullsafe, nullable_methods:codetoanalyze.java.nullsafe.NestedFieldAccess$TestFunctionsIdempotent.nullable at 175, field:codetoanalyze.java.nullsafe.NestedFieldAccess$TestFunctionsIdempotent.dontAssignNull
codetoanalyze/java/nullsafe/NestedFieldAccess.java, codetoanalyze.java.nullsafe.NestedFieldAccess$TestFunctionsIdempotent.chainOf1VsChainOf1ParamMismatchIsBad():void, 2, ERADICATE_FIELD_NOT_NULLABLE, no_bucket, WARNING, [`dontAssignNull` is declared non-nullable but is assigned a nullable: call to nullable(...) at line 187.], NestedFieldAccess$TestFunctionsIdempotent, codetoanalyze.java.nullsafe, nullable_methods:codetoanalyze.java.nullsafe.NestedFieldAccess$TestFunctionsIdempotent.nullable at 187, field:codetoanalyze.java.nullsafe.NestedFieldAccess$TestFunctionsIdempotent.dontAssignNull
codetoanalyze/java/nullsafe/NestedFieldAccess.java, codetoanalyze.java.nullsafe.NestedFieldAccess$TestFunctionsIdempotent.chainOf1VsChainOf2IsBad():void, 2, ERADICATE_FIELD_NOT_NULLABLE, no_bucket, WARNING, [`dontAssignNull` is declared non-nullable but is assigned a nullable: call to nullable(...) at line 199.], NestedFieldAccess$TestFunctionsIdempotent, codetoanalyze.java.nullsafe, nullable_methods:codetoanalyze.java.nullsafe.NestedFieldAccess$TestFunctionsIdempotent.nullable at 199, field:codetoanalyze.java.nullsafe.NestedFieldAccess$TestFunctionsIdempotent.dontAssignNull
codetoanalyze/java/nullsafe/NestedFieldAccess.java, codetoanalyze.java.nullsafe.NestedFieldAccess$TestFunctionsIdempotent.chainOf2VsChainOf1IsBad():void, 2, ERADICATE_FIELD_NOT_NULLABLE, no_bucket, WARNING, [`dontAssignNull` is declared non-nullable but is assigned a nullable: call to nullable(...) at line 205.], NestedFieldAccess$TestFunctionsIdempotent, codetoanalyze.java.nullsafe, nullable_methods:codetoanalyze.java.nullsafe.NestedFieldAccess$TestFunctionsIdempotent.nullable at 205, field:codetoanalyze.java.nullsafe.NestedFieldAccess$TestFunctionsIdempotent.dontAssignNull
codetoanalyze/java/nullsafe/NestedFieldAccess.java, codetoanalyze.java.nullsafe.NestedFieldAccess$TestFunctionsIdempotent.otherObjVsItselfIsOKParamsMismatchIsBAD(codetoanalyze.java.nullsafe.NestedFieldAccess$TestFunctionsIdempotent):void, 2, ERADICATE_FIELD_NOT_NULLABLE, no_bucket, WARNING, [`dontAssignNull` is declared non-nullable but is assigned a nullable: call to nullable(...) at line 157.], NestedFieldAccess$TestFunctionsIdempotent, codetoanalyze.java.nullsafe, nullable_methods:codetoanalyze.java.nullsafe.NestedFieldAccess$TestFunctionsIdempotent.nullable at 157, field:codetoanalyze.java.nullsafe.NestedFieldAccess$TestFunctionsIdempotent.dontAssignNull
codetoanalyze/java/nullsafe/NestedFieldAccess.java, codetoanalyze.java.nullsafe.NestedFieldAccess$TestFunctionsIdempotent.selfVsOtherObjectIsBAD(codetoanalyze.java.nullsafe.NestedFieldAccess$TestFunctionsIdempotent):void, 2, ERADICATE_FIELD_NOT_NULLABLE, no_bucket, WARNING, [`dontAssignNull` is declared non-nullable but is assigned a nullable: call to nullable(...) at line 163.], NestedFieldAccess$TestFunctionsIdempotent, codetoanalyze.java.nullsafe, nullable_methods:codetoanalyze.java.nullsafe.NestedFieldAccess$TestFunctionsIdempotent.nullable at 163, field:codetoanalyze.java.nullsafe.NestedFieldAccess$TestFunctionsIdempotent.dontAssignNull
codetoanalyze/java/nullsafe/NestedFieldAccess.java, codetoanalyze.java.nullsafe.NestedFieldAccess$TestNullableChains.deep_AccessWithoutNullCheckIsBad(codetoanalyze.java.nullsafe.NestedFieldAccess$CC):void, 2, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`cc.c.s` is nullable and is not locally checked for null when calling `length()`.], NestedFieldAccess$TestNullableChains, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/NestedFieldAccess.java, codetoanalyze.java.nullsafe.NestedFieldAccess$TestNullableChains.field_AccessWithoutNullCheckIsBad():void, 1, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`NestedFieldAccess$TestNullableChains.s` is nullable and is not locally checked for null when calling `length()`.], NestedFieldAccess$TestNullableChains, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/NestedFieldAccess.java, codetoanalyze.java.nullsafe.NestedFieldAccess$TestNullableChains.local_AccessWithoutNullCheckIsBad():void, 2, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`c.s` is nullable and is not locally checked for null when calling `length()`.], NestedFieldAccess$TestNullableChains, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/NestedFieldAccess.java, codetoanalyze.java.nullsafe.NestedFieldAccess$TestNullableChains.nestedField_AccessWithoutNullCheckIsBad():void, 1, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`NestedFieldAccess$TestNullableChains.myc.s` is nullable and is not locally checked for null when calling `length()`.], NestedFieldAccess$TestNullableChains, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/NestedFieldAccess.java, codetoanalyze.java.nullsafe.NestedFieldAccess$TestNullableChains.param_AccessWithoutNullCheckIsBad(codetoanalyze.java.nullsafe.NestedFieldAccess$C):void, 1, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`c.s` is nullable and is not locally checked for null when calling `length()`.], NestedFieldAccess$TestNullableChains, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/NestedFieldAccess.java, codetoanalyze.java.nullsafe.NestedFieldAccess$TestNullableChains.veryDeep_AccessWithoutNullCheckIsBad(codetoanalyze.java.nullsafe.NestedFieldAccess$CCC):void, 2, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`ccc.cc.c.s` is nullable and is not locally checked for null when calling `length()`.], NestedFieldAccess$TestNullableChains, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/NestedFieldAccess.java, codetoanalyze.java.nullsafe.NestedFieldAccess$TestNullableChains.veryDeep_IncompleteAccessViaOrEarlyReturnIsBad(codetoanalyze.java.nullsafe.NestedFieldAccess$CCC):void, 3, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`ccc.cc.c.s` is nullable and is not locally checked for null when calling `length()`.], NestedFieldAccess$TestNullableChains, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/NoReuseUndefFunctionValues.java, Linters_dummy_method, 12, ERADICATE_META_CLASS_CAN_BE_NULLSAFE, no_bucket, ADVICE, [Congrats! `NoReuseUndefFunctionValues` is free of nullability issues. Mark it `@Nullsafe(Nullsafe.Mode.LOCAL)` to prevent regressions.], NoReuseUndefFunctionValues, codetoanalyze.java.nullsafe, issues: 0, curr_mode: "Default", promote_mode: "Strict"
codetoanalyze/java/nullsafe/NullFieldAccess.java, Linters_dummy_method, 12, ERADICATE_META_CLASS_NEEDS_IMPROVEMENT, no_bucket, INFO, [], NullFieldAccess, codetoanalyze.java.nullsafe, issues: 5, curr_mode: "Default"
codetoanalyze/java/nullsafe/NullFieldAccess.java, codetoanalyze.java.nullsafe.NullFieldAccess.<init>(), 0, ERADICATE_FIELD_OVER_ANNOTATED, no_bucket, ADVICE, [Field `NullFieldAccess.nullableArray` is always initialized in the constructor but is declared `@Nullable`], NullFieldAccess, codetoanalyze.java.nullsafe, field:codetoanalyze.java.nullsafe.NullFieldAccess.nullableArray
codetoanalyze/java/nullsafe/NullFieldAccess.java, codetoanalyze.java.nullsafe.NullFieldAccess.<init>(), 0, ERADICATE_FIELD_OVER_ANNOTATED, no_bucket, ADVICE, [Field `NullFieldAccess.nullable` is always initialized in the constructor but is declared `@Nullable`], NullFieldAccess, codetoanalyze.java.nullsafe, field:codetoanalyze.java.nullsafe.NullFieldAccess.nullable
codetoanalyze/java/nullsafe/NullFieldAccess.java, codetoanalyze.java.nullsafe.NullFieldAccess.testArray():void, 1, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [Array `NullFieldAccess.nullableArray` is nullable and is not locally checked for null when accessing its length.], NullFieldAccess, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/NullFieldAccess.java, codetoanalyze.java.nullsafe.NullFieldAccess.testArray():void, 2, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [Array `NullFieldAccess.nullableArray` is nullable and is not locally checked for null when accessing at index `0`.], NullFieldAccess, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/NullFieldAccess.java, codetoanalyze.java.nullsafe.NullFieldAccess.testInterface():void, 2, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`bad` is nullable and is not locally checked for null when calling `toString()`: field nullable at line 52.], NullFieldAccess, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/NullFieldAccess.java, codetoanalyze.java.nullsafe.NullFieldAccess.testNonStaticFields():void, 2, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`bad` is nullable and is not locally checked for null when calling `toString()`: field nullable at line 36.], NullFieldAccess, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/NullFieldAccess.java, codetoanalyze.java.nullsafe.NullFieldAccess.testStatic():void, 2, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`bad` is nullable and is not locally checked for null when calling `toString()`: field nullableStatic at line 44.], NullFieldAccess, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/NullMethodCall.java, Linters_dummy_method, 22, ERADICATE_META_CLASS_NEEDS_IMPROVEMENT, no_bucket, INFO, [], NullMethodCall, codetoanalyze.java.nullsafe, issues: 23, curr_mode: "Default"
codetoanalyze/java/nullsafe/NullMethodCall.java, codetoanalyze.java.nullsafe.NullMethodCall$Inner.outerField():int, 2, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`s` is nullable and is not locally checked for null when calling `length()`: field fld at line 69.], NullMethodCall$Inner, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/NullMethodCall.java, codetoanalyze.java.nullsafe.NullMethodCall$Inner.outerPrivateField():int, 2, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`s` is nullable and is not locally checked for null when calling `length()`: field pfld at line 80.], NullMethodCall$Inner, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/NullMethodCall.java, codetoanalyze.java.nullsafe.NullMethodCall.FP_propagatesNonNullAfterComparisonFieldOkay(java.lang.Object):void, 2, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`NullMethodCall.nullableField` is nullable and is not locally checked for null when calling `toString()`.], NullMethodCall, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/NullMethodCall.java, codetoanalyze.java.nullsafe.NullMethodCall.FP_propagatesNonNullAfterComparisonParameterOkay(java.lang.Object,java.lang.Object):void, 3, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`nullableParameter` is nullable and is not locally checked for null when calling `toString()`.], NullMethodCall, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/NullMethodCall.java, codetoanalyze.java.nullsafe.NullMethodCall.callOnNull():void, 2, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [NullPointerException will be thrown at this line! `s` is `null` and is dereferenced via calling `length()`: null constant at line 25.], NullMethodCall, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/NullMethodCall.java, codetoanalyze.java.nullsafe.NullMethodCall.callingSeverSideNullableGetter(codetoanalyze.java.nullsafe.ServerSideDeserializer):java.lang.String, 1, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`deserializer.nullableGetter()` is nullable and is not locally checked for null when calling `toString()`.], NullMethodCall, codetoanalyze.java.nullsafe, nullable_methods:codetoanalyze.java.nullsafe.ServerSideDeserializer.nullableGetter at 307
codetoanalyze/java/nullsafe/NullMethodCall.java, codetoanalyze.java.nullsafe.NullMethodCall.nullMethodCallWithAlarmManager(android.app.AlarmManager,android.app.PendingIntent):void, 1, ERADICATE_PARAMETER_NOT_NULLABLE, no_bucket, WARNING, [`AlarmManager.cancel(...)`: parameter #1 is declared non-nullable (according to nullsafe internal models) but the argument `intent` is nullable.], NullMethodCall, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/NullMethodCall.java, codetoanalyze.java.nullsafe.NullMethodCall.nullabilityNotPreservedAfterAssignment():void, 3, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`t` is nullable and is not locally checked for null when calling `toString()`: call to getNullable() at line 340.], NullMethodCall, codetoanalyze.java.nullsafe, nullable_methods:codetoanalyze.java.nullsafe.NullMethodCall.getNullable at 340
codetoanalyze/java/nullsafe/NullMethodCall.java, codetoanalyze.java.nullsafe.NullMethodCall.nullabilityStoredInBooleanFP():void, 3, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`getNullable()` is nullable and is not locally checked for null when calling `toString()`.], NullMethodCall, codetoanalyze.java.nullsafe, nullable_methods:codetoanalyze.java.nullsafe.NullMethodCall.getNullable at 346
codetoanalyze/java/nullsafe/NullMethodCall.java, codetoanalyze.java.nullsafe.NullMethodCall.testExceptionPerInstruction(int):void, 6, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [NullPointerException will be thrown at this line! `s` is `null` and is dereferenced via calling `length()`: null constant at line 181.], NullMethodCall, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/NullMethodCall.java, codetoanalyze.java.nullsafe.NullMethodCall.testFieldAssignmentIfThenElse(java.lang.String):void, 2, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`s` is nullable and is not locally checked for null when calling `length()`: null constant at line 172.], NullMethodCall, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/NullMethodCall.java, codetoanalyze.java.nullsafe.NullMethodCall.testMapGetBad(java.util.Map,java.util.HashMap,java.util.concurrent.ConcurrentHashMap):void, 2, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`m.get(...)` is nullable and is not locally checked for null when calling `toString()`: call to Map.get(...) at line 260 (nullable according to nullsafe internal models).], NullMethodCall, codetoanalyze.java.nullsafe, nullable_methods:java.util.Map.get at 260
codetoanalyze/java/nullsafe/NullMethodCall.java, codetoanalyze.java.nullsafe.NullMethodCall.testMapGetBad(java.util.Map,java.util.HashMap,java.util.concurrent.ConcurrentHashMap):void, 3, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`hm.get(...)` is nullable and is not locally checked for null when calling `toString()`: call to HashMap.get(...) at line 261 (nullable according to nullsafe internal models).], NullMethodCall, codetoanalyze.java.nullsafe, nullable_methods:java.util.HashMap.get at 261
codetoanalyze/java/nullsafe/NullMethodCall.java, codetoanalyze.java.nullsafe.NullMethodCall.testMapGetBad(java.util.Map,java.util.HashMap,java.util.concurrent.ConcurrentHashMap):void, 4, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`chm.get(...)` is nullable and is not locally checked for null when calling `toString()`: call to ConcurrentHashMap.get(...) at line 262 (nullable according to nullsafe internal models).], NullMethodCall, codetoanalyze.java.nullsafe, nullable_methods:java.util.concurrent.ConcurrentHashMap.get at 262
codetoanalyze/java/nullsafe/NullMethodCall.java, codetoanalyze.java.nullsafe.NullMethodCall.testMapRemoveBad(java.util.Map,java.util.HashMap,java.util.concurrent.ConcurrentHashMap):void, 2, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`m.remove(...)` is nullable and is not locally checked for null when calling `toString()`: call to Map.remove(...) at line 267 (nullable according to nullsafe internal models).], NullMethodCall, codetoanalyze.java.nullsafe, nullable_methods:java.util.Map.remove at 267
codetoanalyze/java/nullsafe/NullMethodCall.java, codetoanalyze.java.nullsafe.NullMethodCall.testMapRemoveBad(java.util.Map,java.util.HashMap,java.util.concurrent.ConcurrentHashMap):void, 3, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`hm.remove(...)` is nullable and is not locally checked for null when calling `toString()`: call to HashMap.remove(...) at line 268 (nullable according to nullsafe internal models).], NullMethodCall, codetoanalyze.java.nullsafe, nullable_methods:java.util.HashMap.remove at 268
codetoanalyze/java/nullsafe/NullMethodCall.java, codetoanalyze.java.nullsafe.NullMethodCall.testMapRemoveBad(java.util.Map,java.util.HashMap,java.util.concurrent.ConcurrentHashMap):void, 4, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`chm.remove(...)` is nullable and is not locally checked for null when calling `toString()`: call to ConcurrentHashMap.remove(...) at line 269 (nullable according to nullsafe internal models).], NullMethodCall, codetoanalyze.java.nullsafe, nullable_methods:java.util.concurrent.ConcurrentHashMap.remove at 269
codetoanalyze/java/nullsafe/NullMethodCall.java, codetoanalyze.java.nullsafe.NullMethodCall.testNotDetectingInvariantFP(java.lang.Object,java.lang.Object):java.lang.String, 4, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`object2` is nullable and is not locally checked for null when calling `toString()`.], NullMethodCall, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/NullMethodCall.java, codetoanalyze.java.nullsafe.NullMethodCall.testPathGetParent():java.lang.String, 1, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`get(...).getParent()` is nullable and is not locally checked for null when calling `toString()`: call to Path.getParent() at line 360 (nullable according to nullsafe internal models).], NullMethodCall, codetoanalyze.java.nullsafe, nullable_methods:java.nio.file.Path.getParent at 360
codetoanalyze/java/nullsafe/NullMethodCall.java, codetoanalyze.java.nullsafe.NullMethodCall.testSystemGetPropertyReturn():void, 2, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`s` is nullable and is not locally checked for null when calling `length()`: call to System.getProperty(...) at line 235 (nullable according to nullsafe internal models).], NullMethodCall, codetoanalyze.java.nullsafe, nullable_methods:java.lang.System.getProperty at 235
codetoanalyze/java/nullsafe/NullMethodCall.java, codetoanalyze.java.nullsafe.NullMethodCall.testSystemGetenvBad():int, 2, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`envValue` is nullable and is not locally checked for null when calling `length()`: call to System.getenv(...) at line 240 (nullable according to nullsafe internal models).], NullMethodCall, codetoanalyze.java.nullsafe, nullable_methods:java.lang.System.getenv at 240
codetoanalyze/java/nullsafe/NullMethodCall.java, codetoanalyze.java.nullsafe.NullMethodCall.withConditionalAssignemnt(codetoanalyze.java.nullsafe.NullMethodCall$AnotherI,boolean,java.lang.Object,java.lang.Object):void, 2, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`i` is nullable and is not locally checked for null when calling `withObjectParameter(...)`.], NullMethodCall, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/NullMethodCall.java, codetoanalyze.java.nullsafe.NullMethodCall.withConjuction(codetoanalyze.java.nullsafe.NullMethodCall$AnotherI,boolean,boolean):void, 1, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`i` is nullable and is not locally checked for null when calling `withBooleanParameter(...)`.], NullMethodCall, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/NullsafeMode.java, Linters_dummy_method, 16, ERADICATE_META_CLASS_NEEDS_IMPROVEMENT, no_bucket, INFO, [], NullsafeMode, codetoanalyze.java.nullsafe, issues: 13, curr_mode: "Default"
codetoanalyze/java/nullsafe/NullsafeMode.java, codetoanalyze.java.nullsafe.NullsafeMode$NullsafeWithStrictMode.BAD_returnFromNonStrict():java.lang.String, 1, ERADICATE_UNCHECKED_USAGE_IN_NULLSAFE, no_bucket, ERROR, [`NullsafeMode$VariousMethods.returnVal()`: `@Nullsafe(STRICT)` prohibits using values coming from non-strict classes without a check. Result of this call is used at line 178. Either add a local check for null or assertion, or make `NullsafeMode$VariousMethods` nullsafe strict.], NullsafeMode$NullsafeWithStrictMode, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/NullsafeMode.java, codetoanalyze.java.nullsafe.NullsafeMode$StrictNullsafe.BAD_dereferenceNotAnnotatedThirdParty():void, 1, ERADICATE_UNVETTED_THIRD_PARTY_IN_NULLSAFE, no_bucket, ERROR, [`ThirdPartyTestClass.returnUnspecified()`: `@Nullsafe` mode prohibits using values coming from not vetted third party methods without a check. Result of this call is used at line 222. Either add a local check for null or assertion, or add the correct signature to nullsafe/third-party-signatures/some.test.pckg.sig.], NullsafeMode$StrictNullsafe, codetoanalyze.java.nullsafe, unvetted_3rd_party:[some.test.pckg.ThirdPartyTestClass#returnUnspecified()]
codetoanalyze/java/nullsafe/NullsafeMode.java, codetoanalyze.java.nullsafe.NullsafeMode$StrictNullsafe.BAD_passThirdPartyToUnchecked():codetoanalyze.java.nullsafe.NullsafeMode$UncheckedParams, 1, ERADICATE_UNVETTED_THIRD_PARTY_IN_NULLSAFE, no_bucket, ERROR, [`ThirdPartyTestClass.getUncheckedLong(...)`: `@Nullsafe` mode prohibits using values coming from not vetted third party methods without a check. Result of this call is used at line 218. Either add a local check for null or assertion, or add the correct signature to nullsafe/third-party-signatures/some.test.pckg.sig.], NullsafeMode$StrictNullsafe, codetoanalyze.java.nullsafe, unvetted_3rd_party:[some.test.pckg.ThirdPartyTestClass#getUncheckedLong(long)]
codetoanalyze/java/nullsafe/NullsafeMode.java, codetoanalyze.java.nullsafe.NullsafeMode$StrictNullsafe.BAD_returnFromNonNullsafe():java.lang.String, 1, ERADICATE_UNCHECKED_USAGE_IN_NULLSAFE, no_bucket, ERROR, [`NullsafeMode$NonNullsafe.returnVal()`: `@Nullsafe(STRICT)` prohibits using values coming from non-strict classes without a check. Result of this call is used at line 201. Either add a local check for null or assertion, or make `NullsafeMode$NonNullsafe` nullsafe strict.], NullsafeMode$StrictNullsafe, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/NullsafeMode.java, codetoanalyze.java.nullsafe.NullsafeMode$TrustAllNullsafe.BAD_passThirdPartyToUnchecked():codetoanalyze.java.nullsafe.NullsafeMode$UncheckedParams, 1, ERADICATE_UNVETTED_THIRD_PARTY_IN_NULLSAFE, no_bucket, ERROR, [`ThirdPartyTestClass.getUncheckedLong(...)`: `@Nullsafe` mode prohibits using values coming from not vetted third party methods without a check. Result of this call is used at line 113. Either add a local check for null or assertion, or add the correct signature to nullsafe/third-party-signatures/some.test.pckg.sig.], NullsafeMode$TrustAllNullsafe, codetoanalyze.java.nullsafe, unvetted_3rd_party:[some.test.pckg.ThirdPartyTestClass#getUncheckedLong(long)]
codetoanalyze/java/nullsafe/NullsafeMode.java, codetoanalyze.java.nullsafe.NullsafeMode$TrustAllNullsafe.BAD_returnFromUnvettedThirdParty():java.lang.String, 1, ERADICATE_UNVETTED_THIRD_PARTY_IN_NULLSAFE, no_bucket, ERROR, [`ThirdPartyTestClass.returnUnspecified()`: `@Nullsafe` mode prohibits using values coming from not vetted third party methods without a check. Result of this call is used at line 92. Either add a local check for null or assertion, or add the correct signature to nullsafe/third-party-signatures/some.test.pckg.sig.], NullsafeMode$TrustAllNullsafe, codetoanalyze.java.nullsafe, unvetted_3rd_party:[some.test.pckg.ThirdPartyTestClass#returnUnspecified()]
codetoanalyze/java/nullsafe/NullsafeMode.java, codetoanalyze.java.nullsafe.NullsafeMode$TrustAllNullsafe.BAD_returnNonNullableFieldFromThirdParty():java.lang.String, 1, ERADICATE_UNVETTED_THIRD_PARTY_IN_NULLSAFE, no_bucket, ERROR, [`ThirdPartyTestClass.nonNullableField`: `@Nullsafe` mode prohibits using values coming from not vetted third party fields without a check. This field is used at line 100. Either add a local check for null or assertion, or access `nonNullableField` via a nullsafe getter.], NullsafeMode$TrustAllNullsafe, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/NullsafeMode.java, codetoanalyze.java.nullsafe.NullsafeMode$TrustAllNullsafe.BAD_returnNullFromNonNulsafe():java.lang.String, 0, ERADICATE_RETURN_NOT_NULLABLE, no_bucket, ERROR, [`BAD_returnNullFromNonNulsafe()`: return type is declared non-nullable but the method returns a nullable value: call to returnNull() at line 89.], NullsafeMode$TrustAllNullsafe, codetoanalyze.java.nullsafe, nullable_methods:codetoanalyze.java.nullsafe.NullsafeMode$VariousMethods.returnNull at 89
codetoanalyze/java/nullsafe/NullsafeMode.java, codetoanalyze.java.nullsafe.NullsafeMode$TrustAllNullsafe.BAD_returnNullableFieldFromThirdParty():java.lang.String, 0, ERADICATE_RETURN_NOT_NULLABLE, no_bucket, ERROR, [`BAD_returnNullableFieldFromThirdParty()`: return type is declared non-nullable but the method returns a nullable value: field nullableField at line 97.], NullsafeMode$TrustAllNullsafe, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/NullsafeMode.java, codetoanalyze.java.nullsafe.NullsafeMode$TrustNoneNullsafe.BAD_returnFromNonNullsafe():java.lang.String, 1, ERADICATE_UNCHECKED_USAGE_IN_NULLSAFE, no_bucket, ERROR, [`NullsafeMode$NonNullsafe.returnVal()`: `@Nullsafe(trust={...})` prohibits using values coming from non-`@Nullsafe` classes without a check, unless the class is in the trust list. Result of this call is used at line 158. Either add a local check for null or assertion, or make `NullsafeMode$NonNullsafe` @Nullsafe (or add it to trust list).], NullsafeMode$TrustNoneNullsafe, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/NullsafeMode.java, codetoanalyze.java.nullsafe.NullsafeMode$TrustSomeNullsafe.BAD_returnFromUntrustedNonNullsafe():java.lang.String, 1, ERADICATE_UNCHECKED_USAGE_IN_NULLSAFE, no_bucket, ERROR, [`NullsafeMode$VariousMethods.returnVal()`: `@Nullsafe(trust={...})` prohibits using values coming from non-`@Nullsafe` classes without a check, unless the class is in the trust list. Result of this call is used at line 138. Either add a local check for null or assertion, or make `NullsafeMode$VariousMethods` @Nullsafe (or add it to trust list).], NullsafeMode$TrustSomeNullsafe, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/NullsafeMode.java, codetoanalyze.java.nullsafe.NullsafeMode$TrustSomeNullsafe.BAD_returnNullFromNonNulsafe():java.lang.String, 0, ERADICATE_RETURN_NOT_NULLABLE, no_bucket, ERROR, [`BAD_returnNullFromNonNulsafe()`: return type is declared non-nullable but the method returns a nullable value: call to returnNull() at line 148.], NullsafeMode$TrustSomeNullsafe, codetoanalyze.java.nullsafe, nullable_methods:codetoanalyze.java.nullsafe.NullsafeMode$VariousMethods.returnNull at 148
codetoanalyze/java/nullsafe/NullsafeMode.java, codetoanalyze.java.nullsafe.NullsafeMode$TrustSomeNullsafe.FP_OK_accessFieldFromNonNullsafe():java.lang.String, 1, ERADICATE_UNCHECKED_USAGE_IN_NULLSAFE, no_bucket, ERROR, [`NullsafeMode$NonNullsafe.valField`: `@Nullsafe(trust={...})` prohibits using values coming from non-`@Nullsafe` classes without a check, unless the class is in the trust list. This field is used at line 151. Either add a local check for null or assertion, or make `NullsafeMode$NonNullsafe` @Nullsafe (or add it to trust list).], NullsafeMode$TrustSomeNullsafe, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/NullsafeMode.java, codetoanalyze.java.nullsafe.NullsafeMode$TrustSomeNullsafe.OK_returnFromUntrustedNonNullsafeAsNullable():java.lang.String, 0, ERADICATE_RETURN_OVER_ANNOTATED, no_bucket, ADVICE, [Method `OK_returnFromUntrustedNonNullsafeAsNullable()` is annotated with `@Nullable` but never returns null.], NullsafeMode$TrustSomeNullsafe, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/NullsafeModeNestedClasses.java, Linters_dummy_method, 14, ERADICATE_META_CLASS_NEEDS_IMPROVEMENT, no_bucket, INFO, [], NullsafeLocal, codetoanalyze.java.nullsafe, issues: 5, curr_mode: "LocalTrustAll"
codetoanalyze/java/nullsafe/NullsafeModeNestedClasses.java, Linters_dummy_method, 49, ERADICATE_REDUNDANT_NESTED_CLASS_ANNOTATION, no_bucket, ADVICE, [`NullsafeLocal$NestedExplicitLocal`: the same @Nullsafe mode is already specified in the outer class, so this annotation can be removed.], NullsafeLocal$NestedExplicitLocal, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/NullsafeModeNestedClasses.java, Linters_dummy_method, 57, ERADICATE_META_CLASS_NEEDS_IMPROVEMENT, no_bucket, INFO, [], NullsafeStrict, codetoanalyze.java.nullsafe, issues: 4, curr_mode: "Strict"
codetoanalyze/java/nullsafe/NullsafeModeNestedClasses.java, Linters_dummy_method, 71, ERADICATE_BAD_NESTED_CLASS_ANNOTATION, no_bucket, WARNING, [`NullsafeStrict$Nested$DeeplyNestedLocalIsStillStrict`: nested classes are disallowed to weaken @Nullsafe mode specified in the outer class. This annotation will be ignored.], NullsafeStrict$Nested$DeeplyNestedLocalIsStillStrict, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/NullsafeModeNestedClasses.java, Linters_dummy_method, 80, ERADICATE_BAD_NESTED_CLASS_ANNOTATION, no_bucket, WARNING, [`NullsafeStrict$NestedLocalIsStillStrict`: nested classes are disallowed to weaken @Nullsafe mode specified in the outer class. This annotation will be ignored.], NullsafeStrict$NestedLocalIsStillStrict, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/NullsafeModeNestedClasses.java, Linters_dummy_method, 87, ERADICATE_META_CLASS_NEEDS_IMPROVEMENT, no_bucket, INFO, [], Default, codetoanalyze.java.nullsafe, issues: 2, curr_mode: "Default"
codetoanalyze/java/nullsafe/NullsafeModeNestedClasses.java, Linters_dummy_method, 114, ERADICATE_META_CLASS_CAN_BE_NULLSAFE, no_bucket, ADVICE, [Congrats! `A` is free of nullability issues. Mark it `@Nullsafe(Nullsafe.Mode.LOCAL)` to prevent regressions.], A, codetoanalyze.java.nullsafe, issues: 0, curr_mode: "Default", promote_mode: "Strict"
codetoanalyze/java/nullsafe/NullsafeModeNestedClasses.java, Linters_dummy_method, 120, ERADICATE_META_CLASS_CAN_BE_NULLSAFE, no_bucket, ADVICE, [Congrats! `B` is free of nullability issues. Mark it `@Nullsafe(Nullsafe.Mode.LOCAL)` to prevent regressions.], B, codetoanalyze.java.nullsafe, issues: 0, curr_mode: "Default", promote_mode: "Strict"
codetoanalyze/java/nullsafe/NullsafeModeNestedClasses.java, Linters_dummy_method, 122, ERADICATE_META_CLASS_CAN_BE_NULLSAFE, no_bucket, ADVICE, [Congrats! `C` is free of nullability issues. Mark it `@Nullsafe(Nullsafe.Mode.LOCAL)` to prevent regressions.], C, codetoanalyze.java.nullsafe, issues: 0, curr_mode: "Default", promote_mode: "Strict"
codetoanalyze/java/nullsafe/NullsafeModeNestedClasses.java, Linters_dummy_method, 129, ERADICATE_META_CLASS_NEEDS_IMPROVEMENT, no_bucket, INFO, [], TrustSome, codetoanalyze.java.nullsafe, issues: 4, curr_mode: "LocalTrustSome"
codetoanalyze/java/nullsafe/NullsafeModeNestedClasses.java, Linters_dummy_method, 161, ERADICATE_BAD_NESTED_CLASS_ANNOTATION, no_bucket, WARNING, [Nested classes cannot add classes to trust list if they are not in the outer class trust list. Remove `C` from trust list.], TrustSome$CanNotAddToTrustList, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/NullsafeModeNestedClasses.java, codetoanalyze.java.nullsafe.Default$NestedLocal$DeeplyNestedStrict.returningDefaultNotNullIsError():java.lang.String, 1, ERADICATE_UNCHECKED_USAGE_IN_NULLSAFE, no_bucket, ERROR, [`Default.getString()`: `@Nullsafe(STRICT)` prohibits using values coming from non-strict classes without a check. Result of this call is used at line 107. Either add a local check for null or assertion, or make `Default` nullsafe strict.], Default$NestedLocal$DeeplyNestedStrict, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/NullsafeModeNestedClasses.java, codetoanalyze.java.nullsafe.Default$NestedLocal.shouldBeNullsafeModeError():java.lang.String, 0, ERADICATE_RETURN_NOT_NULLABLE, no_bucket, ERROR, [`shouldBeNullsafeModeError()`: return type is declared non-nullable but the method returns `null`: null constant at line 96.], Default$NestedLocal, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/NullsafeModeNestedClasses.java, codetoanalyze.java.nullsafe.NullsafeLocal$Nested$DeeplyNested.shouldBeNullsafeModeError():java.lang.String, 0, ERADICATE_RETURN_NOT_NULLABLE, no_bucket, ERROR, [`shouldBeNullsafeModeError()`: return type is declared non-nullable but the method returns `null`: null constant at line 29.], NullsafeLocal$Nested$DeeplyNested, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/NullsafeModeNestedClasses.java, codetoanalyze.java.nullsafe.NullsafeLocal$Nested.shouldBeNullsafeModeError():java.lang.String, 0, ERADICATE_RETURN_NOT_NULLABLE, no_bucket, ERROR, [`shouldBeNullsafeModeError()`: return type is declared non-nullable but the method returns `null`: null constant at line 23.], NullsafeLocal$Nested, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/NullsafeModeNestedClasses.java, codetoanalyze.java.nullsafe.NullsafeLocal$NestedExplicitLocal.shouldBeNullsafeModeError():java.lang.String, 0, ERADICATE_RETURN_NOT_NULLABLE, no_bucket, ERROR, [`shouldBeNullsafeModeError()`: return type is declared non-nullable but the method returns `null`: null constant at line 51.], NullsafeLocal$NestedExplicitLocal, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/NullsafeModeNestedClasses.java, codetoanalyze.java.nullsafe.NullsafeLocal$NestedStrict.returningDefaultNotNullIsError():java.lang.String, 1, ERADICATE_UNCHECKED_USAGE_IN_NULLSAFE, no_bucket, ERROR, [`Default.getString()`: `@Nullsafe(STRICT)` prohibits using values coming from non-strict classes without a check. Result of this call is used at line 42. Either add a local check for null or assertion, or make `Default` nullsafe strict.], NullsafeLocal$NestedStrict, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/NullsafeModeNestedClasses.java, codetoanalyze.java.nullsafe.NullsafeLocal.shouldBeNullsafeModeError():java.lang.String, 0, ERADICATE_RETURN_NOT_NULLABLE, no_bucket, ERROR, [`shouldBeNullsafeModeError()`: return type is declared non-nullable but the method returns `null`: null constant at line 17.], NullsafeLocal, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/NullsafeModeNestedClasses.java, codetoanalyze.java.nullsafe.NullsafeStrict$Nested$DeeplyNestedLocalIsStillStrict.returningDefaultNotNullIsError():java.lang.String, 1, ERADICATE_UNCHECKED_USAGE_IN_NULLSAFE, no_bucket, ERROR, [`Default.getString()`: `@Nullsafe(STRICT)` prohibits using values coming from non-strict classes without a check. Result of this call is used at line 72. Either add a local check for null or assertion, or make `Default` nullsafe strict.], NullsafeStrict$Nested$DeeplyNestedLocalIsStillStrict, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/NullsafeModeNestedClasses.java, codetoanalyze.java.nullsafe.NullsafeStrict$Nested.returningDefaultNotNullIsError():java.lang.String, 1, ERADICATE_UNCHECKED_USAGE_IN_NULLSAFE, no_bucket, ERROR, [`Default.getString()`: `@Nullsafe(STRICT)` prohibits using values coming from non-strict classes without a check. Result of this call is used at line 64. Either add a local check for null or assertion, or make `Default` nullsafe strict.], NullsafeStrict$Nested, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/NullsafeModeNestedClasses.java, codetoanalyze.java.nullsafe.NullsafeStrict$NestedLocalIsStillStrict.returningDefaultNotNullIsError():java.lang.String, 1, ERADICATE_UNCHECKED_USAGE_IN_NULLSAFE, no_bucket, ERROR, [`Default.getString()`: `@Nullsafe(STRICT)` prohibits using values coming from non-strict classes without a check. Result of this call is used at line 81. Either add a local check for null or assertion, or make `Default` nullsafe strict.], NullsafeStrict$NestedLocalIsStillStrict, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/NullsafeModeNestedClasses.java, codetoanalyze.java.nullsafe.NullsafeStrict.returningDefaultNotNullIsError():java.lang.String, 1, ERADICATE_UNCHECKED_USAGE_IN_NULLSAFE, no_bucket, ERROR, [`Default.getString()`: `@Nullsafe(STRICT)` prohibits using values coming from non-strict classes without a check. Result of this call is used at line 58. Either add a local check for null or assertion, or make `Default` nullsafe strict.], NullsafeStrict, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/NullsafeModeNestedClasses.java, codetoanalyze.java.nullsafe.TrustSome$CanNotAddToTrustList.stillDontTrustC_BAD():java.lang.String, 1, ERADICATE_UNCHECKED_USAGE_IN_NULLSAFE, no_bucket, ERROR, [`C.getString()`: `@Nullsafe(trust={...})` prohibits using values coming from non-`@Nullsafe` classes without a check, unless the class is in the trust list. Result of this call is used at line 162. Either add a local check for null or assertion, or make `C` @Nullsafe (or add it to trust list).], TrustSome$CanNotAddToTrustList, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/NullsafeModeNestedClasses.java, codetoanalyze.java.nullsafe.TrustSome$CanRemoveFromTrustList.dontTrustA_BAD():java.lang.String, 1, ERADICATE_UNCHECKED_USAGE_IN_NULLSAFE, no_bucket, ERROR, [`A.getString()`: `@Nullsafe(trust={...})` prohibits using values coming from non-`@Nullsafe` classes without a check, unless the class is in the trust list. Result of this call is used at line 153. Either add a local check for null or assertion, or make `A` @Nullsafe (or add it to trust list).], TrustSome$CanRemoveFromTrustList, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/NullsafeModeNestedClasses.java, codetoanalyze.java.nullsafe.TrustSome$NotAnnotatedNested.dontTrustC_Bad():java.lang.String, 1, ERADICATE_UNCHECKED_USAGE_IN_NULLSAFE, no_bucket, ERROR, [`C.getString()`: `@Nullsafe(trust={...})` prohibits using values coming from non-`@Nullsafe` classes without a check, unless the class is in the trust list. Result of this call is used at line 145. Either add a local check for null or assertion, or make `C` @Nullsafe (or add it to trust list).], TrustSome$NotAnnotatedNested, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/NullsafeModeNestedClasses.java, codetoanalyze.java.nullsafe.TrustSome.dontTrustC_Bad():java.lang.String, 1, ERADICATE_UNCHECKED_USAGE_IN_NULLSAFE, no_bucket, ERROR, [`C.getString()`: `@Nullsafe(trust={...})` prohibits using values coming from non-`@Nullsafe` classes without a check, unless the class is in the trust list. Result of this call is used at line 135. Either add a local check for null or assertion, or make `C` @Nullsafe (or add it to trust list).], TrustSome, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/ParameterNotNullable.java, Linters_dummy_method, 20, ERADICATE_META_CLASS_NEEDS_IMPROVEMENT, no_bucket, INFO, [], ParameterNotNullable, codetoanalyze.java.nullsafe, issues: 38, curr_mode: "Default"
codetoanalyze/java/nullsafe/ParameterNotNullable.java, Linters_dummy_method, 195, ERADICATE_META_CLASS_CAN_BE_NULLSAFE, no_bucket, ADVICE, [Congrats! `SomeClass` is free of nullability issues. Mark it `@Nullsafe(Nullsafe.Mode.LOCAL)` to prevent regressions.], SomeClass, codetoanalyze.java.nullsafe, issues: 0, curr_mode: "Default", promote_mode: "Strict"
codetoanalyze/java/nullsafe/ParameterNotNullable.java, codetoanalyze.java.nullsafe.ParameterNotNullable$ConstructorCall.<init>(codetoanalyze.java.nullsafe.ParameterNotNullable,int), 0, ERADICATE_PARAMETER_NOT_NULLABLE, no_bucket, WARNING, [`ParameterNotNullable$ConstructorCall(...)`: parameter #2(`s`) is declared non-nullable but the argument is `null`.], ParameterNotNullable$ConstructorCall, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/ParameterNotNullable.java, codetoanalyze.java.nullsafe.ParameterNotNullable.callNull():void, 2, ERADICATE_PARAMETER_NOT_NULLABLE, no_bucket, WARNING, [`ParameterNotNullable.test(...)`: parameter #1(`s`) is declared non-nullable but the argument `s` is `null`: null constant at line 39.], ParameterNotNullable, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/ParameterNotNullable.java, codetoanalyze.java.nullsafe.ParameterNotNullable.callNullable(java.lang.String):void, 1, ERADICATE_PARAMETER_NOT_NULLABLE, no_bucket, WARNING, [`ParameterNotNullable.test(...)`: parameter #1(`s`) is declared non-nullable but the argument `s` is nullable.], ParameterNotNullable, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/ParameterNotNullable.java, codetoanalyze.java.nullsafe.ParameterNotNullable.callWithConditionalAssignment(java.lang.Object,boolean):void, 1, ERADICATE_PARAMETER_NOT_NULLABLE, no_bucket, WARNING, [`ParameterNotNullable.doesNotAcceptNullableFirstParameter(...)`: parameter #1(`object`) is declared non-nullable but the argument `object` is nullable: null constant at line 116.], ParameterNotNullable, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/ParameterNotNullable.java, codetoanalyze.java.nullsafe.ParameterNotNullable.callWithNullableFirstParameter(boolean,boolean):void, 1, ERADICATE_PARAMETER_NOT_NULLABLE, no_bucket, WARNING, [`ParameterNotNullable.doesNotAcceptNullableFirstParameter(...)`: parameter #1(`object`) is declared non-nullable but the argument `formal parameter object` is `null`: null constant at line 112.], ParameterNotNullable, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/ParameterNotNullable.java, codetoanalyze.java.nullsafe.ParameterNotNullable.testClassGetResourceArgument(java.lang.Class):java.net.URL, 1, ERADICATE_PARAMETER_NOT_NULLABLE, no_bucket, WARNING, [`Class.getResource(...)`: parameter #1 is declared non-nullable (according to nullsafe internal models) but the argument is `null`.], ParameterNotNullable, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/ParameterNotNullable.java, codetoanalyze.java.nullsafe.ParameterNotNullable.testImmutableListCopyOfNotNullArguments():void, 6, ERADICATE_PARAMETER_NOT_NULLABLE, no_bucket, WARNING, [`ImmutableList.copyOf(...)`: parameter #1 is declared non-nullable (according to nullsafe internal models) but the argument `nullIterable` is `null`: null constant at line 131.], ParameterNotNullable, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/ParameterNotNullable.java, codetoanalyze.java.nullsafe.ParameterNotNullable.testImmutableListCopyOfNotNullArguments():void, 7, ERADICATE_PARAMETER_NOT_NULLABLE, no_bucket, WARNING, [`ImmutableList.copyOf(...)`: parameter #1 is declared non-nullable (according to nullsafe internal models) but the argument `nullIterator` is `null`: null constant at line 132.], ParameterNotNullable, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/ParameterNotNullable.java, codetoanalyze.java.nullsafe.ParameterNotNullable.testImmutableListCopyOfNotNullArguments():void, 8, ERADICATE_PARAMETER_NOT_NULLABLE, no_bucket, WARNING, [`ImmutableList.copyOf(...)`: parameter #1 is declared non-nullable (according to nullsafe internal models) but the argument `nullCollection` is `null`: null constant at line 133.], ParameterNotNullable, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/ParameterNotNullable.java, codetoanalyze.java.nullsafe.ParameterNotNullable.testImmutableListOfnotNullArguments():void, 4, ERADICATE_PARAMETER_NOT_NULLABLE, no_bucket, WARNING, [`ImmutableList.of(...)`: parameter #1 is declared non-nullable (according to nullsafe internal models) but the argument is `null`.], ParameterNotNullable, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/ParameterNotNullable.java, codetoanalyze.java.nullsafe.ParameterNotNullable.testImmutableListOfnotNullArguments():void, 5, ERADICATE_PARAMETER_NOT_NULLABLE, no_bucket, WARNING, [`ImmutableList.of(...)`: parameter #2 is declared non-nullable (according to nullsafe internal models) but the argument is `null`.], ParameterNotNullable, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/ParameterNotNullable.java, codetoanalyze.java.nullsafe.ParameterNotNullable.testImmutableListOfnotNullArguments():void, 5, ERADICATE_PARAMETER_NOT_NULLABLE, no_bucket, WARNING, [`ImmutableList.of(...)`: parameter #1 is declared non-nullable (according to nullsafe internal models) but the argument is `null`.], ParameterNotNullable, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/ParameterNotNullable.java, codetoanalyze.java.nullsafe.ParameterNotNullable.testImmutableListOfnotNullArguments():void, 7, ERADICATE_PARAMETER_NOT_NULLABLE, no_bucket, WARNING, [`ImmutableList.of(...)`: parameter #2 is declared non-nullable (according to nullsafe internal models) but the argument is `null`.], ParameterNotNullable, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/ParameterNotNullable.java, codetoanalyze.java.nullsafe.ParameterNotNullable.testImmutableListSortedCopyOfNotNullArguments():void, 1, ERADICATE_PARAMETER_NOT_NULLABLE, no_bucket, WARNING, [`ImmutableList.sortedCopyOf(...)`: parameter #1 is declared non-nullable (according to nullsafe internal models) but the argument is `null`.], ParameterNotNullable, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/ParameterNotNullable.java, codetoanalyze.java.nullsafe.ParameterNotNullable.testImmutableListSortedCopyOfNotNullArguments():void, 1, ERADICATE_PARAMETER_NOT_NULLABLE, no_bucket, WARNING, [`ImmutableList.sortedCopyOf(...)`: parameter #2 is declared non-nullable (according to nullsafe internal models) but the argument is `null`.], ParameterNotNullable, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/ParameterNotNullable.java, codetoanalyze.java.nullsafe.ParameterNotNullable.testImmutableMapCopyOfNotNullArguments():void, 5, ERADICATE_PARAMETER_NOT_NULLABLE, no_bucket, WARNING, [`ImmutableMap.copyOf(...)`: parameter #1 is declared non-nullable (according to nullsafe internal models) but the argument `nullIterable` is `null`: null constant at line 177.], ParameterNotNullable, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/ParameterNotNullable.java, codetoanalyze.java.nullsafe.ParameterNotNullable.testImmutableMapCopyOfNotNullArguments():void, 6, ERADICATE_PARAMETER_NOT_NULLABLE, no_bucket, WARNING, [`ImmutableMap.copyOf(...)`: parameter #1 is declared non-nullable (according to nullsafe internal models) but the argument `nullMap` is `null`: null constant at line 178.], ParameterNotNullable, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/ParameterNotNullable.java, codetoanalyze.java.nullsafe.ParameterNotNullable.testImmutableMapOfnotNullArguments():void, 4, ERADICATE_PARAMETER_NOT_NULLABLE, no_bucket, WARNING, [`ImmutableMap.of(...)`: parameter #2 is declared non-nullable (according to nullsafe internal models) but the argument is `null`.], ParameterNotNullable, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/ParameterNotNullable.java, codetoanalyze.java.nullsafe.ParameterNotNullable.testImmutableMapOfnotNullArguments():void, 4, ERADICATE_PARAMETER_NOT_NULLABLE, no_bucket, WARNING, [`ImmutableMap.of(...)`: parameter #1 is declared non-nullable (according to nullsafe internal models) but the argument is `null`.], ParameterNotNullable, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/ParameterNotNullable.java, codetoanalyze.java.nullsafe.ParameterNotNullable.testImmutableMapOfnotNullArguments():void, 6, ERADICATE_PARAMETER_NOT_NULLABLE, no_bucket, WARNING, [`ImmutableMap.of(...)`: parameter #4 is declared non-nullable (according to nullsafe internal models) but the argument is `null`.], ParameterNotNullable, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/ParameterNotNullable.java, codetoanalyze.java.nullsafe.ParameterNotNullable.testImmutableMapOfnotNullArguments():void, 6, ERADICATE_PARAMETER_NOT_NULLABLE, no_bucket, WARNING, [`ImmutableMap.of(...)`: parameter #2 is declared non-nullable (according to nullsafe internal models) but the argument is `null`.], ParameterNotNullable, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/ParameterNotNullable.java, codetoanalyze.java.nullsafe.ParameterNotNullable.testImmutableSetCopyOfNotNullArguments():void, 6, ERADICATE_PARAMETER_NOT_NULLABLE, no_bucket, WARNING, [`ImmutableSet.copyOf(...)`: parameter #1 is declared non-nullable (according to nullsafe internal models) but the argument `nullIterable` is `null`: null constant at line 157.], ParameterNotNullable, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/ParameterNotNullable.java, codetoanalyze.java.nullsafe.ParameterNotNullable.testImmutableSetCopyOfNotNullArguments():void, 7, ERADICATE_PARAMETER_NOT_NULLABLE, no_bucket, WARNING, [`ImmutableSet.copyOf(...)`: parameter #1 is declared non-nullable (according to nullsafe internal models) but the argument `nullIterator` is `null`: null constant at line 158.], ParameterNotNullable, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/ParameterNotNullable.java, codetoanalyze.java.nullsafe.ParameterNotNullable.testImmutableSetCopyOfNotNullArguments():void, 8, ERADICATE_PARAMETER_NOT_NULLABLE, no_bucket, WARNING, [`ImmutableSet.copyOf(...)`: parameter #1 is declared non-nullable (according to nullsafe internal models) but the argument `nullCollection` is `null`: null constant at line 159.], ParameterNotNullable, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/ParameterNotNullable.java, codetoanalyze.java.nullsafe.ParameterNotNullable.testImmutableSetOfnotNullArguments():void, 4, ERADICATE_PARAMETER_NOT_NULLABLE, no_bucket, WARNING, [`ImmutableSet.of(...)`: parameter #1 is declared non-nullable (according to nullsafe internal models) but the argument is `null`.], ParameterNotNullable, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/ParameterNotNullable.java, codetoanalyze.java.nullsafe.ParameterNotNullable.testImmutableSetOfnotNullArguments():void, 5, ERADICATE_PARAMETER_NOT_NULLABLE, no_bucket, WARNING, [`ImmutableSet.of(...)`: parameter #2 is declared non-nullable (according to nullsafe internal models) but the argument is `null`.], ParameterNotNullable, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/ParameterNotNullable.java, codetoanalyze.java.nullsafe.ParameterNotNullable.testImmutableSetOfnotNullArguments():void, 5, ERADICATE_PARAMETER_NOT_NULLABLE, no_bucket, WARNING, [`ImmutableSet.of(...)`: parameter #1 is declared non-nullable (according to nullsafe internal models) but the argument is `null`.], ParameterNotNullable, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/ParameterNotNullable.java, codetoanalyze.java.nullsafe.ParameterNotNullable.testImmutableSetOfnotNullArguments():void, 7, ERADICATE_PARAMETER_NOT_NULLABLE, no_bucket, WARNING, [`ImmutableSet.of(...)`: parameter #2 is declared non-nullable (according to nullsafe internal models) but the argument is `null`.], ParameterNotNullable, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/ParameterNotNullable.java, codetoanalyze.java.nullsafe.ParameterNotNullable.testImmutableSetOfnotNullArguments():void, 8, ERADICATE_PARAMETER_NOT_NULLABLE, no_bucket, WARNING, [`ImmutableSet.of(...)`: parameter #4 is declared non-nullable (according to nullsafe internal models) but the argument is `null`.], ParameterNotNullable, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/ParameterNotNullable.java, codetoanalyze.java.nullsafe.ParameterNotNullable.testImmutableSetOfnotNullArguments():void, 8, ERADICATE_PARAMETER_NOT_NULLABLE, no_bucket, WARNING, [`ImmutableSet.of(...)`: parameter #2 is declared non-nullable (according to nullsafe internal models) but the argument is `null`.], ParameterNotNullable, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/ParameterNotNullable.java, codetoanalyze.java.nullsafe.ParameterNotNullable.testParsingNullStringToNumber():void, 2, ERADICATE_PARAMETER_NOT_NULLABLE, no_bucket, WARNING, [`Long.parseLong(...)`: parameter #1 is declared non-nullable (according to nullsafe internal models) but the argument `ns` is `null`: null constant at line 185.], ParameterNotNullable, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/ParameterNotNullable.java, codetoanalyze.java.nullsafe.ParameterNotNullable.testParsingNullStringToNumber():void, 3, ERADICATE_PARAMETER_NOT_NULLABLE, no_bucket, WARNING, [`Integer.parseInt(...)`: parameter #1 is declared non-nullable (according to nullsafe internal models) but the argument `ns` is `null`: null constant at line 185.], ParameterNotNullable, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/ParameterNotNullable.java, codetoanalyze.java.nullsafe.ParameterNotNullable.testSystemGetPropertyArgument():java.lang.String, 1, ERADICATE_PARAMETER_NOT_NULLABLE, no_bucket, WARNING, [`System.getProperty(...)`: parameter #1 is declared non-nullable (according to nullsafe internal models) but the argument is `null`.], ParameterNotNullable, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/ParameterNotNullable.java, codetoanalyze.java.nullsafe.ParameterNotNullable.testSystemGetenvBad():java.lang.String, 1, ERADICATE_PARAMETER_NOT_NULLABLE, no_bucket, WARNING, [`System.getenv(...)`: parameter #1 is declared non-nullable (according to nullsafe internal models) but the argument is `null`.], ParameterNotNullable, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/ParameterNotNullable.java, codetoanalyze.java.nullsafe.ParameterNotNullable.testThreeParameters():void, 2, ERADICATE_PARAMETER_NOT_NULLABLE, no_bucket, WARNING, [`ParameterNotNullable.threeParameters(...)`: parameter #1(`s1`) is declared non-nullable but the argument is `null`.], ParameterNotNullable, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/ParameterNotNullable.java, codetoanalyze.java.nullsafe.ParameterNotNullable.testThreeParameters():void, 3, ERADICATE_PARAMETER_NOT_NULLABLE, no_bucket, WARNING, [`ParameterNotNullable.threeParameters(...)`: parameter #2(`s2`) is declared non-nullable but the argument is `null`.], ParameterNotNullable, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/ParameterNotNullable.java, codetoanalyze.java.nullsafe.ParameterNotNullable.testThreeParameters():void, 4, ERADICATE_PARAMETER_NOT_NULLABLE, no_bucket, WARNING, [`ParameterNotNullable.threeParameters(...)`: parameter #3(`s3`) is declared non-nullable but the argument is `null`.], ParameterNotNullable, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/PropagatesNullable.java, Linters_dummy_method, 14, ERADICATE_META_CLASS_NEEDS_IMPROVEMENT, no_bucket, INFO, [], TestPropagatesNullable, codetoanalyze.java.nullsafe, issues: 20, curr_mode: "Default"
codetoanalyze/java/nullsafe/PropagatesNullable.java, codetoanalyze.java.nullsafe.TestPropagatesNullable$TestBothParams.testBothParamsShouldBeNonnull(java.lang.String,java.lang.String):void, 1, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`propagatesNullable(...)` is nullable and is not locally checked for null when calling `length()`: method parameter sNullable.], TestPropagatesNullable$TestBothParams, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/PropagatesNullable.java, codetoanalyze.java.nullsafe.TestPropagatesNullable$TestBothParams.testBothParamsShouldBeNonnull(java.lang.String,java.lang.String):void, 2, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`propagatesNullable(...)` is nullable and is not locally checked for null when calling `length()`: method parameter sNullable.], TestPropagatesNullable$TestBothParams, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/PropagatesNullable.java, codetoanalyze.java.nullsafe.TestPropagatesNullable$TestBothParams.testBothParamsShouldBeNonnull(java.lang.String,java.lang.String):void, 3, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`propagatesNullable(...)` is nullable and is not locally checked for null when calling `length()`: method parameter sNullable.], TestPropagatesNullable$TestBothParams, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/PropagatesNullable.java, codetoanalyze.java.nullsafe.TestPropagatesNullable$TestOneParameter.test(java.lang.String,java.lang.String):void, 2, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [NullPointerException will be thrown at this line! `propagatesNullable(...)` is `null` and is dereferenced via calling `length()`: null constant at line 30.], TestPropagatesNullable$TestOneParameter, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/PropagatesNullable.java, codetoanalyze.java.nullsafe.TestPropagatesNullable$TestOneParameter.test(java.lang.String,java.lang.String):void, 3, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`nullable(...)` is nullable and is not locally checked for null when calling `length()`.], TestPropagatesNullable$TestOneParameter, codetoanalyze.java.nullsafe, nullable_methods:codetoanalyze.java.nullsafe.TestPropagatesNullable$TestOneParameter.nullable at 31
codetoanalyze/java/nullsafe/PropagatesNullable.java, codetoanalyze.java.nullsafe.TestPropagatesNullable$TestOneParameter.test(java.lang.String,java.lang.String):void, 6, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`propagatesNullable(...)` is nullable and is not locally checked for null when calling `length()`: method parameter sNullable.], TestPropagatesNullable$TestOneParameter, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/PropagatesNullable.java, codetoanalyze.java.nullsafe.TestPropagatesNullable$TestOneParameter.test(java.lang.String,java.lang.String):void, 7, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`nullable(...)` is nullable and is not locally checked for null when calling `length()`.], TestPropagatesNullable$TestOneParameter, codetoanalyze.java.nullsafe, nullable_methods:codetoanalyze.java.nullsafe.TestPropagatesNullable$TestOneParameter.nullable at 35
codetoanalyze/java/nullsafe/PropagatesNullable.java, codetoanalyze.java.nullsafe.TestPropagatesNullable$TestOneParameter.test(java.lang.String,java.lang.String):void, 11, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`nullable(...)` is nullable and is not locally checked for null when calling `length()`.], TestPropagatesNullable$TestOneParameter, codetoanalyze.java.nullsafe, nullable_methods:codetoanalyze.java.nullsafe.TestPropagatesNullable$TestOneParameter.nullable at 39
codetoanalyze/java/nullsafe/PropagatesNullable.java, codetoanalyze.java.nullsafe.TestPropagatesNullable$TestOneParameter.test(java.lang.String,java.lang.String):void, 15, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`nullable(...)` is nullable and is not locally checked for null when calling `length()`.], TestPropagatesNullable$TestOneParameter, codetoanalyze.java.nullsafe, nullable_methods:codetoanalyze.java.nullsafe.TestPropagatesNullable$TestOneParameter.nullable at 43
codetoanalyze/java/nullsafe/PropagatesNullable.java, codetoanalyze.java.nullsafe.TestPropagatesNullable$TestOneParameter.test(java.lang.String,java.lang.String):void, 21, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`propagatesNullable(...)` is nullable and is not locally checked for null when calling `length()`: method parameter sNullable.], TestPropagatesNullable$TestOneParameter, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/PropagatesNullable.java, codetoanalyze.java.nullsafe.TestPropagatesNullable$TestOneParameter.test(java.lang.String,java.lang.String):void, 22, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`nullable(...)` is nullable and is not locally checked for null when calling `length()`.], TestPropagatesNullable$TestOneParameter, codetoanalyze.java.nullsafe, nullable_methods:codetoanalyze.java.nullsafe.TestPropagatesNullable$TestOneParameter.nullable at 35
codetoanalyze/java/nullsafe/PropagatesNullable.java, codetoanalyze.java.nullsafe.TestPropagatesNullable$TestReturnValueAnnotationIsAutomaticallyInferred.annotated_dereferencingAfterPassingNullableIsBAD(java.lang.String):void, 1, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`annotatedReturn(...)` is nullable and is not locally checked for null when calling `toString()`: method parameter s.], TestPropagatesNullable$TestReturnValueAnnotationIsAutomaticallyInferred, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/PropagatesNullable.java, codetoanalyze.java.nullsafe.TestPropagatesNullable$TestReturnValueAnnotationIsAutomaticallyInferred.notAnnotated_dereferencingAfterPassingNullableIsBAD(java.lang.String):void, 1, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`notAnnotatedReturn(...)` is nullable and is not locally checked for null when calling `toString()`: method parameter s.], TestPropagatesNullable$TestReturnValueAnnotationIsAutomaticallyInferred, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/PropagatesNullable.java, codetoanalyze.java.nullsafe.TestPropagatesNullable$TestReturnValueAnnotationIsAutomaticallyInferred.notAnnotatingReturnWhenThereAreNoPropagatesNullableIsBAD(java.lang.String):java.lang.String, 0, ERADICATE_RETURN_NOT_NULLABLE, no_bucket, WARNING, [`notAnnotatingReturnWhenThereAreNoPropagatesNullableIsBAD(...)`: return type is declared non-nullable but the method returns `null`: null constant at line 123.], TestPropagatesNullable$TestReturnValueAnnotationIsAutomaticallyInferred, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/PropagatesNullable.java, codetoanalyze.java.nullsafe.TestPropagatesNullable$TestSecondParameter.test(java.lang.String,java.lang.String):void, 2, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`propagatesNullable(...)` is nullable and is not locally checked for null when calling `length()`: method parameter sNullable.], TestPropagatesNullable$TestSecondParameter, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/PropagatesNullable.java, codetoanalyze.java.nullsafe.TestPropagatesNullable$TestSecondParameter.test(java.lang.String,java.lang.String):void, 3, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`nullable(...)` is nullable and is not locally checked for null when calling `length()`.], TestPropagatesNullable$TestSecondParameter, codetoanalyze.java.nullsafe, nullable_methods:codetoanalyze.java.nullsafe.TestPropagatesNullable$TestSecondParameter.nullable at 80
codetoanalyze/java/nullsafe/PropagatesNullable.java, codetoanalyze.java.nullsafe.TestPropagatesNullable$TestSecondParameter.test(java.lang.String,java.lang.String):void, 6, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`propagatesNullable(...)` is nullable and is not locally checked for null when calling `length()`: method parameter sNullable.], TestPropagatesNullable$TestSecondParameter, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/PropagatesNullable.java, codetoanalyze.java.nullsafe.TestPropagatesNullable$TestSecondParameter.test(java.lang.String,java.lang.String):void, 7, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`nullable(...)` is nullable and is not locally checked for null when calling `length()`.], TestPropagatesNullable$TestSecondParameter, codetoanalyze.java.nullsafe, nullable_methods:codetoanalyze.java.nullsafe.TestPropagatesNullable$TestSecondParameter.nullable at 84
codetoanalyze/java/nullsafe/PropagatesNullable.java, codetoanalyze.java.nullsafe.TestPropagatesNullable$TestSecondParameter.test(java.lang.String,java.lang.String):void, 11, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`nullable(...)` is nullable and is not locally checked for null when calling `length()`.], TestPropagatesNullable$TestSecondParameter, codetoanalyze.java.nullsafe, nullable_methods:codetoanalyze.java.nullsafe.TestPropagatesNullable$TestSecondParameter.nullable at 88
codetoanalyze/java/nullsafe/PropagatesNullable.java, codetoanalyze.java.nullsafe.TestPropagatesNullable$TestSecondParameter.test(java.lang.String,java.lang.String):void, 15, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`nullable(...)` is nullable and is not locally checked for null when calling `length()`.], TestPropagatesNullable$TestSecondParameter, codetoanalyze.java.nullsafe, nullable_methods:codetoanalyze.java.nullsafe.TestPropagatesNullable$TestSecondParameter.nullable at 92
codetoanalyze/java/nullsafe/ReturnNotNullable.java, Linters_dummy_method, 23, ERADICATE_META_CLASS_NEEDS_IMPROVEMENT, no_bucket, INFO, [], ReturnNotNullable, codetoanalyze.java.nullsafe, issues: 8, curr_mode: "Default"
codetoanalyze/java/nullsafe/ReturnNotNullable.java, codetoanalyze.java.nullsafe.ReturnNotNullable$ConditionalAssignment.test(boolean):java.lang.Object, 0, ERADICATE_RETURN_NOT_NULLABLE, no_bucket, WARNING, [`test(...)`: return type is declared non-nullable but the method returns a nullable value: field f1 at line 191.], ReturnNotNullable$ConditionalAssignment, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/ReturnNotNullable.java, codetoanalyze.java.nullsafe.ReturnNotNullable.constantToNullableIsOverannotated():java.lang.String, 0, ERADICATE_RETURN_OVER_ANNOTATED, no_bucket, ADVICE, [Method `constantToNullableIsOverannotated()` is annotated with `@Nullable` but never returns null.], ReturnNotNullable, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/ReturnNotNullable.java, codetoanalyze.java.nullsafe.ReturnNotNullable.getResourceNullable(java.lang.Class,java.lang.String):java.net.URL, 0, ERADICATE_RETURN_NOT_NULLABLE, no_bucket, WARNING, [`getResourceNullable(...)`: return type is declared non-nullable but the method returns a nullable value: call to Class.getResource(...) at line 169 (nullable according to nullsafe internal models).], ReturnNotNullable, codetoanalyze.java.nullsafe, nullable_methods:java.lang.Class.getResource at 169
codetoanalyze/java/nullsafe/ReturnNotNullable.java, codetoanalyze.java.nullsafe.ReturnNotNullable.nonNullToNullableIsOverannotated(java.lang.String):java.lang.String, 0, ERADICATE_RETURN_OVER_ANNOTATED, no_bucket, ADVICE, [Method `nonNullToNullableIsOverannotated(...)` is annotated with `@Nullable` but never returns null.], ReturnNotNullable, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/ReturnNotNullable.java, codetoanalyze.java.nullsafe.ReturnNotNullable.notAnnotatedNullableIsOverannotated(java.lang.String):java.lang.String, 0, ERADICATE_RETURN_OVER_ANNOTATED, no_bucket, ADVICE, [Method `notAnnotatedNullableIsOverannotated(...)` is annotated with `@Nullable` but never returns null.], ReturnNotNullable, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/ReturnNotNullable.java, codetoanalyze.java.nullsafe.ReturnNotNullable.nullToNonnullIsBad():java.lang.String, 0, ERADICATE_RETURN_NOT_NULLABLE, no_bucket, WARNING, [`nullToNonnullIsBad()`: return type is declared non-nullable but the method returns `null`: null constant at line 64.], ReturnNotNullable, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/ReturnNotNullable.java, codetoanalyze.java.nullsafe.ReturnNotNullable.nullToNotAnnotatedIsBad():java.lang.String, 0, ERADICATE_RETURN_NOT_NULLABLE, no_bucket, WARNING, [`nullToNotAnnotatedIsBad()`: return type is declared non-nullable but the method returns `null`: null constant at line 39.], ReturnNotNullable, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/ReturnNotNullable.java, codetoanalyze.java.nullsafe.ReturnNotNullable.nullableToNonnullIsBad(java.lang.String):java.lang.String, 0, ERADICATE_RETURN_NOT_NULLABLE, no_bucket, WARNING, [`nullableToNonnullIsBad(...)`: return type is declared non-nullable but the method returns a nullable value: method parameter s.], ReturnNotNullable, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/ReturnNotNullable.java, codetoanalyze.java.nullsafe.ReturnNotNullable.nullableToNotAnnotatedIsBad(java.lang.String):java.lang.String, 0, ERADICATE_RETURN_NOT_NULLABLE, no_bucket, WARNING, [`nullableToNotAnnotatedIsBad(...)`: return type is declared non-nullable but the method returns a nullable value: method parameter s.], ReturnNotNullable, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/ReturnNotNullable.java, codetoanalyze.java.nullsafe.ReturnNotNullable.return_null_in_catch():java.lang.String, 0, ERADICATE_RETURN_NOT_NULLABLE, no_bucket, WARNING, [`return_null_in_catch()`: return type is declared non-nullable but the method returns `null`: null constant at line 152.], ReturnNotNullable, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/ReturnNotNullable.java, codetoanalyze.java.nullsafe.ReturnNotNullable.return_null_in_catch_after_throw():java.lang.String, 0, ERADICATE_RETURN_NOT_NULLABLE, no_bucket, WARNING, [`return_null_in_catch_after_throw()`: return type is declared non-nullable but the method returns `null`: null constant at line 164.], ReturnNotNullable, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/StrictMode.java, Linters_dummy_method, 15, ERADICATE_META_CLASS_NEEDS_IMPROVEMENT, no_bucket, INFO, [], Strict, codetoanalyze.java.nullsafe, issues: 17, curr_mode: "Strict"
codetoanalyze/java/nullsafe/StrictMode.java, Linters_dummy_method, 239, ERADICATE_META_CLASS_IS_NULLSAFE, no_bucket, INFO, [], OtherStrict, codetoanalyze.java.nullsafe, issues: 0, curr_mode: "Strict"
codetoanalyze/java/nullsafe/StrictMode.java, Linters_dummy_method, 260, ERADICATE_META_CLASS_CAN_BE_NULLSAFE, no_bucket, ADVICE, [Congrats! `NonStrict` is free of nullability issues. Mark it `@Nullsafe(Nullsafe.Mode.LOCAL)` to prevent regressions.], NonStrict, codetoanalyze.java.nullsafe, issues: 0, curr_mode: "Default", promote_mode: "LocalTrustAll"
codetoanalyze/java/nullsafe/StrictMode.java, Linters_dummy_method, 285, ERADICATE_META_CLASS_NEEDS_IMPROVEMENT, no_bucket, INFO, [], SomeEnum, codetoanalyze.java.nullsafe, issues: 0, curr_mode: "Default"
codetoanalyze/java/nullsafe/StrictMode.java, codetoanalyze.java.nullsafe.Strict.<init>(), 0, ERADICATE_FIELD_NOT_INITIALIZED, no_bucket, ERROR, [Field `notInitializedIsBAD` is declared non-nullable, so it should be initialized in the constructor], Strict, codetoanalyze.java.nullsafe, field:codetoanalyze.java.nullsafe.Strict.notInitializedIsBAD
codetoanalyze/java/nullsafe/StrictMode.java, codetoanalyze.java.nullsafe.Strict.nonStrictClass_convertingNonnullToNonnullIsBad():java.lang.String, 2, ERADICATE_UNCHECKED_USAGE_IN_NULLSAFE, no_bucket, ERROR, [`NonStrict.getNonnull()`: `@Nullsafe(STRICT)` prohibits using values coming from non-strict classes without a check. Result of this call is used at line 179. Either add a local check for null or assertion, or make `NonStrict` nullsafe strict.], Strict, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/StrictMode.java, codetoanalyze.java.nullsafe.Strict.nonStrictClass_convertingNonnullToNullableIsOK():java.lang.String, 0, ERADICATE_RETURN_OVER_ANNOTATED, no_bucket, ADVICE, [Method `nonStrictClass_convertingNonnullToNullableIsOK()` is annotated with `@Nullable` but never returns null.], Strict, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/StrictMode.java, codetoanalyze.java.nullsafe.Strict.nonStrictClass_convertingNullableToNonnullIsBad():java.lang.String, 0, ERADICATE_RETURN_NOT_NULLABLE, no_bucket, ERROR, [`nonStrictClass_convertingNullableToNonnullIsBad()`: return type is declared non-nullable but the method returns a nullable value: call to getNullable() at line 137.], Strict, codetoanalyze.java.nullsafe, nullable_methods:codetoanalyze.java.nullsafe.NonStrict.getNullable at 137
codetoanalyze/java/nullsafe/StrictMode.java, codetoanalyze.java.nullsafe.Strict.nonStrictClass_dereferenceNonnullFieldAfterCheckIsOK():void, 2, ERADICATE_CONDITION_REDUNDANT, no_bucket, ADVICE, [The condition NonStrict.nonnull might be always true according to the existing annotations.], Strict, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/StrictMode.java, codetoanalyze.java.nullsafe.Strict.nonStrictClass_dereferenceNonnullFieldIsBad():void, 2, ERADICATE_UNCHECKED_USAGE_IN_NULLSAFE, no_bucket, ERROR, [`NonStrict.nonnull`: `@Nullsafe(STRICT)` prohibits using values coming from non-strict classes without a check. This field is used at line 133. Either add a local check for null or assertion, or make `NonStrict` nullsafe strict.], Strict, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/StrictMode.java, codetoanalyze.java.nullsafe.Strict.nonStrictClass_dereferenceNonnullMethodAfterCheckIsOK():void, 2, ERADICATE_CONDITION_REDUNDANT, no_bucket, ADVICE, [The condition lang.String(o) might be always true: `NonStrict.getNonnull()` is not annotated as `@Nullable`.], Strict, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/StrictMode.java, codetoanalyze.java.nullsafe.Strict.nonStrictClass_dereferenceNonnullMethodIsBad():void, 2, ERADICATE_UNCHECKED_USAGE_IN_NULLSAFE, no_bucket, ERROR, [`NonStrict.getNonnull()`: `@Nullsafe(STRICT)` prohibits using values coming from non-strict classes without a check. Result of this call is used at line 115. Either add a local check for null or assertion, or make `NonStrict` nullsafe strict.], Strict, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/StrictMode.java, codetoanalyze.java.nullsafe.Strict.nonStrictClass_dereferenceNonnullStaticMethodIsBad():void, 2, ERADICATE_UNCHECKED_USAGE_IN_NULLSAFE, no_bucket, ERROR, [`NonStrict.staticNonnull()`: `@Nullsafe(STRICT)` prohibits using values coming from non-strict classes without a check. Result of this call is used at line 124. Either add a local check for null or assertion, or make `NonStrict` nullsafe strict.], Strict, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/StrictMode.java, codetoanalyze.java.nullsafe.Strict.nonStrictClass_dereferenceNullableFieldIsBad():void, 1, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, ERROR, [`__new(...).nullable` is nullable and is not locally checked for null when calling `toString()`.], Strict, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/StrictMode.java, codetoanalyze.java.nullsafe.Strict.nonStrictClass_dereferenceNullableMethodIsBad():void, 1, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, ERROR, [`getNullable(...)` is nullable and is not locally checked for null when calling `toString()`: call to getNullable() at line 110.], Strict, codetoanalyze.java.nullsafe, nullable_methods:codetoanalyze.java.nullsafe.NonStrict.getNullable at 110
codetoanalyze/java/nullsafe/StrictMode.java, codetoanalyze.java.nullsafe.Strict.nonStrictClass_dereferenceNullableStaticMethodIsBad():void, 1, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, ERROR, [`staticNullable()` is nullable and is not locally checked for null when calling `toString()`.], Strict, codetoanalyze.java.nullsafe, nullable_methods:codetoanalyze.java.nullsafe.NonStrict.staticNullable at 119
codetoanalyze/java/nullsafe/StrictMode.java, codetoanalyze.java.nullsafe.Strict.sameClass_convertingNullableToNonnullIsBad():java.lang.String, 0, ERADICATE_RETURN_NOT_NULLABLE, no_bucket, ERROR, [`sameClass_convertingNullableToNonnullIsBad()`: return type is declared non-nullable but the method returns a nullable value: call to getNullable() at line 65.], Strict, codetoanalyze.java.nullsafe, nullable_methods:codetoanalyze.java.nullsafe.Strict.getNullable at 65
codetoanalyze/java/nullsafe/StrictMode.java, codetoanalyze.java.nullsafe.Strict.sameClass_dereferenceNullableFieldIsBad():void, 1, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, ERROR, [`Strict.nullable` is nullable and is not locally checked for null when calling `toString()`.], Strict, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/StrictMode.java, codetoanalyze.java.nullsafe.Strict.sameClass_dereferenceNullableMethodIsBad():void, 1, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, ERROR, [`getNullable()` is nullable and is not locally checked for null when calling `toString()`.], Strict, codetoanalyze.java.nullsafe, nullable_methods:codetoanalyze.java.nullsafe.Strict.getNullable at 41
codetoanalyze/java/nullsafe/StrictMode.java, codetoanalyze.java.nullsafe.Strict.sameClass_dereferenceNullableStaticMethodIsBad():void, 1, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, ERROR, [`staticNullable()` is nullable and is not locally checked for null when calling `toString()`.], Strict, codetoanalyze.java.nullsafe, nullable_methods:codetoanalyze.java.nullsafe.Strict.staticNullable at 49
codetoanalyze/java/nullsafe/StrictMode.java, codetoanalyze.java.nullsafe.Strict.strictClass_convertingNullableToNonnullIsBad():java.lang.String, 0, ERADICATE_RETURN_NOT_NULLABLE, no_bucket, ERROR, [`strictClass_convertingNullableToNonnullIsBad()`: return type is declared non-nullable but the method returns a nullable value: call to getNullable() at line 99.], Strict, codetoanalyze.java.nullsafe, nullable_methods:codetoanalyze.java.nullsafe.OtherStrict.getNullable at 99
codetoanalyze/java/nullsafe/StrictMode.java, codetoanalyze.java.nullsafe.Strict.strictClass_dereferenceNullableFieldIsBad():void, 1, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, ERROR, [`__new(...).nullable` is nullable and is not locally checked for null when calling `toString()`.], Strict, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/StrictMode.java, codetoanalyze.java.nullsafe.Strict.strictClass_dereferenceNullableMethodIsBad():void, 1, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, ERROR, [`getNullable(...)` is nullable and is not locally checked for null when calling `toString()`: call to getNullable() at line 75.], Strict, codetoanalyze.java.nullsafe, nullable_methods:codetoanalyze.java.nullsafe.OtherStrict.getNullable at 75
codetoanalyze/java/nullsafe/StrictMode.java, codetoanalyze.java.nullsafe.Strict.strictClass_dereferenceNullableStaticMethodIsBad():void, 1, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, ERROR, [`staticNullable()` is nullable and is not locally checked for null when calling `toString()`.], Strict, codetoanalyze.java.nullsafe, nullable_methods:codetoanalyze.java.nullsafe.OtherStrict.staticNullable at 83
codetoanalyze/java/nullsafe/StrictModeForThirdParty.java, Linters_dummy_method, 20, ERADICATE_META_CLASS_NEEDS_IMPROVEMENT, no_bucket, INFO, [], StrictModeForThirdParty, codetoanalyze.java.nullsafe, issues: 10, curr_mode: "Strict"
codetoanalyze/java/nullsafe/StrictModeForThirdParty.java, codetoanalyze.java.nullsafe.StrictModeForThirdParty.arrayRepresentation(java.lang.String,java.lang.String[]):java.lang.String, 1, ERADICATE_UNVETTED_THIRD_PARTY_IN_NULLSAFE, no_bucket, ERROR, [`ThirdPartyTestClass.array(...)`: `@Nullsafe` mode prohibits using values coming from not vetted third party methods without a check. Result of this call is used at line 103. Either add a local check for null or assertion, or add the correct signature to nullsafe/third-party-signatures/some.test.pckg.sig.], StrictModeForThirdParty, codetoanalyze.java.nullsafe, unvetted_3rd_party:[some.test.pckg.ThirdPartyTestClass#array(java.lang.String, java.lang.String[])]
codetoanalyze/java/nullsafe/StrictModeForThirdParty.java, codetoanalyze.java.nullsafe.StrictModeForThirdParty.dereferenceFieldIsBAD():void, 1, ERADICATE_UNVETTED_THIRD_PARTY_IN_NULLSAFE, no_bucket, ERROR, [`ThirdPartyTestClass.nonNullableField`: `@Nullsafe` mode prohibits using values coming from not vetted third party fields without a check. This field is used at line 50. Either add a local check for null or assertion, or access `nonNullableField` via a nullsafe strict getter.], StrictModeForThirdParty, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/StrictModeForThirdParty.java, codetoanalyze.java.nullsafe.StrictModeForThirdParty.dereferenceSpecifiedAsNullableIsBAD():void, 1, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, ERROR, [`StrictModeForThirdParty.obj.returnSpecifiedAsNullable()` is nullable and is not locally checked for null when calling `toString()`: call to ThirdPartyTestClass.returnSpecifiedAsNullable() at line 46 (declared nullable in nullsafe/third-party-signatures/some.test.pckg.sig at line 2).], StrictModeForThirdParty, codetoanalyze.java.nullsafe, nullable_methods:some.test.pckg.ThirdPartyTestClass.returnSpecifiedAsNullable at 46
codetoanalyze/java/nullsafe/StrictModeForThirdParty.java, codetoanalyze.java.nullsafe.StrictModeForThirdParty.dereferenceUnspecifiedIsBAD():void, 1, ERADICATE_UNVETTED_THIRD_PARTY_IN_NULLSAFE, no_bucket, ERROR, [`ThirdPartyTestClass.returnUnspecified()`: `@Nullsafe` mode prohibits using values coming from not vetted third party methods without a check. Result of this call is used at line 42. Either add a local check for null or assertion, or add the correct signature to nullsafe/third-party-signatures/some.test.pckg.sig.], StrictModeForThirdParty, codetoanalyze.java.nullsafe, unvetted_3rd_party:[some.test.pckg.ThirdPartyTestClass#returnUnspecified()]
codetoanalyze/java/nullsafe/StrictModeForThirdParty.java, codetoanalyze.java.nullsafe.StrictModeForThirdParty.genericExtendsStringRepresentation(java.lang.String,java.util.List):java.lang.String, 1, ERADICATE_UNVETTED_THIRD_PARTY_IN_NULLSAFE, no_bucket, ERROR, [`ThirdPartyTestClass.genericString(...)`: `@Nullsafe` mode prohibits using values coming from not vetted third party methods without a check. Result of this call is used at line 97. Either add a local check for null or assertion, or add the correct signature to nullsafe/third-party-signatures/some.test.pckg.sig.], StrictModeForThirdParty, codetoanalyze.java.nullsafe, unvetted_3rd_party:[some.test.pckg.ThirdPartyTestClass#genericString(java.lang.String, java.util.List)]
codetoanalyze/java/nullsafe/StrictModeForThirdParty.java, codetoanalyze.java.nullsafe.StrictModeForThirdParty.genericObjectRepresentation(java.lang.String,java.util.List):java.lang.String, 1, ERADICATE_UNVETTED_THIRD_PARTY_IN_NULLSAFE, no_bucket, ERROR, [`ThirdPartyTestClass.generic(...)`: `@Nullsafe` mode prohibits using values coming from not vetted third party methods without a check. Result of this call is used at line 90. Either add a local check for null or assertion, or add the correct signature to nullsafe/third-party-signatures/some.test.pckg.sig.], StrictModeForThirdParty, codetoanalyze.java.nullsafe, unvetted_3rd_party:[some.test.pckg.ThirdPartyTestClass#generic(java.lang.Object, java.util.List)]
codetoanalyze/java/nullsafe/StrictModeForThirdParty.java, codetoanalyze.java.nullsafe.StrictModeForThirdParty.passingNullableParamToUnspecifiedIsBAD():void, 1, ERADICATE_PARAMETER_NOT_NULLABLE, no_bucket, ERROR, [Third-party `ThirdPartyTestClass.paramUnspecified(...)` is missing a signature that would allow passing a nullable to param #1(`param`). Actual argument `getNullable()` is nullable. Consider adding the correct signature of `ThirdPartyTestClass.paramUnspecified(...)` to nullsafe/third-party-signatures/some.test.pckg.sig.], StrictModeForThirdParty, codetoanalyze.java.nullsafe, unvetted_3rd_party:[some.test.pckg.ThirdPartyTestClass#paramUnspecified(java.lang.String)], nullable_methods:codetoanalyze.java.nullsafe.StrictModeForThirdParty.getNullable at 63
codetoanalyze/java/nullsafe/StrictModeForThirdParty.java, codetoanalyze.java.nullsafe.StrictModeForThirdParty.passingNullableToParamSpecifiedAsNonnullIsBAD():void, 1, ERADICATE_PARAMETER_NOT_NULLABLE, no_bucket, ERROR, [`ThirdPartyTestClass.secondParamSpecifiedAsNonnull(...)`: parameter #2(`specifiedAsNonnull`) is declared non-nullable (see nullsafe/third-party-signatures/some.test.pckg.sig at line 3) but the argument `getNullable()` is nullable.], StrictModeForThirdParty, codetoanalyze.java.nullsafe, nullable_methods:codetoanalyze.java.nullsafe.StrictModeForThirdParty.getNullable at 71
codetoanalyze/java/nullsafe/StrictModeForThirdParty.java, codetoanalyze.java.nullsafe.StrictModeForThirdParty.varargGenericRepresentation(java.lang.String):java.lang.String, 1, ERADICATE_UNVETTED_THIRD_PARTY_IN_NULLSAFE, no_bucket, ERROR, [`ThirdPartyTestClass.varargGeneric(...)`: `@Nullsafe` mode prohibits using values coming from not vetted third party methods without a check. Result of this call is used at line 116. Either add a local check for null or assertion, or add the correct signature to nullsafe/third-party-signatures/some.test.pckg.sig.], StrictModeForThirdParty, codetoanalyze.java.nullsafe, unvetted_3rd_party:[some.test.pckg.ThirdPartyTestClass#varargGeneric(java.lang.Object, java.lang.Object[])]
codetoanalyze/java/nullsafe/StrictModeForThirdParty.java, codetoanalyze.java.nullsafe.StrictModeForThirdParty.varargRepresentation(java.lang.String):java.lang.String, 1, ERADICATE_UNVETTED_THIRD_PARTY_IN_NULLSAFE, no_bucket, ERROR, [`ThirdPartyTestClass.vararg(...)`: `@Nullsafe` mode prohibits using values coming from not vetted third party methods without a check. Result of this call is used at line 109. Either add a local check for null or assertion, or add the correct signature to nullsafe/third-party-signatures/some.test.pckg.sig.], StrictModeForThirdParty, codetoanalyze.java.nullsafe, unvetted_3rd_party:[some.test.pckg.ThirdPartyTestClass#vararg(java.lang.String, java.lang.String[])]
codetoanalyze/java/nullsafe/SwitchCase.java, Linters_dummy_method, 12, ERADICATE_META_CLASS_NEEDS_IMPROVEMENT, no_bucket, INFO, [], SwitchCase, codetoanalyze.java.nullsafe, issues: 2, curr_mode: "Default"
codetoanalyze/java/nullsafe/SwitchCase.java, Linters_dummy_method, 63, ERADICATE_META_CLASS_NEEDS_IMPROVEMENT, no_bucket, INFO, [], Color, codetoanalyze.java.nullsafe, issues: 0, curr_mode: "Default"
codetoanalyze/java/nullsafe/SwitchCase.java, codetoanalyze.java.nullsafe.SwitchCase.getNullableColor():codetoanalyze.java.nullsafe.Color, 0, ERADICATE_RETURN_OVER_ANNOTATED, no_bucket, ADVICE, [Method `getNullableColor()` is annotated with `@Nullable` but never returns null.], SwitchCase, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/SwitchCase.java, codetoanalyze.java.nullsafe.SwitchCase.switchOnNullIsBad():java.lang.String, 2, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [NullPointerException will be thrown at this line! `color` is `null` and is dereferenced via calling `ordinal()`: null constant at line 14.], SwitchCase, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/SwitchCase.java, codetoanalyze.java.nullsafe.SwitchCase.switchOnNullableIsBad():java.lang.String, 2, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`color` is nullable and is not locally checked for null when calling `ordinal()`: call to getNullableColor() at line 28.], SwitchCase, codetoanalyze.java.nullsafe, nullable_methods:codetoanalyze.java.nullsafe.SwitchCase.getNullableColor at 28
codetoanalyze/java/nullsafe/SyntheticErrorSuppressions.java, Linters_dummy_method, 13, ERADICATE_META_CLASS_NEEDS_IMPROVEMENT, no_bucket, INFO, [], SyntheticErrorSuppressions, codetoanalyze.java.nullsafe, issues: 3, curr_mode: "Default"
codetoanalyze/java/nullsafe/SyntheticErrorSuppressions.java, codetoanalyze.java.nullsafe.SyntheticErrorSuppressions$ClassWithSyntheticCode.dereferencingNullableSyntheticMethodCall_OK_FP():java.lang.String, 1, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`$ul_iAmNullableAutogen(...)` is nullable and is not locally checked for null when calling `toString()`: call to $ul_iAmNullableAutogen() at line 68.], SyntheticErrorSuppressions$ClassWithSyntheticCode, codetoanalyze.java.nullsafe, nullable_methods:codetoanalyze.java.nullsafe.SyntheticErrorSuppressions$ClassWithSyntheticCode.$ul_iAmNullableAutogen at 68
codetoanalyze/java/nullsafe/SyntheticErrorSuppressions.java, codetoanalyze.java.nullsafe.SyntheticErrorSuppressions$ClassWithSyntheticCode.dereferencingSyntheticNullableField_OK_FP():java.lang.String, 1, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`SyntheticErrorSuppressions$ClassWithSyntheticCode.$ul_fieldNullable` is nullable and is not locally checked for null when calling `toString()`.], SyntheticErrorSuppressions$ClassWithSyntheticCode, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/SyntheticErrorSuppressions.java, codetoanalyze.java.nullsafe.SyntheticErrorSuppressions$ClassWithSyntheticCode.passingSyntheticParamToAnyMethod_OK_FP():void, 1, ERADICATE_PARAMETER_NOT_NULLABLE, no_bucket, WARNING, [`SyntheticErrorSuppressions$Fragment.setContext(...)`: parameter #1(`context`) is declared non-nullable but the argument `SyntheticErrorSuppressions$ClassWithSyntheticCode.$ul_fieldNullable` is nullable.], SyntheticErrorSuppressions$ClassWithSyntheticCode, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/TrueFalseOnNull.java, Linters_dummy_method, 17, ERADICATE_META_CLASS_NEEDS_IMPROVEMENT, no_bucket, INFO, [], TrueFalseOnNull, codetoanalyze.java.nullsafe, issues: 17, curr_mode: "Default"
codetoanalyze/java/nullsafe/TrueFalseOnNull.java, codetoanalyze.java.nullsafe.TrueFalseOnNull$EarlyReturn.testEarlyReturn(java.lang.CharSequence,java.lang.CharSequence):void, 6, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`s2` is nullable and is not locally checked for null when calling `toString()`.], TrueFalseOnNull$EarlyReturn, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/TrueFalseOnNull.java, codetoanalyze.java.nullsafe.TrueFalseOnNull$TestNonStaticOneParam.falseOnNullNegativeBranchIsBAD(java.lang.String):void, 2, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`s` is nullable and is not locally checked for null when calling `toString()`.], TrueFalseOnNull$TestNonStaticOneParam, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/TrueFalseOnNull.java, codetoanalyze.java.nullsafe.TrueFalseOnNull$TestNonStaticOneParam.notAnnotatedNegativeBranchIsBAD(java.lang.String):void, 2, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`s` is nullable and is not locally checked for null when calling `toString()`.], TrueFalseOnNull$TestNonStaticOneParam, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/TrueFalseOnNull.java, codetoanalyze.java.nullsafe.TrueFalseOnNull$TestNonStaticOneParam.notAnnotatedPositiveBranchIsBAD(java.lang.String):void, 2, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`s` is nullable and is not locally checked for null when calling `toString()`.], TrueFalseOnNull$TestNonStaticOneParam, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/TrueFalseOnNull.java, codetoanalyze.java.nullsafe.TrueFalseOnNull$TestNonStaticOneParam.trueOnNullPositiveBranchIsBAD(java.lang.String):void, 2, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`s` is nullable and is not locally checked for null when calling `toString()`.], TrueFalseOnNull$TestNonStaticOneParam, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/TrueFalseOnNull.java, codetoanalyze.java.nullsafe.TrueFalseOnNull$TestNonStaticSeveralParams.falseOnNullNegativeBranchIsBAD(java.lang.String,java.lang.String):void, 2, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`s1` is nullable and is not locally checked for null when calling `toString()`.], TrueFalseOnNull$TestNonStaticSeveralParams, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/TrueFalseOnNull.java, codetoanalyze.java.nullsafe.TrueFalseOnNull$TestNonStaticSeveralParams.falseOnNullNegativeBranchIsBAD(java.lang.String,java.lang.String):void, 3, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`s2` is nullable and is not locally checked for null when calling `toString()`.], TrueFalseOnNull$TestNonStaticSeveralParams, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/TrueFalseOnNull.java, codetoanalyze.java.nullsafe.TrueFalseOnNull$TestNonStaticSeveralParams.notAnnotatedNegativeBranchIsBAD(java.lang.String,java.lang.String):void, 2, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`s1` is nullable and is not locally checked for null when calling `toString()`.], TrueFalseOnNull$TestNonStaticSeveralParams, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/TrueFalseOnNull.java, codetoanalyze.java.nullsafe.TrueFalseOnNull$TestNonStaticSeveralParams.notAnnotatedNegativeBranchIsBAD(java.lang.String,java.lang.String):void, 3, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`s2` is nullable and is not locally checked for null when calling `toString()`.], TrueFalseOnNull$TestNonStaticSeveralParams, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/TrueFalseOnNull.java, codetoanalyze.java.nullsafe.TrueFalseOnNull$TestNonStaticSeveralParams.notAnnotatedPositiveBranchIsBAD(java.lang.String,java.lang.String):void, 2, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`s1` is nullable and is not locally checked for null when calling `toString()`.], TrueFalseOnNull$TestNonStaticSeveralParams, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/TrueFalseOnNull.java, codetoanalyze.java.nullsafe.TrueFalseOnNull$TestNonStaticSeveralParams.notAnnotatedPositiveBranchIsBAD(java.lang.String,java.lang.String):void, 3, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`s2` is nullable and is not locally checked for null when calling `toString()`.], TrueFalseOnNull$TestNonStaticSeveralParams, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/TrueFalseOnNull.java, codetoanalyze.java.nullsafe.TrueFalseOnNull$TestNonStaticSeveralParams.trueOnNullPositiveBranchIsBAD(java.lang.String,java.lang.String):void, 2, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`s1` is nullable and is not locally checked for null when calling `toString()`.], TrueFalseOnNull$TestNonStaticSeveralParams, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/TrueFalseOnNull.java, codetoanalyze.java.nullsafe.TrueFalseOnNull$TestNonStaticSeveralParams.trueOnNullPositiveBranchIsBAD(java.lang.String,java.lang.String):void, 3, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`s2` is nullable and is not locally checked for null when calling `toString()`.], TrueFalseOnNull$TestNonStaticSeveralParams, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/TrueFalseOnNull.java, codetoanalyze.java.nullsafe.TrueFalseOnNull$TestStaticOneParam.falseOnNullNegativeBranchIsBAD(java.lang.String):void, 2, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`s` is nullable and is not locally checked for null when calling `toString()`.], TrueFalseOnNull$TestStaticOneParam, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/TrueFalseOnNull.java, codetoanalyze.java.nullsafe.TrueFalseOnNull$TestStaticOneParam.notAnnotatedNegativeBranchIsBAD(java.lang.String):void, 2, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`s` is nullable and is not locally checked for null when calling `toString()`.], TrueFalseOnNull$TestStaticOneParam, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/TrueFalseOnNull.java, codetoanalyze.java.nullsafe.TrueFalseOnNull$TestStaticOneParam.notAnnotatedPositiveBranchIsBAD(java.lang.String):void, 2, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`s` is nullable and is not locally checked for null when calling `toString()`.], TrueFalseOnNull$TestStaticOneParam, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/TrueFalseOnNull.java, codetoanalyze.java.nullsafe.TrueFalseOnNull$TestStaticOneParam.trueOnNullPositiveBranchIsBAD(java.lang.String):void, 2, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`s` is nullable and is not locally checked for null when calling `toString()`.], TrueFalseOnNull$TestStaticOneParam, codetoanalyze.java.nullsafe
