codetoanalyze/java/nullsafe/AlternativeRecommendations.java, Linters_dummy_method, 17, ERADICATE_META_CLASS_NEEDS_IMPROVEMENT, no_bucket, INFO, [], AlternativeRecommendations, codetoanalyze.java.nullsafe, issues: 5, curr_mode: "Default"
codetoanalyze/java/nullsafe/AlternativeRecommendations.java, codetoanalyze.java.nullsafe.AlternativeRecommendations.assigningField_ShouldSuggestAlternative(android.view.View):void, 1, ERADICATE_FIELD_NOT_NULLABLE, no_bucket, WARNING, [`field` is declared non-nullable but is assigned a nullable: call to View.findViewById(...) at line 34 (nullable according to nullsafe internal models). If you don't expect null, use `androidx.core.view.ViewCompat.requireViewById()` instead.]
codetoanalyze/java/nullsafe/AlternativeRecommendations.java, codetoanalyze.java.nullsafe.AlternativeRecommendations.dereference_ShouldSuggestAlternative(android.view.View):void, 1, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`view.findViewById(...)` is nullable and is not locally checked for null when calling `setId(...)`: call to View.findViewById(...) at line 22 (nullable according to nullsafe internal models). If this is intentional, use `androidx.core.view.ViewCompat.requireViewById()` instead.]
codetoanalyze/java/nullsafe/AlternativeRecommendations.java, codetoanalyze.java.nullsafe.AlternativeRecommendations.passingParam_ShouldSuggestAlternative(android.view.View):void, 1, ERADICATE_PARAMETER_NOT_NULLABLE, no_bucket, WARNING, [`AlternativeRecommendations.acceptsNonnullView(...)`: parameter #1(`view`) is declared non-nullable but the argument `view.findViewById(...)` is nullable: call to View.findViewById(...) at line 26 (nullable according to nullsafe internal models). If you don't expect null, use `androidx.core.view.ViewCompat.requireViewById()` instead.]
codetoanalyze/java/nullsafe/AlternativeRecommendations.java, codetoanalyze.java.nullsafe.AlternativeRecommendations.returnValue_ShouldSuggestAlternative(android.view.View):android.view.View, 0, ERADICATE_RETURN_NOT_NULLABLE, no_bucket, WARNING, [`returnValue_ShouldSuggestAlternative(...)`: return type is declared non-nullable but the method returns a nullable value: call to View.findViewById(...) at line 30 (nullable according to nullsafe internal models). If you don't expect null, use `androidx.core.view.ViewCompat.requireViewById()` instead.]
codetoanalyze/java/nullsafe/ButterKnife.java, Linters_dummy_method, 15, ERADICATE_META_CLASS_NEEDS_IMPROVEMENT, no_bucket, INFO, [], ButterKnife, codetoanalyze.java.nullsafe, issues: 5, curr_mode: "Default"
codetoanalyze/java/nullsafe/ButterKnife.java, codetoanalyze.java.nullsafe.ButterKnife$TestNotInitialized.<init>(codetoanalyze.java.nullsafe.ButterKnife), 0, ERADICATE_FIELD_NOT_INITIALIZED, no_bucket, WARNING, [Field `notInitializedNormalIsBAD` is declared non-nullable, so it should be initialized in the constructor or in an `@Initializer` method]
codetoanalyze/java/nullsafe/ButterKnife.java, codetoanalyze.java.nullsafe.ButterKnife.<init>(), 0, ERADICATE_FIELD_OVER_ANNOTATED, no_bucket, ADVICE, [Field `ButterKnife.nullable` is always initialized in the constructor but is declared `@Nullable`]
codetoanalyze/java/nullsafe/ButterKnife.java, codetoanalyze.java.nullsafe.ButterKnife.assignNullToNormalIsBAD():void, 1, ERADICATE_FIELD_NOT_NULLABLE, no_bucket, WARNING, [`normal` is declared non-nullable but is assigned `null`: null constant at line 76.]
codetoanalyze/java/nullsafe/ButterKnife.java, codetoanalyze.java.nullsafe.ButterKnife.convertingToNotNullableForNullableIsBAD():java.lang.String, 0, ERADICATE_RETURN_NOT_NULLABLE, no_bucket, WARNING, [`convertingToNotNullableForNullableIsBAD()`: return type is declared non-nullable but the method returns a nullable value: field nullable at line 47.]
codetoanalyze/java/nullsafe/ButterKnife.java, codetoanalyze.java.nullsafe.ButterKnife.dereferencingNullableIsBAD():void, 1, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`ButterKnife.nullable` is nullable and is not locally checked for null when calling `length()`.]
codetoanalyze/java/nullsafe/ButterKnife.java, codetoanalyze.java.nullsafe.ButterKnife.passingToNullableForNullableIsBAD():void, 1, ERADICATE_PARAMETER_NOT_NULLABLE, no_bucket, WARNING, [`ButterKnife.f(...)`: parameter #1(`nonNullable`) is declared non-nullable but the argument `ButterKnife.nullable` is nullable.]
codetoanalyze/java/nullsafe/CapturedParam.java, Linters_dummy_method, 13, ERADICATE_META_CLASS_NEEDS_IMPROVEMENT, no_bucket, INFO, [], CapturedParam, codetoanalyze.java.nullsafe, issues: 1, curr_mode: "Default"
codetoanalyze/java/nullsafe/CapturedParam.java, codetoanalyze.java.nullsafe.CapturedParam.dereferencingNullableIsBAD(java.lang.Object):void, 1, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`parameter` is nullable and is not locally checked for null when calling `toString()`.]
codetoanalyze/java/nullsafe/ConditionRedundant.java, Linters_dummy_method, 13, ERADICATE_META_CLASS_CAN_BE_NULLSAFE, no_bucket, ADVICE, [Congrats! `ConditionRedundant` is free of nullability issues. Mark it `@Nullsafe(Nullsafe.Mode.LOCAL)` to prevent regressions.], ConditionRedundant, codetoanalyze.java.nullsafe, issues: 0, curr_mode: "Default", promote_mode: "Strict"
codetoanalyze/java/nullsafe/ConditionRedundant.java, codetoanalyze.java.nullsafe.ConditionRedundant.<init>(), 0, ERADICATE_FIELD_OVER_ANNOTATED, no_bucket, ADVICE, [Field `ConditionRedundant.fieldNullable` is always initialized in the constructor but is declared `@Nullable`]
codetoanalyze/java/nullsafe/ConditionRedundant.java, codetoanalyze.java.nullsafe.ConditionRedundant.FP_ternary_NonnullInOneBranch_SecondBranch_ShouldBeOK(java.lang.String,java.lang.String,int):void, 2, ERADICATE_CONDITION_REDUNDANT, no_bucket, ADVICE, [The condition s2 might be always false according to the existing annotations.]
codetoanalyze/java/nullsafe/ConditionRedundant.java, codetoanalyze.java.nullsafe.ConditionRedundant.assertNotNull_NonnullIsBAD(java.lang.String):void, 1, ERADICATE_CONDITION_REDUNDANT, no_bucket, ADVICE, [The condition (s!=null) might be always true according to the existing annotations.]
codetoanalyze/java/nullsafe/ConditionRedundant.java, codetoanalyze.java.nullsafe.ConditionRedundant.checkArgument_NonnullIsBAd(java.lang.String):void, 1, ERADICATE_CONDITION_REDUNDANT, no_bucket, ADVICE, [The condition s might be always true according to the existing annotations.]
codetoanalyze/java/nullsafe/ConditionRedundant.java, codetoanalyze.java.nullsafe.ConditionRedundant.checkNotNull_NonnullIsBAD(java.lang.String):void, 1, ERADICATE_CONDITION_REDUNDANT, no_bucket, ADVICE, [The condition (s!=null) might be always true according to the existing annotations.]
codetoanalyze/java/nullsafe/ConditionRedundant.java, codetoanalyze.java.nullsafe.ConditionRedundant.compareEQ_NonnullIsBAD(java.lang.String):void, 1, ERADICATE_CONDITION_REDUNDANT, no_bucket, ADVICE, [The condition s might be always false according to the existing annotations.]
codetoanalyze/java/nullsafe/ConditionRedundant.java, codetoanalyze.java.nullsafe.ConditionRedundant.compareNEQ_NonnullIsBAD(java.lang.String):void, 1, ERADICATE_CONDITION_REDUNDANT, no_bucket, ADVICE, [The condition s might be always true according to the existing annotations.]
codetoanalyze/java/nullsafe/ConditionRedundant.java, codetoanalyze.java.nullsafe.ConditionRedundant.comparingNonnullFieldIsBAD():void, 1, ERADICATE_CONDITION_REDUNDANT, no_bucket, ADVICE, [The condition ConditionRedundant.fieldNonnull might be always true according to the existing annotations.]
codetoanalyze/java/nullsafe/ConditionRedundant.java, codetoanalyze.java.nullsafe.ConditionRedundant.comparingNonnullFunctionIsBAD():void, 1, ERADICATE_CONDITION_REDUNDANT, no_bucket, ADVICE, [The condition lang.String(this)V might be always true: `ConditionRedundant.getNonnull()` is not annotated as `@Nullable`.]
codetoanalyze/java/nullsafe/ConditionRedundant.java, codetoanalyze.java.nullsafe.ConditionRedundant.comparingNullableFieldThatIsAlreadyCheckedIsBAD():void, 2, ERADICATE_CONDITION_REDUNDANT, no_bucket, ADVICE, [The condition ConditionRedundant.fieldNullable might be always true according to the existing annotations.]
codetoanalyze/java/nullsafe/ConditionRedundant.java, codetoanalyze.java.nullsafe.ConditionRedundant.comparingWithNullIfAssignedBeforeThrowableIsBAD():void, 6, ERADICATE_CONDITION_REDUNDANT, no_bucket, ADVICE, [The condition s might be always true according to the existing annotations.]
codetoanalyze/java/nullsafe/ConditionRedundant.java, codetoanalyze.java.nullsafe.ConditionRedundant.conjunctionBothNonnullIsBAD(java.lang.String,java.lang.String):void, 1, ERADICATE_CONDITION_REDUNDANT, no_bucket, ADVICE, [The condition s2 might be always true according to the existing annotations.]
codetoanalyze/java/nullsafe/ConditionRedundant.java, codetoanalyze.java.nullsafe.ConditionRedundant.conjunctionBothNonnullIsBAD(java.lang.String,java.lang.String):void, 1, ERADICATE_CONDITION_REDUNDANT, no_bucket, ADVICE, [The condition s1 might be always true according to the existing annotations.]
codetoanalyze/java/nullsafe/ConditionRedundant.java, codetoanalyze.java.nullsafe.ConditionRedundant.conjunctionOneNonnullIsBAD(java.lang.String,java.lang.String):void, 1, ERADICATE_CONDITION_REDUNDANT, no_bucket, ADVICE, [The condition s2 might be always true according to the existing annotations.]
codetoanalyze/java/nullsafe/ConditionRedundant.java, codetoanalyze.java.nullsafe.ConditionRedundant.disjunctionBothNonnullIsBAD(java.lang.String,java.lang.String):void, 1, ERADICATE_CONDITION_REDUNDANT, no_bucket, ADVICE, [The condition s1 might be always false according to the existing annotations.]
codetoanalyze/java/nullsafe/ConditionRedundant.java, codetoanalyze.java.nullsafe.ConditionRedundant.disjunctionBothNonnullIsBAD(java.lang.String,java.lang.String):void, 1, ERADICATE_CONDITION_REDUNDANT, no_bucket, ADVICE, [The condition s2 might be always true according to the existing annotations.]
codetoanalyze/java/nullsafe/ConditionRedundant.java, codetoanalyze.java.nullsafe.ConditionRedundant.disjunctionOneNonnullIsBAD(java.lang.String,java.lang.String):void, 1, ERADICATE_CONDITION_REDUNDANT, no_bucket, ADVICE, [The condition s2 might be always true according to the existing annotations.]
codetoanalyze/java/nullsafe/ConditionRedundant.java, codetoanalyze.java.nullsafe.ConditionRedundant.irrelevantConditionWithNonnullIsBAD(java.lang.String,java.lang.String,int):void, 1, ERADICATE_CONDITION_REDUNDANT, no_bucket, ADVICE, [The condition s1 might be always true according to the existing annotations.]
codetoanalyze/java/nullsafe/ConditionRedundant.java, codetoanalyze.java.nullsafe.ConditionRedundant.outsideOfIfCompareNonnullIsBAD(java.lang.String):void, 1, ERADICATE_CONDITION_REDUNDANT, no_bucket, ADVICE, [The condition s might be always true according to the existing annotations.]
codetoanalyze/java/nullsafe/ConditionRedundant.java, codetoanalyze.java.nullsafe.ConditionRedundant.ternary_NonnullInBothBranchesIsBAD(java.lang.String,java.lang.String,int):void, 2, ERADICATE_CONDITION_REDUNDANT, no_bucket, ADVICE, [The condition s2 might be always false according to the existing annotations.]
codetoanalyze/java/nullsafe/ConditionRedundant.java, codetoanalyze.java.nullsafe.ConditionRedundant.testFlowSensitivity(java.lang.String,java.lang.String):void, 2, ERADICATE_CONDITION_REDUNDANT, no_bucket, ADVICE, [The condition nullable1 might be always true according to the existing annotations.]
codetoanalyze/java/nullsafe/ConditionRedundant.java, codetoanalyze.java.nullsafe.ConditionRedundant.testFlowSensitivity(java.lang.String,java.lang.String):void, 4, ERADICATE_CONDITION_REDUNDANT, no_bucket, ADVICE, [The condition nullable1 might be always true according to the existing annotations.]
codetoanalyze/java/nullsafe/FieldNotInitialized.java, Linters_dummy_method, 25, ERADICATE_META_CLASS_NEEDS_IMPROVEMENT, no_bucket, INFO, [], FieldNotInitialized, codetoanalyze.java.nullsafe, issues: 31, curr_mode: "Default"
codetoanalyze/java/nullsafe/FieldNotInitialized.java, Linters_dummy_method, 233, ERADICATE_META_CLASS_NEEDS_IMPROVEMENT, no_bucket, INFO, [], TestKnownInitializers, codetoanalyze.java.nullsafe, issues: 2, curr_mode: "Default"
codetoanalyze/java/nullsafe/FieldNotInitialized.java, Linters_dummy_method, 280, ERADICATE_META_CLASS_NEEDS_IMPROVEMENT, no_bucket, INFO, [], TestInitializerAnnotation, codetoanalyze.java.nullsafe, issues: 3, curr_mode: "Default"
codetoanalyze/java/nullsafe/FieldNotInitialized.java, codetoanalyze.java.nullsafe.FieldNotInitialized$InitCircular.<init>(codetoanalyze.java.nullsafe.FieldNotInitialized), 0, ERADICATE_FIELD_NOT_INITIALIZED, no_bucket, WARNING, [Field `stillBad` is declared non-nullable, so it should be initialized in the constructor or in an `@Initializer` method]
codetoanalyze/java/nullsafe/FieldNotInitialized.java, codetoanalyze.java.nullsafe.FieldNotInitialized$InitCircular.<init>(codetoanalyze.java.nullsafe.FieldNotInitialized), 0, ERADICATE_FIELD_NOT_INITIALIZED, no_bucket, WARNING, [Field `bad` is declared non-nullable, so it should be initialized in the constructor or in an `@Initializer` method]
codetoanalyze/java/nullsafe/FieldNotInitialized.java, codetoanalyze.java.nullsafe.FieldNotInitialized$InitIfNull.<init>(codetoanalyze.java.nullsafe.FieldNotInitialized), 0, ERADICATE_FIELD_NOT_INITIALIZED, no_bucket, WARNING, [Field `shouldBeGood_FIXME` is declared non-nullable, so it should be initialized in the constructor or in an `@Initializer` method]
codetoanalyze/java/nullsafe/FieldNotInitialized.java, codetoanalyze.java.nullsafe.FieldNotInitialized$InitWithOtherClass$OtherClass.<init>(codetoanalyze.java.nullsafe.FieldNotInitialized$InitWithOtherClass), 0, ERADICATE_FIELD_OVER_ANNOTATED, no_bucket, ADVICE, [Field `FieldNotInitialized$InitWithOtherClass$OtherClass.nullable` is always initialized in the constructor but is declared `@Nullable`]
codetoanalyze/java/nullsafe/FieldNotInitialized.java, codetoanalyze.java.nullsafe.FieldNotInitialized$InitWithOtherClass.<init>(codetoanalyze.java.nullsafe.FieldNotInitialized,codetoanalyze.java.nullsafe.FieldNotInitialized$InitWithOtherClass$OtherClass), 1, ERADICATE_FIELD_NOT_NULLABLE, no_bucket, WARNING, [`bad` is declared non-nullable but is assigned a nullable: field nullable at line 182.]
codetoanalyze/java/nullsafe/FieldNotInitialized.java, codetoanalyze.java.nullsafe.FieldNotInitialized$InitWithTheSameClass.<init>(codetoanalyze.java.nullsafe.FieldNotInitialized,codetoanalyze.java.nullsafe.FieldNotInitialized$InitWithTheSameClass), 0, ERADICATE_FIELD_NOT_INITIALIZED, no_bucket, WARNING, [Field `bad` is declared non-nullable, so it should be initialized in the constructor or in an `@Initializer` method]
codetoanalyze/java/nullsafe/FieldNotInitialized.java, codetoanalyze.java.nullsafe.FieldNotInitialized$InitializationOrder.<init>(codetoanalyze.java.nullsafe.FieldNotInitialized,int), 0, ERADICATE_FIELD_NOT_INITIALIZED, no_bucket, WARNING, [Field `o1` is declared non-nullable, so it should be initialized in the constructor or in an `@Initializer` method]
codetoanalyze/java/nullsafe/FieldNotInitialized.java, codetoanalyze.java.nullsafe.FieldNotInitialized$OnlyRead.<init>(codetoanalyze.java.nullsafe.FieldNotInitialized), 0, ERADICATE_FIELD_NOT_INITIALIZED, no_bucket, WARNING, [Field `o` is declared non-nullable, so it should be initialized in the constructor or in an `@Initializer` method]
codetoanalyze/java/nullsafe/FieldNotInitialized.java, codetoanalyze.java.nullsafe.FieldNotInitialized$OnlyReadIndirect.<init>(codetoanalyze.java.nullsafe.FieldNotInitialized), 0, ERADICATE_FIELD_NOT_INITIALIZED, no_bucket, WARNING, [Field `o1` is declared non-nullable, so it should be initialized in the constructor or in an `@Initializer` method]
codetoanalyze/java/nullsafe/FieldNotInitialized.java, codetoanalyze.java.nullsafe.FieldNotInitialized$ShouldInitializeInAllBranches.<init>(codetoanalyze.java.nullsafe.FieldNotInitialized,int), 0, ERADICATE_FIELD_NOT_INITIALIZED, no_bucket, WARNING, [Field `f3` is declared non-nullable, so it should be initialized in the constructor or in an `@Initializer` method]
codetoanalyze/java/nullsafe/FieldNotInitialized.java, codetoanalyze.java.nullsafe.FieldNotInitialized$ShouldInitializeInAllBranches.<init>(codetoanalyze.java.nullsafe.FieldNotInitialized,int), 0, ERADICATE_FIELD_NOT_INITIALIZED, no_bucket, WARNING, [Field `f5` is declared non-nullable, so it should be initialized in the constructor or in an `@Initializer` method]
codetoanalyze/java/nullsafe/FieldNotInitialized.java, codetoanalyze.java.nullsafe.FieldNotInitialized$ShouldInitializeInAllBranches.<init>(codetoanalyze.java.nullsafe.FieldNotInitialized,int), 0, ERADICATE_FIELD_NOT_INITIALIZED, no_bucket, WARNING, [Field `f2` is declared non-nullable, so it should be initialized in the constructor or in an `@Initializer` method]
codetoanalyze/java/nullsafe/FieldNotInitialized.java, codetoanalyze.java.nullsafe.FieldNotInitialized$Suppression.<init>(codetoanalyze.java.nullsafe.FieldNotInitialized), 0, ERADICATE_FIELD_NOT_INITIALIZED, no_bucket, WARNING, [Field `suppressWrongLintIsBAD` is declared non-nullable, so it should be initialized in the constructor or in an `@Initializer` method]
codetoanalyze/java/nullsafe/FieldNotInitialized.java, codetoanalyze.java.nullsafe.FieldNotInitialized$Suppression.<init>(codetoanalyze.java.nullsafe.FieldNotInitialized), 0, ERADICATE_FIELD_NOT_INITIALIZED, no_bucket, WARNING, [Field `nonNullIsBAD` is declared non-nullable, so it should be initialized in the constructor or in an `@Initializer` method]
codetoanalyze/java/nullsafe/FieldNotInitialized.java, codetoanalyze.java.nullsafe.FieldNotInitialized$Suppression.<init>(codetoanalyze.java.nullsafe.FieldNotInitialized), 0, ERADICATE_FIELD_NOT_INITIALIZED, no_bucket, WARNING, [Field `notNullIsBAD` is declared non-nullable, so it should be initialized in the constructor or in an `@Initializer` method]
codetoanalyze/java/nullsafe/FieldNotInitialized.java, codetoanalyze.java.nullsafe.FieldNotInitialized$Suppression.<init>(codetoanalyze.java.nullsafe.FieldNotInitialized), 0, ERADICATE_FIELD_NOT_INITIALIZED, no_bucket, WARNING, [Field `nonnullIsBAD` is declared non-nullable, so it should be initialized in the constructor or in an `@Initializer` method]
codetoanalyze/java/nullsafe/FieldNotInitialized.java, codetoanalyze.java.nullsafe.FieldNotInitialized$Suppression.testNullifyFields():void, 3, ERADICATE_FIELD_NOT_NULLABLE, no_bucket, WARNING, [`nonnullIsBAD` is declared non-nullable but is assigned `null`: null constant at line 59.]
codetoanalyze/java/nullsafe/FieldNotInitialized.java, codetoanalyze.java.nullsafe.FieldNotInitialized$Suppression.testNullifyFields():void, 4, ERADICATE_FIELD_NOT_NULLABLE, no_bucket, WARNING, [`nonNullIsBAD` is declared non-nullable but is assigned `null`: null constant at line 60.]
codetoanalyze/java/nullsafe/FieldNotInitialized.java, codetoanalyze.java.nullsafe.FieldNotInitialized$Suppression.testNullifyFields():void, 5, ERADICATE_FIELD_NOT_NULLABLE, no_bucket, WARNING, [`injectIsOK` is declared non-nullable but is assigned `null`: null constant at line 61.]
codetoanalyze/java/nullsafe/FieldNotInitialized.java, codetoanalyze.java.nullsafe.FieldNotInitialized$Suppression.testNullifyFields():void, 6, ERADICATE_FIELD_NOT_NULLABLE, no_bucket, WARNING, [`suppressAnnotationIsOK` is declared non-nullable but is assigned `null`: null constant at line 62.]
codetoanalyze/java/nullsafe/FieldNotInitialized.java, codetoanalyze.java.nullsafe.FieldNotInitialized$Suppression.testNullifyFields():void, 7, ERADICATE_FIELD_NOT_NULLABLE, no_bucket, WARNING, [`suppressLintIsOK` is declared non-nullable but is assigned `null`: null constant at line 63.]
codetoanalyze/java/nullsafe/FieldNotInitialized.java, codetoanalyze.java.nullsafe.FieldNotInitialized$Suppressions.<init>(codetoanalyze.java.nullsafe.FieldNotInitialized,int), 0, ERADICATE_FIELD_NOT_INITIALIZED, no_bucket, WARNING, [Field `f2` is declared non-nullable, so it should be initialized in the constructor or in an `@Initializer` method]
codetoanalyze/java/nullsafe/FieldNotInitialized.java, codetoanalyze.java.nullsafe.FieldNotInitialized$Suppressions.<init>(codetoanalyze.java.nullsafe.FieldNotInitialized,int), 2, ERADICATE_PARAMETER_NOT_NULLABLE, no_bucket, WARNING, [`FieldNotInitialized$Suppressions.f(...)`: parameter #1(`a`) is declared non-nullable but the argument is `null`.]
codetoanalyze/java/nullsafe/FieldNotInitialized.java, codetoanalyze.java.nullsafe.FieldNotInitialized$Suppressions.<init>(codetoanalyze.java.nullsafe.FieldNotInitialized,int,int,int), 1, ERADICATE_PARAMETER_NOT_NULLABLE, no_bucket, WARNING, [`FieldNotInitialized$Suppressions.f(...)`: parameter #1(`a`) is declared non-nullable but the argument is `null`.]
codetoanalyze/java/nullsafe/FieldNotInitialized.java, codetoanalyze.java.nullsafe.FieldNotInitialized$WriteItselfIsBAD.<init>(codetoanalyze.java.nullsafe.FieldNotInitialized), 0, ERADICATE_FIELD_NOT_INITIALIZED, no_bucket, WARNING, [Field `bad` is declared non-nullable, so it should be initialized in the constructor or in an `@Initializer` method]
codetoanalyze/java/nullsafe/FieldNotInitialized.java, codetoanalyze.java.nullsafe.TestInitializerAnnotation.<init>(), 0, ERADICATE_FIELD_NOT_INITIALIZED, no_bucket, WARNING, [Field `dontInitAtAllIsBAD` is declared non-nullable, so it should be initialized in the constructor or in an `@Initializer` method]
codetoanalyze/java/nullsafe/FieldNotInitialized.java, codetoanalyze.java.nullsafe.TestInitializerAnnotation.<init>(), 0, ERADICATE_FIELD_NOT_INITIALIZED, no_bucket, WARNING, [Field `initInAnyOtherMethodIsBAD` is declared non-nullable, so it should be initialized in the constructor or in an `@Initializer` method]
codetoanalyze/java/nullsafe/FieldNotInitialized.java, codetoanalyze.java.nullsafe.TestInitializerAnnotation.build():java.lang.Object, 5, ERADICATE_CONDITION_REDUNDANT, no_bucket, ADVICE, [The condition TestInitializerAnnotation.initInInitilizerMethod1IsOK might be always true according to the existing annotations.]
codetoanalyze/java/nullsafe/FieldNotInitialized.java, codetoanalyze.java.nullsafe.TestInitializerAnnotation.build():java.lang.Object, 5, ERADICATE_CONDITION_REDUNDANT, no_bucket, ADVICE, [The condition TestInitializerAnnotation.initInInitilizerMethod2IsOK might be always true according to the existing annotations.]
codetoanalyze/java/nullsafe/FieldNotInitialized.java, codetoanalyze.java.nullsafe.TestInitializerAnnotation.set4(java.lang.String):void, 2, ERADICATE_FIELD_NOT_NULLABLE, no_bucket, WARNING, [`initByNullableInInitializedMethodIsBAD` is declared non-nullable but is assigned a nullable: method parameter value.]
codetoanalyze/java/nullsafe/FieldNotInitialized.java, codetoanalyze.java.nullsafe.TestKnownInitializers$KnownInitializers.<init>(codetoanalyze.java.nullsafe.TestKnownInitializers), 0, ERADICATE_FIELD_NOT_INITIALIZED, no_bucket, WARNING, [Field `initInUnknownMethodIsBAD` is declared non-nullable, so it should be initialized in the constructor or in an `@Initializer` method]
codetoanalyze/java/nullsafe/FieldNotInitialized.java, codetoanalyze.java.nullsafe.TestKnownInitializers$SimplyOnCreateWontDoATrick.<init>(codetoanalyze.java.nullsafe.TestKnownInitializers), 0, ERADICATE_FIELD_NOT_INITIALIZED, no_bucket, WARNING, [Field `initInUnknownMethodIsBAD` is declared non-nullable, so it should be initialized in the constructor or in an `@Initializer` method]
codetoanalyze/java/nullsafe/FieldNotNullable.java, Linters_dummy_method, 20, ERADICATE_META_CLASS_NEEDS_IMPROVEMENT, no_bucket, INFO, [], CanAssignNullInCleanupMethods, codetoanalyze.java.nullsafe, issues: 1, curr_mode: "Default"
codetoanalyze/java/nullsafe/FieldNotNullable.java, Linters_dummy_method, 48, ERADICATE_META_CLASS_NEEDS_IMPROVEMENT, no_bucket, INFO, [], FieldNotNullable, codetoanalyze.java.nullsafe, issues: 4, curr_mode: "Default"
codetoanalyze/java/nullsafe/FieldNotNullable.java, codetoanalyze.java.nullsafe.CanAssignNullInCleanupMethods.assignNullInAnyOtherMethodIsBAD():void, 1, ERADICATE_FIELD_NOT_NULLABLE, no_bucket, WARNING, [`someObject` is declared non-nullable but is assigned `null`: null constant at line 44.]
codetoanalyze/java/nullsafe/FieldNotNullable.java, codetoanalyze.java.nullsafe.FieldNotNullable.<init>(), 0, ERADICATE_FIELD_OVER_ANNOTATED, no_bucket, ADVICE, [Field `FieldNotNullable.nullable` is always initialized in the constructor but is declared `@Nullable`]
codetoanalyze/java/nullsafe/FieldNotNullable.java, codetoanalyze.java.nullsafe.FieldNotNullable.<init>(), 4, ERADICATE_FIELD_NOT_NULLABLE, no_bucket, WARNING, [`initializeNonNullableWithNullIsBAD` is declared non-nullable but is assigned `null`: null constant at line 52.]
codetoanalyze/java/nullsafe/FieldNotNullable.java, codetoanalyze.java.nullsafe.FieldNotNullable.getNullable():java.lang.String, 0, ERADICATE_RETURN_OVER_ANNOTATED, no_bucket, ADVICE, [Method `getNullable()` is annotated with `@Nullable` but never returns null.]
codetoanalyze/java/nullsafe/FieldNotNullable.java, codetoanalyze.java.nullsafe.FieldNotNullable.setNullableToNotNullableIsBAD(java.lang.String):void, 1, ERADICATE_FIELD_NOT_NULLABLE, no_bucket, WARNING, [`notNullable` is declared non-nullable but is assigned `null`: null constant at line 65.]
codetoanalyze/java/nullsafe/FieldNotNullable.java, codetoanalyze.java.nullsafe.FieldNotNullable.setNullableToNotNullableIsBAD(java.lang.String):void, 2, ERADICATE_FIELD_NOT_NULLABLE, no_bucket, WARNING, [`notNullable` is declared non-nullable but is assigned a nullable: method parameter s.]
codetoanalyze/java/nullsafe/FieldNotNullable.java, codetoanalyze.java.nullsafe.FieldNotNullable.setNullableToNotNullableIsBAD(java.lang.String):void, 3, ERADICATE_FIELD_NOT_NULLABLE, no_bucket, WARNING, [`notNullable` is declared non-nullable but is assigned a nullable: call to getNullable() at line 67.]
codetoanalyze/java/nullsafe/FieldNullabilityMemoization.java, Linters_dummy_method, 27, ERADICATE_META_CLASS_NEEDS_IMPROVEMENT, no_bucket, INFO, [], FieldNullabilityMemoization, codetoanalyze.java.nullsafe, issues: 2, curr_mode: "Default"
codetoanalyze/java/nullsafe/FieldNullabilityMemoization.java, codetoanalyze.java.nullsafe.FieldNullabilityMemoization.dereferenceIsBAD():void, 1, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`FieldNullabilityMemoization.nullable` is nullable and is not locally checked for null when calling `toString()`.]
codetoanalyze/java/nullsafe/FieldNullabilityMemoization.java, codetoanalyze.java.nullsafe.FieldNullabilityMemoization.dereferenceViaLocalVarIsBAD():void, 2, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`a` is nullable and is not locally checked for null when calling `toString()`: field nullable at line 35.]
codetoanalyze/java/nullsafe/FieldOverAnnotated.java, Linters_dummy_method, 15, ERADICATE_META_CLASS_CAN_BE_NULLSAFE, no_bucket, ADVICE, [Congrats! `FieldOverAnnotated` is free of nullability issues. Mark it `@Nullsafe(Nullsafe.Mode.LOCAL)` to prevent regressions.], FieldOverAnnotated, codetoanalyze.java.nullsafe, issues: 0, curr_mode: "Default", promote_mode: "Strict"
codetoanalyze/java/nullsafe/FieldOverAnnotated.java, codetoanalyze.java.nullsafe.FieldOverAnnotated.<init>(int), 0, ERADICATE_FIELD_OVER_ANNOTATED, no_bucket, ADVICE, [Field `FieldOverAnnotated.initializedInAllConstructorsIsBAD` is always initialized in the constructor but is declared `@Nullable`]
codetoanalyze/java/nullsafe/FieldOverAnnotated.java, codetoanalyze.java.nullsafe.FieldOverAnnotated.<init>(int), 0, ERADICATE_FIELD_OVER_ANNOTATED, no_bucket, ADVICE, [Field `FieldOverAnnotated.FP_initializedInAllConstructorsButSetToNullInAPublicMethodShouldBeOK` is always initialized in the constructor but is declared `@Nullable`]
codetoanalyze/java/nullsafe/FieldOverAnnotated.java, codetoanalyze.java.nullsafe.FieldOverAnnotated.<init>(int), 0, ERADICATE_FIELD_OVER_ANNOTATED, no_bucket, ADVICE, [Field `FieldOverAnnotated.initilizedInAllConstructorsAndAllBranchesIsBAD` is always initialized in the constructor but is declared `@Nullable`]
codetoanalyze/java/nullsafe/FieldOverAnnotated.java, codetoanalyze.java.nullsafe.FieldOverAnnotated.<init>(int,int), 0, ERADICATE_FIELD_OVER_ANNOTATED, no_bucket, ADVICE, [Field `FieldOverAnnotated.initializedInAllConstructorsIsBAD` is always initialized in the constructor but is declared `@Nullable`]
codetoanalyze/java/nullsafe/FieldOverAnnotated.java, codetoanalyze.java.nullsafe.FieldOverAnnotated.<init>(int,int), 0, ERADICATE_FIELD_OVER_ANNOTATED, no_bucket, ADVICE, [Field `FieldOverAnnotated.FP_initializedInAllConstructorsButSetToNullInAPublicMethodShouldBeOK` is always initialized in the constructor but is declared `@Nullable`]
codetoanalyze/java/nullsafe/FieldOverAnnotated.java, codetoanalyze.java.nullsafe.FieldOverAnnotated.<init>(int,int), 0, ERADICATE_FIELD_OVER_ANNOTATED, no_bucket, ADVICE, [Field `FieldOverAnnotated.initilizedInAllConstructorsAndAllBranchesIsBAD` is always initialized in the constructor but is declared `@Nullable`]
codetoanalyze/java/nullsafe/InconsistentSubclassAnnotation.java, Linters_dummy_method, 39, ERADICATE_META_CLASS_NEEDS_IMPROVEMENT, no_bucket, INFO, [], ReturnValToNullBAD, codetoanalyze.java.nullsafe, issues: 1, curr_mode: "Default"
codetoanalyze/java/nullsafe/InconsistentSubclassAnnotation.java, Linters_dummy_method, 46, ERADICATE_META_CLASS_CAN_BE_NULLSAFE, no_bucket, ADVICE, [Congrats! `ReturnNullToValOK` is free of nullability issues. Mark it `@Nullsafe(Nullsafe.Mode.LOCAL)` to prevent regressions.], ReturnNullToValOK, codetoanalyze.java.nullsafe, issues: 0, curr_mode: "Default", promote_mode: "Strict"
codetoanalyze/java/nullsafe/InconsistentSubclassAnnotation.java, Linters_dummy_method, 50, ERADICATE_META_CLASS_CAN_BE_NULLSAFE, no_bucket, ADVICE, [Congrats! `ReturnValFromValAndNullFromNullOK` is free of nullability issues. Mark it `@Nullsafe(Nullsafe.Mode.LOCAL)` to prevent regressions.], ReturnValFromValAndNullFromNullOK, codetoanalyze.java.nullsafe, issues: 0, curr_mode: "Default", promote_mode: "Strict"
codetoanalyze/java/nullsafe/InconsistentSubclassAnnotation.java, Linters_dummy_method, 61, ERADICATE_META_CLASS_CAN_BE_NULLSAFE, no_bucket, ADVICE, [Congrats! `AbstractReturnValToNullFN` is free of nullability issues. Mark it `@Nullsafe(Nullsafe.Mode.LOCAL)` to prevent regressions.], AbstractReturnValToNullFN, codetoanalyze.java.nullsafe, issues: 0, curr_mode: "Default", promote_mode: "Strict"
codetoanalyze/java/nullsafe/InconsistentSubclassAnnotation.java, Linters_dummy_method, 69, ERADICATE_META_CLASS_CAN_BE_NULLSAFE, no_bucket, ADVICE, [Congrats! `ArgValToNullOK` is free of nullability issues. Mark it `@Nullsafe(Nullsafe.Mode.LOCAL)` to prevent regressions.], ArgValToNullOK, codetoanalyze.java.nullsafe, issues: 0, curr_mode: "Default", promote_mode: "Strict"
codetoanalyze/java/nullsafe/InconsistentSubclassAnnotation.java, Linters_dummy_method, 75, ERADICATE_META_CLASS_NEEDS_IMPROVEMENT, no_bucket, INFO, [], ArgNullToValBAD, codetoanalyze.java.nullsafe, issues: 1, curr_mode: "Default"
codetoanalyze/java/nullsafe/InconsistentSubclassAnnotation.java, Linters_dummy_method, 81, ERADICATE_META_CLASS_NEEDS_IMPROVEMENT, no_bucket, INFO, [], ArgNullToValForInterfaceInAnotherFileBAD, codetoanalyze.java.nullsafe, issues: 1, curr_mode: "Default"
codetoanalyze/java/nullsafe/InconsistentSubclassAnnotation.java, Linters_dummy_method, 88, ERADICATE_META_CLASS_CAN_BE_NULLSAFE, no_bucket, ADVICE, [Congrats! `ArgValToValAndNullToNullOK` is free of nullability issues. Mark it `@Nullsafe(Nullsafe.Mode.LOCAL)` to prevent regressions.], ArgValToValAndNullToNullOK, codetoanalyze.java.nullsafe, issues: 0, curr_mode: "Default", promote_mode: "Strict"
codetoanalyze/java/nullsafe/InconsistentSubclassAnnotation.java, Linters_dummy_method, 102, ERADICATE_META_CLASS_CAN_BE_NULLSAFE, no_bucket, ADVICE, [Congrats! `OverrideExistingCorrectlyOK` is free of nullability issues. Mark it `@Nullsafe(Nullsafe.Mode.LOCAL)` to prevent regressions.], OverrideExistingCorrectlyOK, codetoanalyze.java.nullsafe, issues: 0, curr_mode: "Default", promote_mode: "Strict"
codetoanalyze/java/nullsafe/InconsistentSubclassAnnotation.java, Linters_dummy_method, 120, ERADICATE_META_CLASS_NEEDS_IMPROVEMENT, no_bucket, INFO, [], NoOverrideSinceDifferentTypesOK, codetoanalyze.java.nullsafe, issues: 0, curr_mode: "Default"
codetoanalyze/java/nullsafe/InconsistentSubclassAnnotation.java, Linters_dummy_method, 137, ERADICATE_META_CLASS_NEEDS_IMPROVEMENT, no_bucket, INFO, [], OverloadExistingIncorrectBAD, codetoanalyze.java.nullsafe, issues: 1, curr_mode: "Default"
codetoanalyze/java/nullsafe/InconsistentSubclassAnnotation.java, Linters_dummy_method, 146, ERADICATE_META_CLASS_CAN_BE_NULLSAFE, no_bucket, ADVICE, [Congrats! `ConstructorsAreExcluded` is free of nullability issues. Mark it `@Nullsafe(Nullsafe.Mode.LOCAL)` to prevent regressions.], ConstructorsAreExcluded, codetoanalyze.java.nullsafe, issues: 0, curr_mode: "Default", promote_mode: "Strict"
codetoanalyze/java/nullsafe/InconsistentSubclassAnnotation.java, Linters_dummy_method, 160, ERADICATE_META_CLASS_NEEDS_IMPROVEMENT, no_bucket, INFO, [], ExtendsExternalLibrary, codetoanalyze.java.nullsafe, issues: 1, curr_mode: "Default"
codetoanalyze/java/nullsafe/InconsistentSubclassAnnotation.java, Linters_dummy_method, 177, ERADICATE_META_CLASS_NEEDS_IMPROVEMENT, no_bucket, INFO, [], JavaLangEquals, codetoanalyze.java.nullsafe, issues: 2, curr_mode: "Default"
codetoanalyze/java/nullsafe/InconsistentSubclassAnnotation.java, Linters_dummy_method, 197, ERADICATE_META_CLASS_CAN_BE_NULLSAFE, no_bucket, ADVICE, [Congrats! `NonNullableConcreteGetterOK` is free of nullability issues. Mark it `@Nullsafe(Nullsafe.Mode.LOCAL)` to prevent regressions.], NonNullableConcreteGetterOK, codetoanalyze.java.nullsafe, issues: 0, curr_mode: "Default", promote_mode: "Strict"
codetoanalyze/java/nullsafe/InconsistentSubclassAnnotation.java, Linters_dummy_method, 203, ERADICATE_META_CLASS_NEEDS_IMPROVEMENT, no_bucket, INFO, [], NullableConcreteGetterBAD, codetoanalyze.java.nullsafe, issues: 1, curr_mode: "Default"
codetoanalyze/java/nullsafe/InconsistentSubclassAnnotation.java, codetoanalyze.java.nullsafe.ArgNullToValBAD.nullableArg(java.lang.String):java.lang.String, 0, ERADICATE_INCONSISTENT_SUBCLASS_PARAMETER_ANNOTATION, no_bucket, WARNING, [First parameter `arg` of method `ArgNullToValBAD.nullableArg(...)` is missing `@Nullable` declaration when overriding `VariousMethods.nullableArg(...)`. The parent method declared it can handle `null` for this param, so the child should also declare that.]
codetoanalyze/java/nullsafe/InconsistentSubclassAnnotation.java, codetoanalyze.java.nullsafe.ArgNullToValForInterfaceInAnotherFileBAD.implementInAnotherFile(java.lang.String):java.lang.String, 0, ERADICATE_INCONSISTENT_SUBCLASS_PARAMETER_ANNOTATION, no_bucket, WARNING, [First parameter `s` of method `ArgNullToValForInterfaceInAnotherFileBAD.implementInAnotherFile(...)` is missing `@Nullable` declaration when overriding `InconsistentSubclassAnnotationInterface.implementInAnotherFile(...)`. The parent method declared it can handle `null` for this param, so the child should also declare that.]
codetoanalyze/java/nullsafe/InconsistentSubclassAnnotation.java, codetoanalyze.java.nullsafe.ExtendsExternalLibrary.externalMethod2(java.lang.Object):void, 0, ERADICATE_INCONSISTENT_SUBCLASS_PARAMETER_ANNOTATION, no_bucket, WARNING, [First parameter `object` of method `ExtendsExternalLibrary.externalMethod2(...)` is missing `@Nullable` declaration when overriding `SomeExternalClass.externalMethod2(...)`. The parent method declared it can handle `null` for this param, so the child should also declare that.]
codetoanalyze/java/nullsafe/InconsistentSubclassAnnotation.java, codetoanalyze.java.nullsafe.JavaLangEquals.equals(java.lang.Object):boolean, 0, ERADICATE_INCONSISTENT_SUBCLASS_PARAMETER_ANNOTATION, no_bucket, WARNING, [Parameter `x` is missing `@Nullable` declaration: according to the Java Specification, for any object `x` call `x.equals(null)` should properly return false.]
codetoanalyze/java/nullsafe/InconsistentSubclassAnnotation.java, codetoanalyze.java.nullsafe.JavaLangEquals.equals(java.lang.Object):boolean, 4, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`x` is nullable and is not locally checked for null when calling `toString()`: Object.equals() should be able to accept `null`, according to the Java specification.]
codetoanalyze/java/nullsafe/InconsistentSubclassAnnotation.java, codetoanalyze.java.nullsafe.NullableConcreteGetterBAD.get():java.lang.String, 0, ERADICATE_INCONSISTENT_SUBCLASS_RETURN_ANNOTATION, no_bucket, WARNING, [Child method `NullableConcreteGetterBAD.get()` is not substitution-compatible with its parent: the return type is declared as nullable, but parent method `NonNullableInterfaceGetterOK.get()` is missing `@Nullable` declaration. Either mark the parent as `@Nullable` or ensure the child does not return `null`.]
codetoanalyze/java/nullsafe/InconsistentSubclassAnnotation.java, codetoanalyze.java.nullsafe.OverloadExistingIncorrectBAD.overload(java.lang.String,java.lang.String):java.lang.String, 0, ERADICATE_INCONSISTENT_SUBCLASS_RETURN_ANNOTATION, no_bucket, WARNING, [Child method `OverloadExistingIncorrectBAD.overload(...)` is not substitution-compatible with its parent: the return type is declared as nullable, but parent method `Overloads.overload(...)` is missing `@Nullable` declaration. Either mark the parent as `@Nullable` or ensure the child does not return `null`.]
codetoanalyze/java/nullsafe/InconsistentSubclassAnnotation.java, codetoanalyze.java.nullsafe.ReturnValToNullBAD.valBoth(java.lang.String):java.lang.String, 0, ERADICATE_INCONSISTENT_SUBCLASS_RETURN_ANNOTATION, no_bucket, WARNING, [Child method `ReturnValToNullBAD.valBoth(...)` is not substitution-compatible with its parent: the return type is declared as nullable, but parent method `VariousMethods.valBoth(...)` is missing `@Nullable` declaration. Either mark the parent as `@Nullable` or ensure the child does not return `null`.]
codetoanalyze/java/nullsafe/InheritanceForStrictMode.java, Linters_dummy_method, 14, ERADICATE_META_CLASS_NEEDS_IMPROVEMENT, no_bucket, INFO, [], InheritanceForStrictMode, codetoanalyze.java.nullsafe, issues: 6, curr_mode: "Default"
codetoanalyze/java/nullsafe/InheritanceForStrictMode.java, codetoanalyze.java.nullsafe.InheritanceForStrictMode$NonStrictExtendingStrict.badToAddNullableInChildren():java.lang.String, 0, ERADICATE_INCONSISTENT_SUBCLASS_RETURN_ANNOTATION, no_bucket, WARNING, [Child method `InheritanceForStrictMode$NonStrictExtendingStrict.badToAddNullableInChildren()` is not substitution-compatible with its parent: the return type is declared as nullable, but parent method `InheritanceForStrictMode$StrictBase.badToAddNullableInChildren()` is missing `@Nullable` declaration. Either mark the parent as `@Nullable` or ensure the child does not return `null`.]
codetoanalyze/java/nullsafe/InheritanceForStrictMode.java, codetoanalyze.java.nullsafe.InheritanceForStrictMode$NonStrictExtendingStrict.params(java.lang.String,java.lang.String):void, 0, ERADICATE_INCONSISTENT_SUBCLASS_PARAMETER_ANNOTATION, no_bucket, WARNING, [First parameter `badToRemoveNullableInChildren` of method `InheritanceForStrictMode$NonStrictExtendingStrict.params(...)` is missing `@Nullable` declaration when overriding `InheritanceForStrictMode$StrictBase.params(...)`. The parent method declared it can handle `null` for this param, so the child should also declare that.]
codetoanalyze/java/nullsafe/InheritanceForStrictMode.java, codetoanalyze.java.nullsafe.InheritanceForStrictMode$StrictExtendingNonstrict.badToAddNullableInChildren():java.lang.String, 0, ERADICATE_INCONSISTENT_SUBCLASS_RETURN_ANNOTATION, no_bucket, ERROR, [Child method `InheritanceForStrictMode$StrictExtendingNonstrict.badToAddNullableInChildren()` is not substitution-compatible with its parent: the return type is declared as nullable, but parent method `InheritanceForStrictMode$NonStrictBase.badToAddNullableInChildren()` is missing `@Nullable` declaration. Either mark the parent as `@Nullable` or ensure the child does not return `null`.]
codetoanalyze/java/nullsafe/InheritanceForStrictMode.java, codetoanalyze.java.nullsafe.InheritanceForStrictMode$StrictExtendingNonstrict.params(java.lang.String,java.lang.String):void, 0, ERADICATE_INCONSISTENT_SUBCLASS_PARAMETER_ANNOTATION, no_bucket, ERROR, [First parameter `badToRemoveNullableInChildren` of method `InheritanceForStrictMode$StrictExtendingNonstrict.params(...)` is missing `@Nullable` declaration when overriding `InheritanceForStrictMode$NonStrictBase.params(...)`. The parent method declared it can handle `null` for this param, so the child should also declare that.]
codetoanalyze/java/nullsafe/InheritanceForStrictMode.java, codetoanalyze.java.nullsafe.InheritanceForStrictMode$StrictExtendingStrict.badToAddNullableInChildren():java.lang.String, 0, ERADICATE_INCONSISTENT_SUBCLASS_RETURN_ANNOTATION, no_bucket, ERROR, [Child method `InheritanceForStrictMode$StrictExtendingStrict.badToAddNullableInChildren()` is not substitution-compatible with its parent: the return type is declared as nullable, but parent method `InheritanceForStrictMode$StrictBase.badToAddNullableInChildren()` is missing `@Nullable` declaration. Either mark the parent as `@Nullable` or ensure the child does not return `null`.]
codetoanalyze/java/nullsafe/InheritanceForStrictMode.java, codetoanalyze.java.nullsafe.InheritanceForStrictMode$StrictExtendingStrict.params(java.lang.String,java.lang.String):void, 0, ERADICATE_INCONSISTENT_SUBCLASS_PARAMETER_ANNOTATION, no_bucket, ERROR, [First parameter `badToRemoveNullableInChildren` of method `InheritanceForStrictMode$StrictExtendingStrict.params(...)` is missing `@Nullable` declaration when overriding `InheritanceForStrictMode$StrictBase.params(...)`. The parent method declared it can handle `null` for this param, so the child should also declare that.]
codetoanalyze/java/nullsafe/JunitExample.java, Linters_dummy_method, 9, ERADICATE_META_CLASS_CAN_BE_NULLSAFE, no_bucket, ADVICE, [Congrats! `JunitExample` is free of nullability issues. Mark it `@Nullsafe(Nullsafe.Mode.LOCAL)` to prevent regressions.], JunitExample, <no package>, issues: 0, curr_mode: "Default", promote_mode: "LocalTrustAll"
codetoanalyze/java/nullsafe/Lambdas.java, Linters_dummy_method, 19, ERADICATE_META_CLASS_NEEDS_IMPROVEMENT, no_bucket, INFO, [], Lambdas, codetoanalyze.java.nullsafe, issues: 6, curr_mode: "Default"
codetoanalyze/java/nullsafe/Lambdas.java, codetoanalyze.java.nullsafe.Lambdas$Lambda$_22_0.onFailure(java.lang.Integer):void, 0, ERADICATE_INCONSISTENT_SUBCLASS_PARAMETER_ANNOTATION, no_bucket, WARNING, [First parameter `$bcvar1` of method `Lambdas$Lambda$_22_0.onFailure(...)` is missing `@Nullable` declaration when overriding `Lambdas$NullableCallbackWithDefaultMethods.onFailure(...)`. The parent method declared it can handle `null` for this param, so the child should also declare that.]
codetoanalyze/java/nullsafe/Lambdas.java, codetoanalyze.java.nullsafe.Lambdas$Lambda$_27_1.apply(java.lang.Object):java.lang.Object, 0, ERADICATE_INCONSISTENT_SUBCLASS_PARAMETER_ANNOTATION, no_bucket, WARNING, [First parameter `$bcvar1` of method `Lambdas$Lambda$_27_1.apply(...)` is missing `@Nullable` declaration when overriding `Lambdas$NullableFunction.apply(...)`. The parent method declared it can handle `null` for this param, so the child should also declare that.]
codetoanalyze/java/nullsafe/Lambdas.java, codetoanalyze.java.nullsafe.Lambdas$Lambda$_28_1.apply(java.lang.Object):java.lang.Object, 0, ERADICATE_INCONSISTENT_SUBCLASS_PARAMETER_ANNOTATION, no_bucket, WARNING, [First parameter `$bcvar1` of method `Lambdas$Lambda$_28_1.apply(...)` is missing `@Nullable` declaration when overriding `Lambdas$NullableFunction.apply(...)`. The parent method declared it can handle `null` for this param, so the child should also declare that.]
codetoanalyze/java/nullsafe/Lambdas.java, codetoanalyze.java.nullsafe.Lambdas$Lambda$_29_1.apply(java.lang.Object):java.lang.Object, 0, ERADICATE_INCONSISTENT_SUBCLASS_PARAMETER_ANNOTATION, no_bucket, WARNING, [First parameter `$bcvar1` of method `Lambdas$Lambda$_29_1.apply(...)` is missing `@Nullable` declaration when overriding `Lambdas$NullableFunction.apply(...)`. The parent method declared it can handle `null` for this param, so the child should also declare that.]
codetoanalyze/java/nullsafe/Lambdas.java, codetoanalyze.java.nullsafe.Lambdas$NullsafeClass.useJavaUtilFunction_UNSUPPORTED(java.util.function.Function):java.lang.String, 1, ERADICATE_PARAMETER_NOT_NULLABLE, no_bucket, ERROR, [Third-party `Function.apply(...)` is missing a signature that would allow passing a nullable to param #1. Actual argument `getNullableString()` is nullable. Consider adding the correct signature of `Function.apply(...)` to nullsafe/third-party-signatures/java.sig.]
codetoanalyze/java/nullsafe/Lambdas.java, codetoanalyze.java.nullsafe.Lambdas$NullsafeClass.useJavaUtilFunction_UNSUPPORTED(java.util.function.Function):java.lang.String, 1, ERADICATE_UNVETTED_THIRD_PARTY_IN_NULLSAFE, no_bucket, ERROR, [`Function.apply(...)`: `@NullsafeLocal(trust=all)` mode prohibits using values coming from not vetted third party methods without a check. Result of this call is used at line 143. Either add a local check for null or assertion, or add the correct signature to nullsafe/third-party-signatures/java.sig.]
codetoanalyze/java/nullsafe/LibraryCalls.java, Linters_dummy_method, 16, ERADICATE_META_CLASS_NEEDS_IMPROVEMENT, no_bucket, INFO, [], LibraryCalls, codetoanalyze.java.nullsafe, issues: 5, curr_mode: "Default"
codetoanalyze/java/nullsafe/LibraryCalls.java, codetoanalyze.java.nullsafe.LibraryCalls.badAtomicReferenceDereference(java.util.concurrent.atomic.AtomicReference):java.lang.String, 1, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`ref.get()` is nullable and is not locally checked for null when calling `toString()`: call to AtomicReference.get() at line 35 (nullable according to nullsafe internal models).]
codetoanalyze/java/nullsafe/LibraryCalls.java, codetoanalyze.java.nullsafe.LibraryCalls.badPhantomReferenceDereference(java.lang.ref.PhantomReference):java.lang.String, 1, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`ref.get()` is nullable and is not locally checked for null when calling `toString()`: call to PhantomReference.get() at line 27 (nullable according to nullsafe internal models).]
codetoanalyze/java/nullsafe/LibraryCalls.java, codetoanalyze.java.nullsafe.LibraryCalls.badReferenceDereference(java.lang.ref.Reference):java.lang.String, 1, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`ref.get()` is nullable and is not locally checked for null when calling `toString()`: call to Reference.get() at line 19 (nullable according to nullsafe internal models).]
codetoanalyze/java/nullsafe/LibraryCalls.java, codetoanalyze.java.nullsafe.LibraryCalls.badSoftReferenceDereference(java.lang.ref.SoftReference):java.lang.String, 1, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`ref.get()` is nullable and is not locally checked for null when calling `toString()`: call to SoftReference.get() at line 31 (nullable according to nullsafe internal models).]
codetoanalyze/java/nullsafe/LibraryCalls.java, codetoanalyze.java.nullsafe.LibraryCalls.badWeakReferenceDereference(java.lang.ref.WeakReference):java.lang.String, 1, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`ref.get()` is nullable and is not locally checked for null when calling `toString()`: call to Reference.get() at line 23 (nullable according to nullsafe internal models).]
codetoanalyze/java/nullsafe/MapNullability.java, Linters_dummy_method, 13, ERADICATE_META_CLASS_NEEDS_IMPROVEMENT, no_bucket, INFO, [], MapNullability, codetoanalyze.java.nullsafe, issues: 13, curr_mode: "Default"
codetoanalyze/java/nullsafe/MapNullability.java, codetoanalyze.java.nullsafe.MapNullability$TestThatGetAfterPutIsAllowed.getAfterConditionalPutWrongKeyIsBAD(java.util.Map,java.lang.String,java.lang.String):void, 5, ERADICATE_FIELD_NOT_NULLABLE, no_bucket, WARNING, [`dontAssignNull` is declared non-nullable but is assigned a nullable: call to Map.get(...) at line 137 (nullable according to nullsafe internal models).]
codetoanalyze/java/nullsafe/MapNullability.java, codetoanalyze.java.nullsafe.MapNullability$TestThatGetAfterPutIsAllowed.getAfterPutNullableIsBAD(java.util.Map,java.lang.String):void, 2, ERADICATE_PARAMETER_NOT_NULLABLE, no_bucket, WARNING, [`Map.put(...)`: parameter #2 is declared non-nullable (according to nullsafe internal models) but the argument `nullableValue` is nullable.]
codetoanalyze/java/nullsafe/MapNullability.java, codetoanalyze.java.nullsafe.MapNullability$TestThatGetAfterPutIsAllowed.getAfterPutNullableIsBAD(java.util.Map,java.lang.String):void, 3, ERADICATE_FIELD_NOT_NULLABLE, no_bucket, WARNING, [`dontAssignNull` is declared non-nullable but is assigned a nullable: method parameter nullableValue.]
codetoanalyze/java/nullsafe/MapNullability.java, codetoanalyze.java.nullsafe.MapNullability$TestThatGetAfterPutIsAllowed.getAfterPutSeveralKeysButGetWrongOneIsBAD(java.util.Map):void, 4, ERADICATE_FIELD_NOT_NULLABLE, no_bucket, WARNING, [`dontAssignNull` is declared non-nullable but is assigned a nullable: call to Map.get(...) at line 98 (nullable according to nullsafe internal models).]
codetoanalyze/java/nullsafe/MapNullability.java, codetoanalyze.java.nullsafe.MapNullability$TestThatGetAfterPutIsAllowed.getAfterPutWrongKeyIsBAD(java.util.Map,java.lang.String,java.lang.String):void, 3, ERADICATE_FIELD_NOT_NULLABLE, no_bucket, WARNING, [`dontAssignNull` is declared non-nullable but is assigned a nullable: call to Map.get(...) at line 79 (nullable according to nullsafe internal models).]
codetoanalyze/java/nullsafe/MapNullability.java, codetoanalyze.java.nullsafe.MapNullability$TestThatGetAfterPutIsAllowed.getWithoutPutIsBAD(java.util.Map,java.lang.String):void, 1, ERADICATE_FIELD_NOT_NULLABLE, no_bucket, WARNING, [`dontAssignNull` is declared non-nullable but is assigned a nullable: call to Map.get(...) at line 73 (nullable according to nullsafe internal models).]
codetoanalyze/java/nullsafe/MapNullability.java, codetoanalyze.java.nullsafe.MapNullability$TestThatGetAfterPutIsAllowed.overwriteKeyByNonnullIsOK(java.util.Map,java.lang.String):void, 1, ERADICATE_PARAMETER_NOT_NULLABLE, no_bucket, WARNING, [`Map.put(...)`: parameter #2 is declared non-nullable (according to nullsafe internal models) but the argument is `null`.]
codetoanalyze/java/nullsafe/MapNullability.java, codetoanalyze.java.nullsafe.MapNullability$TestThatGetAfterPutIsAllowed.overwriteKeyByNullIsBAD(java.util.Map,java.lang.String):void, 2, ERADICATE_PARAMETER_NOT_NULLABLE, no_bucket, WARNING, [`Map.put(...)`: parameter #2 is declared non-nullable (according to nullsafe internal models) but the argument is `null`.]
codetoanalyze/java/nullsafe/MapNullability.java, codetoanalyze.java.nullsafe.MapNullability$TestThatGetAfterPutIsAllowed.overwriteKeyByNullIsBAD(java.util.Map,java.lang.String):void, 3, ERADICATE_FIELD_NOT_NULLABLE, no_bucket, WARNING, [`dontAssignNull` is declared non-nullable but is assigned `null`: null constant at line 114.]
codetoanalyze/java/nullsafe/MapNullability.java, codetoanalyze.java.nullsafe.MapNullability$TestThatGetIsAllowedOnlyAfterContainsKeyWasChecked.immutableMap_usingGetAfterWrongKeyWasCheckedIsBAD(com.google.common.collect.ImmutableMap):void, 3, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`m.get(...)` is nullable and is not locally checked for null when calling `isEmpty()`: call to ImmutableMap.get(...) at line 59 (nullable according to nullsafe internal models).]
codetoanalyze/java/nullsafe/MapNullability.java, codetoanalyze.java.nullsafe.MapNullability$TestThatGetIsAllowedOnlyAfterContainsKeyWasChecked.usingGetAfterWrongKeyWasCheckedInWhileLoopIsBAD(java.util.Map):void, 3, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`m.get(...)` is nullable and is not locally checked for null when calling `isEmpty()`: call to Map.get(...) at line 44 (nullable according to nullsafe internal models).]
codetoanalyze/java/nullsafe/MapNullability.java, codetoanalyze.java.nullsafe.MapNullability$TestThatGetIsAllowedOnlyAfterContainsKeyWasChecked.usingGetAfterWrongKeyWasCheckedIsBAD(java.util.Map):void, 2, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`m.get(...)` is nullable and is not locally checked for null when calling `isEmpty()`: call to Map.get(...) at line 29 (nullable according to nullsafe internal models).]
codetoanalyze/java/nullsafe/MapNullability.java, codetoanalyze.java.nullsafe.MapNullability$TestThatGetIsAllowedOnlyAfterContainsKeyWasChecked.usingGetWithoutCheckingKeyIsBAD(java.util.Map):void, 1, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`m.get(...)` is nullable and is not locally checked for null when calling `isEmpty()`: call to Map.get(...) at line 24 (nullable according to nullsafe internal models).]
codetoanalyze/java/nullsafe/ModePromotions.java, Linters_dummy_method, 18, ERADICATE_META_CLASS_CAN_BE_NULLSAFE, no_bucket, ADVICE, [Congrats! `Default_NoDeps_CanBePromotedToStrict` is free of nullability issues. Mark it `@Nullsafe(Nullsafe.Mode.LOCAL)` to prevent regressions.], Default_NoDeps_CanBePromotedToStrict, codetoanalyze.java.nullsafe, issues: 0, curr_mode: "Default", promote_mode: "Strict"
codetoanalyze/java/nullsafe/ModePromotions.java, Linters_dummy_method, 25, ERADICATE_META_CLASS_IS_NULLSAFE, no_bucket, INFO, [], Local_NoDeps_CanBePromotedToStrict, codetoanalyze.java.nullsafe, issues: 0, curr_mode: "LocalTrustAll", promote_mode: "Strict"
codetoanalyze/java/nullsafe/ModePromotions.java, Linters_dummy_method, 33, ERADICATE_META_CLASS_IS_NULLSAFE, no_bucket, INFO, [], Strict_NoDeps_NoPromos, codetoanalyze.java.nullsafe, issues: 0, curr_mode: "Strict"
codetoanalyze/java/nullsafe/ModePromotions.java, Linters_dummy_method, 39, ERADICATE_META_CLASS_CAN_BE_NULLSAFE, no_bucket, ADVICE, [Congrats! `Default_UsesDefault_CanBePromotedToTrustAll` is free of nullability issues. Mark it `@Nullsafe(Nullsafe.Mode.LOCAL)` to prevent regressions.], Default_UsesDefault_CanBePromotedToTrustAll, codetoanalyze.java.nullsafe, issues: 0, curr_mode: "Default", promote_mode: "LocalTrustAll"
codetoanalyze/java/nullsafe/ModePromotions.java, Linters_dummy_method, 47, ERADICATE_META_CLASS_CAN_BE_NULLSAFE, no_bucket, ADVICE, [Congrats! `Default_UsesItself_CanBePromotedToStrict` is free of nullability issues. Mark it `@Nullsafe(Nullsafe.Mode.LOCAL)` to prevent regressions.], Default_UsesItself_CanBePromotedToStrict, codetoanalyze.java.nullsafe, issues: 0, curr_mode: "Default", promote_mode: "Strict"
codetoanalyze/java/nullsafe/ModePromotions.java, Linters_dummy_method, 59, ERADICATE_META_CLASS_CAN_BE_NULLSAFE, no_bucket, ADVICE, [Congrats! `Default_UsesLocal_CanBePromotedToTrustNone` is free of nullability issues. Mark it `@Nullsafe(Nullsafe.Mode.LOCAL)` to prevent regressions.], Default_UsesLocal_CanBePromotedToTrustNone, codetoanalyze.java.nullsafe, issues: 0, curr_mode: "Default", promote_mode: "LocalTrustNone"
codetoanalyze/java/nullsafe/ModePromotions.java, Linters_dummy_method, 67, ERADICATE_META_CLASS_CAN_BE_NULLSAFE, no_bucket, ADVICE, [Congrats! `Default_UsesStrict_CanBePromotedToStrict` is free of nullability issues. Mark it `@Nullsafe(Nullsafe.Mode.LOCAL)` to prevent regressions.], Default_UsesStrict_CanBePromotedToStrict, codetoanalyze.java.nullsafe, issues: 0, curr_mode: "Default", promote_mode: "Strict"
codetoanalyze/java/nullsafe/ModePromotions.java, Linters_dummy_method, 78, ERADICATE_META_CLASS_IS_NULLSAFE, no_bucket, INFO, [], TrustSome_DoesNotUseTrusted_CanBePromotedToTrustNone, codetoanalyze.java.nullsafe, issues: 0, curr_mode: "LocalTrustSome", promote_mode: "LocalTrustNone"
codetoanalyze/java/nullsafe/ModePromotions.java, Linters_dummy_method, 87, ERADICATE_META_CLASS_IS_NULLSAFE, no_bucket, INFO, [], TrustSome_UsesTrusted_NoPromo, codetoanalyze.java.nullsafe, issues: 0, curr_mode: "LocalTrustSome"
codetoanalyze/java/nullsafe/ModePromotions.java, Linters_dummy_method, 96, ERADICATE_META_CLASS_IS_NULLSAFE, no_bucket, INFO, [], TrustSome_TrustToLocalIsNotNeeded_CanBePromotedToTrustNone, codetoanalyze.java.nullsafe, issues: 0, curr_mode: "LocalTrustSome", promote_mode: "LocalTrustNone"
codetoanalyze/java/nullsafe/ModePromotions.java, Linters_dummy_method, 105, ERADICATE_META_CLASS_IS_NULLSAFE, no_bucket, INFO, [], TrustSome_TrustStrictIsNotNeeded_CanBePromotedToStrict, codetoanalyze.java.nullsafe, issues: 0, curr_mode: "LocalTrustSome", promote_mode: "Strict"
codetoanalyze/java/nullsafe/ModePromotions.java, Linters_dummy_method, 112, ERADICATE_META_CLASS_IS_NULLSAFE, no_bucket, INFO, [], TrustNone_CanBePromotedToStrict, codetoanalyze.java.nullsafe, issues: 0, curr_mode: "LocalTrustNone", promote_mode: "Strict"
codetoanalyze/java/nullsafe/MyPreconditions.java, Linters_dummy_method, 11, ERADICATE_META_CLASS_CAN_BE_NULLSAFE, no_bucket, ADVICE, [Congrats! `MyPreconditions` is free of nullability issues. Mark it `@Nullsafe(Nullsafe.Mode.LOCAL)` to prevent regressions.], MyPreconditions, codetoanalyze.java.nullsafe, issues: 0, curr_mode: "Default", promote_mode: "Strict"
codetoanalyze/java/nullsafe/NestedFieldAccess.java, Linters_dummy_method, 12, ERADICATE_META_CLASS_NEEDS_IMPROVEMENT, no_bucket, INFO, [], NestedFieldAccess, codetoanalyze.java.nullsafe, issues: 15, curr_mode: "Default"
codetoanalyze/java/nullsafe/NestedFieldAccess.java, codetoanalyze.java.nullsafe.NestedFieldAccess$TestFunctionsIdempotent.chainOf0VsChainOf0ParamsMismatchIsBad():void, 2, ERADICATE_FIELD_NOT_NULLABLE, no_bucket, WARNING, [`dontAssignNull` is declared non-nullable but is assigned a nullable: call to nullable(...) at line 145.]
codetoanalyze/java/nullsafe/NestedFieldAccess.java, codetoanalyze.java.nullsafe.NestedFieldAccess$TestFunctionsIdempotent.chainOf0VsChainOf1IsBad():void, 2, ERADICATE_FIELD_NOT_NULLABLE, no_bucket, WARNING, [`dontAssignNull` is declared non-nullable but is assigned a nullable: call to nullable(...) at line 169.]
codetoanalyze/java/nullsafe/NestedFieldAccess.java, codetoanalyze.java.nullsafe.NestedFieldAccess$TestFunctionsIdempotent.chainOf1VsChainOf0IsBad():void, 2, ERADICATE_FIELD_NOT_NULLABLE, no_bucket, WARNING, [`dontAssignNull` is declared non-nullable but is assigned a nullable: call to nullable(...) at line 175.]
codetoanalyze/java/nullsafe/NestedFieldAccess.java, codetoanalyze.java.nullsafe.NestedFieldAccess$TestFunctionsIdempotent.chainOf1VsChainOf1ParamMismatchIsBad():void, 2, ERADICATE_FIELD_NOT_NULLABLE, no_bucket, WARNING, [`dontAssignNull` is declared non-nullable but is assigned a nullable: call to nullable(...) at line 187.]
codetoanalyze/java/nullsafe/NestedFieldAccess.java, codetoanalyze.java.nullsafe.NestedFieldAccess$TestFunctionsIdempotent.chainOf1VsChainOf2IsBad():void, 2, ERADICATE_FIELD_NOT_NULLABLE, no_bucket, WARNING, [`dontAssignNull` is declared non-nullable but is assigned a nullable: call to nullable(...) at line 199.]
codetoanalyze/java/nullsafe/NestedFieldAccess.java, codetoanalyze.java.nullsafe.NestedFieldAccess$TestFunctionsIdempotent.chainOf2VsChainOf1IsBad():void, 2, ERADICATE_FIELD_NOT_NULLABLE, no_bucket, WARNING, [`dontAssignNull` is declared non-nullable but is assigned a nullable: call to nullable(...) at line 205.]
codetoanalyze/java/nullsafe/NestedFieldAccess.java, codetoanalyze.java.nullsafe.NestedFieldAccess$TestFunctionsIdempotent.otherObjVsItselfIsOKParamsMismatchIsBAD(codetoanalyze.java.nullsafe.NestedFieldAccess$TestFunctionsIdempotent):void, 2, ERADICATE_FIELD_NOT_NULLABLE, no_bucket, WARNING, [`dontAssignNull` is declared non-nullable but is assigned a nullable: call to nullable(...) at line 157.]
codetoanalyze/java/nullsafe/NestedFieldAccess.java, codetoanalyze.java.nullsafe.NestedFieldAccess$TestFunctionsIdempotent.selfVsOtherObjectIsBAD(codetoanalyze.java.nullsafe.NestedFieldAccess$TestFunctionsIdempotent):void, 2, ERADICATE_FIELD_NOT_NULLABLE, no_bucket, WARNING, [`dontAssignNull` is declared non-nullable but is assigned a nullable: call to nullable(...) at line 163.]
codetoanalyze/java/nullsafe/NestedFieldAccess.java, codetoanalyze.java.nullsafe.NestedFieldAccess$TestNullableChains.deep_AccessWithoutNullCheckIsBad(codetoanalyze.java.nullsafe.NestedFieldAccess$CC):void, 2, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`cc.c.s` is nullable and is not locally checked for null when calling `length()`.]
codetoanalyze/java/nullsafe/NestedFieldAccess.java, codetoanalyze.java.nullsafe.NestedFieldAccess$TestNullableChains.field_AccessWithoutNullCheckIsBad():void, 1, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`NestedFieldAccess$TestNullableChains.s` is nullable and is not locally checked for null when calling `length()`.]
codetoanalyze/java/nullsafe/NestedFieldAccess.java, codetoanalyze.java.nullsafe.NestedFieldAccess$TestNullableChains.local_AccessWithoutNullCheckIsBad():void, 2, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`c.s` is nullable and is not locally checked for null when calling `length()`.]
codetoanalyze/java/nullsafe/NestedFieldAccess.java, codetoanalyze.java.nullsafe.NestedFieldAccess$TestNullableChains.nestedField_AccessWithoutNullCheckIsBad():void, 1, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`NestedFieldAccess$TestNullableChains.myc.s` is nullable and is not locally checked for null when calling `length()`.]
codetoanalyze/java/nullsafe/NestedFieldAccess.java, codetoanalyze.java.nullsafe.NestedFieldAccess$TestNullableChains.param_AccessWithoutNullCheckIsBad(codetoanalyze.java.nullsafe.NestedFieldAccess$C):void, 1, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`c.s` is nullable and is not locally checked for null when calling `length()`.]
codetoanalyze/java/nullsafe/NestedFieldAccess.java, codetoanalyze.java.nullsafe.NestedFieldAccess$TestNullableChains.veryDeep_AccessWithoutNullCheckIsBad(codetoanalyze.java.nullsafe.NestedFieldAccess$CCC):void, 2, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`ccc.cc.c.s` is nullable and is not locally checked for null when calling `length()`.]
codetoanalyze/java/nullsafe/NestedFieldAccess.java, codetoanalyze.java.nullsafe.NestedFieldAccess$TestNullableChains.veryDeep_IncompleteAccessViaOrEarlyReturnIsBad(codetoanalyze.java.nullsafe.NestedFieldAccess$CCC):void, 3, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`ccc.cc.c.s` is nullable and is not locally checked for null when calling `length()`.]
codetoanalyze/java/nullsafe/NoReuseUndefFunctionValues.java, Linters_dummy_method, 12, ERADICATE_META_CLASS_CAN_BE_NULLSAFE, no_bucket, ADVICE, [Congrats! `NoReuseUndefFunctionValues` is free of nullability issues. Mark it `@Nullsafe(Nullsafe.Mode.LOCAL)` to prevent regressions.], NoReuseUndefFunctionValues, codetoanalyze.java.nullsafe, issues: 0, curr_mode: "Default", promote_mode: "Strict"
codetoanalyze/java/nullsafe/NullFieldAccess.java, Linters_dummy_method, 12, ERADICATE_META_CLASS_NEEDS_IMPROVEMENT, no_bucket, INFO, [], NullFieldAccess, codetoanalyze.java.nullsafe, issues: 5, curr_mode: "Default"
codetoanalyze/java/nullsafe/NullFieldAccess.java, codetoanalyze.java.nullsafe.NullFieldAccess.<init>(), 0, ERADICATE_FIELD_OVER_ANNOTATED, no_bucket, ADVICE, [Field `NullFieldAccess.nullableArray` is always initialized in the constructor but is declared `@Nullable`]
codetoanalyze/java/nullsafe/NullFieldAccess.java, codetoanalyze.java.nullsafe.NullFieldAccess.<init>(), 0, ERADICATE_FIELD_OVER_ANNOTATED, no_bucket, ADVICE, [Field `NullFieldAccess.nullable` is always initialized in the constructor but is declared `@Nullable`]
codetoanalyze/java/nullsafe/NullFieldAccess.java, codetoanalyze.java.nullsafe.NullFieldAccess.testArray():void, 1, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [Array `NullFieldAccess.nullableArray` is nullable and is not locally checked for null when accessing its length.]
codetoanalyze/java/nullsafe/NullFieldAccess.java, codetoanalyze.java.nullsafe.NullFieldAccess.testArray():void, 2, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [Array `NullFieldAccess.nullableArray` is nullable and is not locally checked for null when accessing at index `0`.]
codetoanalyze/java/nullsafe/NullFieldAccess.java, codetoanalyze.java.nullsafe.NullFieldAccess.testInterface():void, 2, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`bad` is nullable and is not locally checked for null when calling `toString()`: field nullable at line 52.]
codetoanalyze/java/nullsafe/NullFieldAccess.java, codetoanalyze.java.nullsafe.NullFieldAccess.testNonStaticFields():void, 2, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`bad` is nullable and is not locally checked for null when calling `toString()`: field nullable at line 36.]
codetoanalyze/java/nullsafe/NullFieldAccess.java, codetoanalyze.java.nullsafe.NullFieldAccess.testStatic():void, 2, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`bad` is nullable and is not locally checked for null when calling `toString()`: field nullableStatic at line 44.]
codetoanalyze/java/nullsafe/NullMethodCall.java, Linters_dummy_method, 22, ERADICATE_META_CLASS_NEEDS_IMPROVEMENT, no_bucket, INFO, [], NullMethodCall, codetoanalyze.java.nullsafe, issues: 23, curr_mode: "Default"
codetoanalyze/java/nullsafe/NullMethodCall.java, codetoanalyze.java.nullsafe.NullMethodCall$Inner.outerField():int, 2, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`s` is nullable and is not locally checked for null when calling `length()`: field fld at line 69.]
codetoanalyze/java/nullsafe/NullMethodCall.java, codetoanalyze.java.nullsafe.NullMethodCall$Inner.outerPrivateField():int, 2, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`s` is nullable and is not locally checked for null when calling `length()`: field pfld at line 80.]
codetoanalyze/java/nullsafe/NullMethodCall.java, codetoanalyze.java.nullsafe.NullMethodCall.FP_propagatesNonNullAfterComparisonFieldOkay(java.lang.Object):void, 2, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`NullMethodCall.nullableField` is nullable and is not locally checked for null when calling `toString()`.]
codetoanalyze/java/nullsafe/NullMethodCall.java, codetoanalyze.java.nullsafe.NullMethodCall.FP_propagatesNonNullAfterComparisonParameterOkay(java.lang.Object,java.lang.Object):void, 3, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`nullableParameter` is nullable and is not locally checked for null when calling `toString()`.]
codetoanalyze/java/nullsafe/NullMethodCall.java, codetoanalyze.java.nullsafe.NullMethodCall.callOnNull():void, 2, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [NullPointerException will be thrown at this line! `s` is `null` and is dereferenced via calling `length()`: null constant at line 25.]
codetoanalyze/java/nullsafe/NullMethodCall.java, codetoanalyze.java.nullsafe.NullMethodCall.callingSeverSideNullableGetter(codetoanalyze.java.nullsafe.ServerSideDeserializer):java.lang.String, 1, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`deserializer.nullableGetter()` is nullable and is not locally checked for null when calling `toString()`.]
codetoanalyze/java/nullsafe/NullMethodCall.java, codetoanalyze.java.nullsafe.NullMethodCall.nullMethodCallWithAlarmManager(android.app.AlarmManager,android.app.PendingIntent):void, 1, ERADICATE_PARAMETER_NOT_NULLABLE, no_bucket, WARNING, [`AlarmManager.cancel(...)`: parameter #1 is declared non-nullable (according to nullsafe internal models) but the argument `intent` is nullable.]
codetoanalyze/java/nullsafe/NullMethodCall.java, codetoanalyze.java.nullsafe.NullMethodCall.nullabilityNotPreservedAfterAssignment():void, 3, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`t` is nullable and is not locally checked for null when calling `toString()`: call to getNullable() at line 340.]
codetoanalyze/java/nullsafe/NullMethodCall.java, codetoanalyze.java.nullsafe.NullMethodCall.nullabilityStoredInBooleanFP():void, 3, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`getNullable()` is nullable and is not locally checked for null when calling `toString()`.]
codetoanalyze/java/nullsafe/NullMethodCall.java, codetoanalyze.java.nullsafe.NullMethodCall.testExceptionPerInstruction(int):void, 6, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [NullPointerException will be thrown at this line! `s` is `null` and is dereferenced via calling `length()`: null constant at line 181.]
codetoanalyze/java/nullsafe/NullMethodCall.java, codetoanalyze.java.nullsafe.NullMethodCall.testFieldAssignmentIfThenElse(java.lang.String):void, 2, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`s` is nullable and is not locally checked for null when calling `length()`: null constant at line 172.]
codetoanalyze/java/nullsafe/NullMethodCall.java, codetoanalyze.java.nullsafe.NullMethodCall.testMapGetBad(java.util.Map,java.util.HashMap,java.util.concurrent.ConcurrentHashMap):void, 2, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`m.get(...)` is nullable and is not locally checked for null when calling `toString()`: call to Map.get(...) at line 260 (nullable according to nullsafe internal models).]
codetoanalyze/java/nullsafe/NullMethodCall.java, codetoanalyze.java.nullsafe.NullMethodCall.testMapGetBad(java.util.Map,java.util.HashMap,java.util.concurrent.ConcurrentHashMap):void, 3, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`hm.get(...)` is nullable and is not locally checked for null when calling `toString()`: call to HashMap.get(...) at line 261 (nullable according to nullsafe internal models).]
codetoanalyze/java/nullsafe/NullMethodCall.java, codetoanalyze.java.nullsafe.NullMethodCall.testMapGetBad(java.util.Map,java.util.HashMap,java.util.concurrent.ConcurrentHashMap):void, 4, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`chm.get(...)` is nullable and is not locally checked for null when calling `toString()`: call to ConcurrentHashMap.get(...) at line 262 (nullable according to nullsafe internal models).]
codetoanalyze/java/nullsafe/NullMethodCall.java, codetoanalyze.java.nullsafe.NullMethodCall.testMapRemoveBad(java.util.Map,java.util.HashMap,java.util.concurrent.ConcurrentHashMap):void, 2, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`m.remove(...)` is nullable and is not locally checked for null when calling `toString()`: call to Map.remove(...) at line 267 (nullable according to nullsafe internal models).]
codetoanalyze/java/nullsafe/NullMethodCall.java, codetoanalyze.java.nullsafe.NullMethodCall.testMapRemoveBad(java.util.Map,java.util.HashMap,java.util.concurrent.ConcurrentHashMap):void, 3, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`hm.remove(...)` is nullable and is not locally checked for null when calling `toString()`: call to HashMap.remove(...) at line 268 (nullable according to nullsafe internal models).]
codetoanalyze/java/nullsafe/NullMethodCall.java, codetoanalyze.java.nullsafe.NullMethodCall.testMapRemoveBad(java.util.Map,java.util.HashMap,java.util.concurrent.ConcurrentHashMap):void, 4, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`chm.remove(...)` is nullable and is not locally checked for null when calling `toString()`: call to ConcurrentHashMap.remove(...) at line 269 (nullable according to nullsafe internal models).]
codetoanalyze/java/nullsafe/NullMethodCall.java, codetoanalyze.java.nullsafe.NullMethodCall.testNotDetectingInvariantFP(java.lang.Object,java.lang.Object):java.lang.String, 4, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`object2` is nullable and is not locally checked for null when calling `toString()`.]
codetoanalyze/java/nullsafe/NullMethodCall.java, codetoanalyze.java.nullsafe.NullMethodCall.testPathGetParent():java.lang.String, 1, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`get(...).getParent()` is nullable and is not locally checked for null when calling `toString()`: call to Path.getParent() at line 360 (nullable according to nullsafe internal models).]
codetoanalyze/java/nullsafe/NullMethodCall.java, codetoanalyze.java.nullsafe.NullMethodCall.testSystemGetPropertyReturn():void, 2, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`s` is nullable and is not locally checked for null when calling `length()`: call to System.getProperty(...) at line 235 (nullable according to nullsafe internal models).]
codetoanalyze/java/nullsafe/NullMethodCall.java, codetoanalyze.java.nullsafe.NullMethodCall.testSystemGetenvBad():int, 2, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`envValue` is nullable and is not locally checked for null when calling `length()`: call to System.getenv(...) at line 240 (nullable according to nullsafe internal models).]
codetoanalyze/java/nullsafe/NullMethodCall.java, codetoanalyze.java.nullsafe.NullMethodCall.withConditionalAssignemnt(codetoanalyze.java.nullsafe.NullMethodCall$AnotherI,boolean,java.lang.Object,java.lang.Object):void, 2, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`i` is nullable and is not locally checked for null when calling `withObjectParameter(...)`.]
codetoanalyze/java/nullsafe/NullMethodCall.java, codetoanalyze.java.nullsafe.NullMethodCall.withConjuction(codetoanalyze.java.nullsafe.NullMethodCall$AnotherI,boolean,boolean):void, 1, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`i` is nullable and is not locally checked for null when calling `withBooleanParameter(...)`.]
codetoanalyze/java/nullsafe/NullsafeMode.java, Linters_dummy_method, 16, ERADICATE_META_CLASS_NEEDS_IMPROVEMENT, no_bucket, INFO, [], NullsafeMode, codetoanalyze.java.nullsafe, issues: 13, curr_mode: "Default"
codetoanalyze/java/nullsafe/NullsafeMode.java, codetoanalyze.java.nullsafe.NullsafeMode$NullsafeWithStrictMode.BAD_returnFromNonStrict():java.lang.String, 1, ERADICATE_UNCHECKED_USAGE_IN_NULLSAFE, no_bucket, ERROR, [`NullsafeMode$VariousMethods.returnVal()`: `@NullsafeStrict` mode prohibits using values coming from non-strict classes without a check. Result of this call is used at line 174. Either add a local check for null or assertion, or make `NullsafeMode$VariousMethods` nullsafe strict.]
codetoanalyze/java/nullsafe/NullsafeMode.java, codetoanalyze.java.nullsafe.NullsafeMode$StrictNullsafe.BAD_dereferenceNotAnnotatedThirdParty():void, 1, ERADICATE_UNVETTED_THIRD_PARTY_IN_NULLSAFE, no_bucket, ERROR, [`ThirdPartyTestClass.returnUnspecified()`: `@NullsafeStrict` mode prohibits using values coming from not vetted third party methods without a check. Result of this call is used at line 218. Either add a local check for null or assertion, or add the correct signature to nullsafe/third-party-signatures/some.test.pckg.sig.]
codetoanalyze/java/nullsafe/NullsafeMode.java, codetoanalyze.java.nullsafe.NullsafeMode$StrictNullsafe.BAD_passThirdPartyToUnchecked():codetoanalyze.java.nullsafe.NullsafeMode$UncheckedParams, 1, ERADICATE_UNVETTED_THIRD_PARTY_IN_NULLSAFE, no_bucket, ERROR, [`ThirdPartyTestClass.getUncheckedLong(...)`: `@NullsafeStrict` mode prohibits using values coming from not vetted third party methods without a check. Result of this call is used at line 214. Either add a local check for null or assertion, or add the correct signature to nullsafe/third-party-signatures/some.test.pckg.sig.]
codetoanalyze/java/nullsafe/NullsafeMode.java, codetoanalyze.java.nullsafe.NullsafeMode$StrictNullsafe.BAD_returnFromNonNullsafe():java.lang.String, 1, ERADICATE_UNCHECKED_USAGE_IN_NULLSAFE, no_bucket, ERROR, [`NullsafeMode$NonNullsafe.returnVal()`: `@NullsafeStrict` mode prohibits using values coming from non-strict classes without a check. Result of this call is used at line 197. Either add a local check for null or assertion, or make `NullsafeMode$NonNullsafe` nullsafe strict.]
codetoanalyze/java/nullsafe/NullsafeMode.java, codetoanalyze.java.nullsafe.NullsafeMode$TrustAllNullsafe.BAD_passThirdPartyToUnchecked():codetoanalyze.java.nullsafe.NullsafeMode$UncheckedParams, 1, ERADICATE_UNVETTED_THIRD_PARTY_IN_NULLSAFE, no_bucket, ERROR, [`ThirdPartyTestClass.getUncheckedLong(...)`: `@NullsafeLocal(trust=all)` mode prohibits using values coming from not vetted third party methods without a check. Result of this call is used at line 113. Either add a local check for null or assertion, or add the correct signature to nullsafe/third-party-signatures/some.test.pckg.sig.]
codetoanalyze/java/nullsafe/NullsafeMode.java, codetoanalyze.java.nullsafe.NullsafeMode$TrustAllNullsafe.BAD_returnFromUnvettedThirdParty():java.lang.String, 1, ERADICATE_UNVETTED_THIRD_PARTY_IN_NULLSAFE, no_bucket, ERROR, [`ThirdPartyTestClass.returnUnspecified()`: `@NullsafeLocal(trust=all)` mode prohibits using values coming from not vetted third party methods without a check. Result of this call is used at line 92. Either add a local check for null or assertion, or add the correct signature to nullsafe/third-party-signatures/some.test.pckg.sig.]
codetoanalyze/java/nullsafe/NullsafeMode.java, codetoanalyze.java.nullsafe.NullsafeMode$TrustAllNullsafe.BAD_returnNonNullableFieldFromThirdParty():java.lang.String, 1, ERADICATE_UNVETTED_THIRD_PARTY_IN_NULLSAFE, no_bucket, ERROR, [`ThirdPartyTestClass.nonNullableField`: `@NullsafeLocal(trust=all)` mode prohibits using values coming from third-party classes without a check. This field is used at line 100. Either add a local check for null or assertion, or access `nonNullableField` via a nullsafe getter.]
codetoanalyze/java/nullsafe/NullsafeMode.java, codetoanalyze.java.nullsafe.NullsafeMode$TrustAllNullsafe.BAD_returnNullFromNonNulsafe():java.lang.String, 0, ERADICATE_RETURN_NOT_NULLABLE, no_bucket, ERROR, [`BAD_returnNullFromNonNulsafe()`: return type is declared non-nullable but the method returns a nullable value: call to returnNull() at line 89.]
codetoanalyze/java/nullsafe/NullsafeMode.java, codetoanalyze.java.nullsafe.NullsafeMode$TrustAllNullsafe.BAD_returnNullableFieldFromThirdParty():java.lang.String, 0, ERADICATE_RETURN_NOT_NULLABLE, no_bucket, ERROR, [`BAD_returnNullableFieldFromThirdParty()`: return type is declared non-nullable but the method returns a nullable value: field nullableField at line 97.]
codetoanalyze/java/nullsafe/NullsafeMode.java, codetoanalyze.java.nullsafe.NullsafeMode$TrustNoneNullsafe.BAD_returnFromNonNullsafe():java.lang.String, 1, ERADICATE_UNCHECKED_USAGE_IN_NULLSAFE, no_bucket, ERROR, [`NullsafeMode$NonNullsafe.returnVal()`: `@NullsafeLocal(trust=none)` mode prohibits using values coming from non-nullsafe classes without a check. Result of this call is used at line 154. Either add a local check for null or assertion, or make `NullsafeMode$NonNullsafe` @Nullsafe (or add it to trust list).]
codetoanalyze/java/nullsafe/NullsafeMode.java, codetoanalyze.java.nullsafe.NullsafeMode$TrustSomeNullsafe.BAD_returnFromUntrustedNonNullsafe():java.lang.String, 1, ERADICATE_UNCHECKED_USAGE_IN_NULLSAFE, no_bucket, ERROR, [`NullsafeMode$VariousMethods.returnVal()`: `@NullsafeLocal(trust=selected)` mode prohibits using values coming from non-nullsafe classes without a check. Result of this call is used at line 134. Either add a local check for null or assertion, or make `NullsafeMode$VariousMethods` @Nullsafe (or add it to trust list).]
codetoanalyze/java/nullsafe/NullsafeMode.java, codetoanalyze.java.nullsafe.NullsafeMode$TrustSomeNullsafe.BAD_returnNullFromNonNulsafe():java.lang.String, 0, ERADICATE_RETURN_NOT_NULLABLE, no_bucket, ERROR, [`BAD_returnNullFromNonNulsafe()`: return type is declared non-nullable but the method returns a nullable value: call to returnNull() at line 144.]
codetoanalyze/java/nullsafe/NullsafeMode.java, codetoanalyze.java.nullsafe.NullsafeMode$TrustSomeNullsafe.FP_OK_accessFieldFromNonNullsafe():java.lang.String, 1, ERADICATE_UNCHECKED_USAGE_IN_NULLSAFE, no_bucket, ERROR, [`NullsafeMode$NonNullsafe.valField`: `@NullsafeLocal(trust=selected)` mode prohibits using values coming from non-nullsafe classes without a check. This field is used at line 147. Either add a local check for null or assertion, or make `NullsafeMode$NonNullsafe` @Nullsafe (or add it to trust list).]
codetoanalyze/java/nullsafe/NullsafeMode.java, codetoanalyze.java.nullsafe.NullsafeMode$TrustSomeNullsafe.OK_returnFromUntrustedNonNullsafeAsNullable():java.lang.String, 0, ERADICATE_RETURN_OVER_ANNOTATED, no_bucket, ADVICE, [Method `OK_returnFromUntrustedNonNullsafeAsNullable()` is annotated with `@Nullable` but never returns null.]
codetoanalyze/java/nullsafe/NullsafeModeNestedClasses.java, Linters_dummy_method, 14, ERADICATE_META_CLASS_NEEDS_IMPROVEMENT, no_bucket, INFO, [], NullsafeLocal, codetoanalyze.java.nullsafe, issues: 5, curr_mode: "LocalTrustAll"
codetoanalyze/java/nullsafe/NullsafeModeNestedClasses.java, Linters_dummy_method, 49, ERADICATE_REDUNDANT_NESTED_CLASS_ANNOTATION, no_bucket, ADVICE, [`NullsafeLocal$NestedExplicitLocal`: the same @Nullsafe mode is already specified in the outer class, so this annotation can be removed.], NullsafeLocal$NestedExplicitLocal, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/NullsafeModeNestedClasses.java, Linters_dummy_method, 57, ERADICATE_META_CLASS_NEEDS_IMPROVEMENT, no_bucket, INFO, [], NullsafeStrict, codetoanalyze.java.nullsafe, issues: 4, curr_mode: "Strict"
codetoanalyze/java/nullsafe/NullsafeModeNestedClasses.java, Linters_dummy_method, 71, ERADICATE_BAD_NESTED_CLASS_ANNOTATION, no_bucket, WARNING, [`NullsafeStrict$Nested$DeeplyNestedLocalIsStillStrict`: nested classes are disallowed to weaken @Nullsafe mode specified in the outer class. This annotation will be ignored.], NullsafeStrict$Nested$DeeplyNestedLocalIsStillStrict, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/NullsafeModeNestedClasses.java, Linters_dummy_method, 80, ERADICATE_BAD_NESTED_CLASS_ANNOTATION, no_bucket, WARNING, [`NullsafeStrict$NestedLocalIsStillStrict`: nested classes are disallowed to weaken @Nullsafe mode specified in the outer class. This annotation will be ignored.], NullsafeStrict$NestedLocalIsStillStrict, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/NullsafeModeNestedClasses.java, Linters_dummy_method, 87, ERADICATE_META_CLASS_NEEDS_IMPROVEMENT, no_bucket, INFO, [], Default, codetoanalyze.java.nullsafe, issues: 2, curr_mode: "Default"
codetoanalyze/java/nullsafe/NullsafeModeNestedClasses.java, Linters_dummy_method, 114, ERADICATE_META_CLASS_CAN_BE_NULLSAFE, no_bucket, ADVICE, [Congrats! `A` is free of nullability issues. Mark it `@Nullsafe(Nullsafe.Mode.LOCAL)` to prevent regressions.], A, codetoanalyze.java.nullsafe, issues: 0, curr_mode: "Default", promote_mode: "Strict"
codetoanalyze/java/nullsafe/NullsafeModeNestedClasses.java, Linters_dummy_method, 120, ERADICATE_META_CLASS_CAN_BE_NULLSAFE, no_bucket, ADVICE, [Congrats! `B` is free of nullability issues. Mark it `@Nullsafe(Nullsafe.Mode.LOCAL)` to prevent regressions.], B, codetoanalyze.java.nullsafe, issues: 0, curr_mode: "Default", promote_mode: "Strict"
codetoanalyze/java/nullsafe/NullsafeModeNestedClasses.java, Linters_dummy_method, 122, ERADICATE_META_CLASS_CAN_BE_NULLSAFE, no_bucket, ADVICE, [Congrats! `C` is free of nullability issues. Mark it `@Nullsafe(Nullsafe.Mode.LOCAL)` to prevent regressions.], C, codetoanalyze.java.nullsafe, issues: 0, curr_mode: "Default", promote_mode: "Strict"
codetoanalyze/java/nullsafe/NullsafeModeNestedClasses.java, Linters_dummy_method, 129, ERADICATE_META_CLASS_NEEDS_IMPROVEMENT, no_bucket, INFO, [], TrustSome, codetoanalyze.java.nullsafe, issues: 4, curr_mode: "LocalTrustSome"
codetoanalyze/java/nullsafe/NullsafeModeNestedClasses.java, Linters_dummy_method, 161, ERADICATE_BAD_NESTED_CLASS_ANNOTATION, no_bucket, WARNING, [Nested classes cannot add classes to trust list if they are not in the outer class trust list. Remove `C` from trust list.], TrustSome$CanNotAddToTrustList, codetoanalyze.java.nullsafe
codetoanalyze/java/nullsafe/NullsafeModeNestedClasses.java, codetoanalyze.java.nullsafe.Default$NestedLocal$DeeplyNestedStrict.returningDefaultNotNullIsError():java.lang.String, 1, ERADICATE_UNCHECKED_USAGE_IN_NULLSAFE, no_bucket, ERROR, [`Default.getString()`: `@NullsafeStrict` mode prohibits using values coming from non-strict classes without a check. Result of this call is used at line 107. Either add a local check for null or assertion, or make `Default` nullsafe strict.]
codetoanalyze/java/nullsafe/NullsafeModeNestedClasses.java, codetoanalyze.java.nullsafe.Default$NestedLocal.shouldBeNullsafeModeError():java.lang.String, 0, ERADICATE_RETURN_NOT_NULLABLE, no_bucket, ERROR, [`shouldBeNullsafeModeError()`: return type is declared non-nullable but the method returns `null`: null constant at line 96.]
codetoanalyze/java/nullsafe/NullsafeModeNestedClasses.java, codetoanalyze.java.nullsafe.NullsafeLocal$Nested$DeeplyNested.shouldBeNullsafeModeError():java.lang.String, 0, ERADICATE_RETURN_NOT_NULLABLE, no_bucket, ERROR, [`shouldBeNullsafeModeError()`: return type is declared non-nullable but the method returns `null`: null constant at line 29.]
codetoanalyze/java/nullsafe/NullsafeModeNestedClasses.java, codetoanalyze.java.nullsafe.NullsafeLocal$Nested.shouldBeNullsafeModeError():java.lang.String, 0, ERADICATE_RETURN_NOT_NULLABLE, no_bucket, ERROR, [`shouldBeNullsafeModeError()`: return type is declared non-nullable but the method returns `null`: null constant at line 23.]
codetoanalyze/java/nullsafe/NullsafeModeNestedClasses.java, codetoanalyze.java.nullsafe.NullsafeLocal$NestedExplicitLocal.shouldBeNullsafeModeError():java.lang.String, 0, ERADICATE_RETURN_NOT_NULLABLE, no_bucket, ERROR, [`shouldBeNullsafeModeError()`: return type is declared non-nullable but the method returns `null`: null constant at line 51.]
codetoanalyze/java/nullsafe/NullsafeModeNestedClasses.java, codetoanalyze.java.nullsafe.NullsafeLocal$NestedStrict.returningDefaultNotNullIsError():java.lang.String, 1, ERADICATE_UNCHECKED_USAGE_IN_NULLSAFE, no_bucket, ERROR, [`Default.getString()`: `@NullsafeStrict` mode prohibits using values coming from non-strict classes without a check. Result of this call is used at line 42. Either add a local check for null or assertion, or make `Default` nullsafe strict.]
codetoanalyze/java/nullsafe/NullsafeModeNestedClasses.java, codetoanalyze.java.nullsafe.NullsafeLocal.shouldBeNullsafeModeError():java.lang.String, 0, ERADICATE_RETURN_NOT_NULLABLE, no_bucket, ERROR, [`shouldBeNullsafeModeError()`: return type is declared non-nullable but the method returns `null`: null constant at line 17.]
codetoanalyze/java/nullsafe/NullsafeModeNestedClasses.java, codetoanalyze.java.nullsafe.NullsafeStrict$Nested$DeeplyNestedLocalIsStillStrict.returningDefaultNotNullIsError():java.lang.String, 1, ERADICATE_UNCHECKED_USAGE_IN_NULLSAFE, no_bucket, ERROR, [`Default.getString()`: `@NullsafeStrict` mode prohibits using values coming from non-strict classes without a check. Result of this call is used at line 72. Either add a local check for null or assertion, or make `Default` nullsafe strict.]
codetoanalyze/java/nullsafe/NullsafeModeNestedClasses.java, codetoanalyze.java.nullsafe.NullsafeStrict$Nested.returningDefaultNotNullIsError():java.lang.String, 1, ERADICATE_UNCHECKED_USAGE_IN_NULLSAFE, no_bucket, ERROR, [`Default.getString()`: `@NullsafeStrict` mode prohibits using values coming from non-strict classes without a check. Result of this call is used at line 64. Either add a local check for null or assertion, or make `Default` nullsafe strict.]
codetoanalyze/java/nullsafe/NullsafeModeNestedClasses.java, codetoanalyze.java.nullsafe.NullsafeStrict$NestedLocalIsStillStrict.returningDefaultNotNullIsError():java.lang.String, 1, ERADICATE_UNCHECKED_USAGE_IN_NULLSAFE, no_bucket, ERROR, [`Default.getString()`: `@NullsafeStrict` mode prohibits using values coming from non-strict classes without a check. Result of this call is used at line 81. Either add a local check for null or assertion, or make `Default` nullsafe strict.]
codetoanalyze/java/nullsafe/NullsafeModeNestedClasses.java, codetoanalyze.java.nullsafe.NullsafeStrict.returningDefaultNotNullIsError():java.lang.String, 1, ERADICATE_UNCHECKED_USAGE_IN_NULLSAFE, no_bucket, ERROR, [`Default.getString()`: `@NullsafeStrict` mode prohibits using values coming from non-strict classes without a check. Result of this call is used at line 58. Either add a local check for null or assertion, or make `Default` nullsafe strict.]
codetoanalyze/java/nullsafe/NullsafeModeNestedClasses.java, codetoanalyze.java.nullsafe.TrustSome$CanNotAddToTrustList.stillDontTrustC_BAD():java.lang.String, 1, ERADICATE_UNCHECKED_USAGE_IN_NULLSAFE, no_bucket, ERROR, [`C.getString()`: `@NullsafeLocal(trust=selected)` mode prohibits using values coming from non-nullsafe classes without a check. Result of this call is used at line 162. Either add a local check for null or assertion, or make `C` @Nullsafe (or add it to trust list).]
codetoanalyze/java/nullsafe/NullsafeModeNestedClasses.java, codetoanalyze.java.nullsafe.TrustSome$CanRemoveFromTrustList.dontTrustA_BAD():java.lang.String, 1, ERADICATE_UNCHECKED_USAGE_IN_NULLSAFE, no_bucket, ERROR, [`A.getString()`: `@NullsafeLocal(trust=selected)` mode prohibits using values coming from non-nullsafe classes without a check. Result of this call is used at line 153. Either add a local check for null or assertion, or make `A` @Nullsafe (or add it to trust list).]
codetoanalyze/java/nullsafe/NullsafeModeNestedClasses.java, codetoanalyze.java.nullsafe.TrustSome$NotAnnotatedNested.dontTrustC_Bad():java.lang.String, 1, ERADICATE_UNCHECKED_USAGE_IN_NULLSAFE, no_bucket, ERROR, [`C.getString()`: `@NullsafeLocal(trust=selected)` mode prohibits using values coming from non-nullsafe classes without a check. Result of this call is used at line 145. Either add a local check for null or assertion, or make `C` @Nullsafe (or add it to trust list).]
codetoanalyze/java/nullsafe/NullsafeModeNestedClasses.java, codetoanalyze.java.nullsafe.TrustSome.dontTrustC_Bad():java.lang.String, 1, ERADICATE_UNCHECKED_USAGE_IN_NULLSAFE, no_bucket, ERROR, [`C.getString()`: `@NullsafeLocal(trust=selected)` mode prohibits using values coming from non-nullsafe classes without a check. Result of this call is used at line 135. Either add a local check for null or assertion, or make `C` @Nullsafe (or add it to trust list).]
codetoanalyze/java/nullsafe/ParameterNotNullable.java, Linters_dummy_method, 20, ERADICATE_META_CLASS_NEEDS_IMPROVEMENT, no_bucket, INFO, [], ParameterNotNullable, codetoanalyze.java.nullsafe, issues: 38, curr_mode: "Default"
codetoanalyze/java/nullsafe/ParameterNotNullable.java, Linters_dummy_method, 195, ERADICATE_META_CLASS_CAN_BE_NULLSAFE, no_bucket, ADVICE, [Congrats! `SomeClass` is free of nullability issues. Mark it `@Nullsafe(Nullsafe.Mode.LOCAL)` to prevent regressions.], SomeClass, codetoanalyze.java.nullsafe, issues: 0, curr_mode: "Default", promote_mode: "Strict"
codetoanalyze/java/nullsafe/ParameterNotNullable.java, codetoanalyze.java.nullsafe.ParameterNotNullable$ConstructorCall.<init>(codetoanalyze.java.nullsafe.ParameterNotNullable,int), 0, ERADICATE_PARAMETER_NOT_NULLABLE, no_bucket, WARNING, [`ParameterNotNullable$ConstructorCall(...)`: parameter #2(`s`) is declared non-nullable but the argument is `null`.]
codetoanalyze/java/nullsafe/ParameterNotNullable.java, codetoanalyze.java.nullsafe.ParameterNotNullable.callNull():void, 2, ERADICATE_PARAMETER_NOT_NULLABLE, no_bucket, WARNING, [`ParameterNotNullable.test(...)`: parameter #1(`s`) is declared non-nullable but the argument `s` is `null`: null constant at line 39.]
codetoanalyze/java/nullsafe/ParameterNotNullable.java, codetoanalyze.java.nullsafe.ParameterNotNullable.callNullable(java.lang.String):void, 1, ERADICATE_PARAMETER_NOT_NULLABLE, no_bucket, WARNING, [`ParameterNotNullable.test(...)`: parameter #1(`s`) is declared non-nullable but the argument `s` is nullable.]
codetoanalyze/java/nullsafe/ParameterNotNullable.java, codetoanalyze.java.nullsafe.ParameterNotNullable.callWithConditionalAssignment(java.lang.Object,boolean):void, 1, ERADICATE_PARAMETER_NOT_NULLABLE, no_bucket, WARNING, [`ParameterNotNullable.doesNotAcceptNullableFirstParameter(...)`: parameter #1(`object`) is declared non-nullable but the argument `object` is nullable: null constant at line 116.]
codetoanalyze/java/nullsafe/ParameterNotNullable.java, codetoanalyze.java.nullsafe.ParameterNotNullable.callWithNullableFirstParameter(boolean,boolean):void, 1, ERADICATE_PARAMETER_NOT_NULLABLE, no_bucket, WARNING, [`ParameterNotNullable.doesNotAcceptNullableFirstParameter(...)`: parameter #1(`object`) is declared non-nullable but the argument `formal parameter object` is `null`: null constant at line 112.]
codetoanalyze/java/nullsafe/ParameterNotNullable.java, codetoanalyze.java.nullsafe.ParameterNotNullable.testClassGetResourceArgument(java.lang.Class):java.net.URL, 1, ERADICATE_PARAMETER_NOT_NULLABLE, no_bucket, WARNING, [`Class.getResource(...)`: parameter #1 is declared non-nullable (according to nullsafe internal models) but the argument is `null`.]
codetoanalyze/java/nullsafe/ParameterNotNullable.java, codetoanalyze.java.nullsafe.ParameterNotNullable.testImmutableListCopyOfNotNullArguments():void, 6, ERADICATE_PARAMETER_NOT_NULLABLE, no_bucket, WARNING, [`ImmutableList.copyOf(...)`: parameter #1 is declared non-nullable (according to nullsafe internal models) but the argument `nullIterable` is `null`: null constant at line 131.]
codetoanalyze/java/nullsafe/ParameterNotNullable.java, codetoanalyze.java.nullsafe.ParameterNotNullable.testImmutableListCopyOfNotNullArguments():void, 7, ERADICATE_PARAMETER_NOT_NULLABLE, no_bucket, WARNING, [`ImmutableList.copyOf(...)`: parameter #1 is declared non-nullable (according to nullsafe internal models) but the argument `nullIterator` is `null`: null constant at line 132.]
codetoanalyze/java/nullsafe/ParameterNotNullable.java, codetoanalyze.java.nullsafe.ParameterNotNullable.testImmutableListCopyOfNotNullArguments():void, 8, ERADICATE_PARAMETER_NOT_NULLABLE, no_bucket, WARNING, [`ImmutableList.copyOf(...)`: parameter #1 is declared non-nullable (according to nullsafe internal models) but the argument `nullCollection` is `null`: null constant at line 133.]
codetoanalyze/java/nullsafe/ParameterNotNullable.java, codetoanalyze.java.nullsafe.ParameterNotNullable.testImmutableListOfnotNullArguments():void, 4, ERADICATE_PARAMETER_NOT_NULLABLE, no_bucket, WARNING, [`ImmutableList.of(...)`: parameter #1 is declared non-nullable (according to nullsafe internal models) but the argument is `null`.]
codetoanalyze/java/nullsafe/ParameterNotNullable.java, codetoanalyze.java.nullsafe.ParameterNotNullable.testImmutableListOfnotNullArguments():void, 5, ERADICATE_PARAMETER_NOT_NULLABLE, no_bucket, WARNING, [`ImmutableList.of(...)`: parameter #2 is declared non-nullable (according to nullsafe internal models) but the argument is `null`.]
codetoanalyze/java/nullsafe/ParameterNotNullable.java, codetoanalyze.java.nullsafe.ParameterNotNullable.testImmutableListOfnotNullArguments():void, 5, ERADICATE_PARAMETER_NOT_NULLABLE, no_bucket, WARNING, [`ImmutableList.of(...)`: parameter #1 is declared non-nullable (according to nullsafe internal models) but the argument is `null`.]
codetoanalyze/java/nullsafe/ParameterNotNullable.java, codetoanalyze.java.nullsafe.ParameterNotNullable.testImmutableListOfnotNullArguments():void, 7, ERADICATE_PARAMETER_NOT_NULLABLE, no_bucket, WARNING, [`ImmutableList.of(...)`: parameter #2 is declared non-nullable (according to nullsafe internal models) but the argument is `null`.]
codetoanalyze/java/nullsafe/ParameterNotNullable.java, codetoanalyze.java.nullsafe.ParameterNotNullable.testImmutableListSortedCopyOfNotNullArguments():void, 1, ERADICATE_PARAMETER_NOT_NULLABLE, no_bucket, WARNING, [`ImmutableList.sortedCopyOf(...)`: parameter #1 is declared non-nullable (according to nullsafe internal models) but the argument is `null`.]
codetoanalyze/java/nullsafe/ParameterNotNullable.java, codetoanalyze.java.nullsafe.ParameterNotNullable.testImmutableListSortedCopyOfNotNullArguments():void, 1, ERADICATE_PARAMETER_NOT_NULLABLE, no_bucket, WARNING, [`ImmutableList.sortedCopyOf(...)`: parameter #2 is declared non-nullable (according to nullsafe internal models) but the argument is `null`.]
codetoanalyze/java/nullsafe/ParameterNotNullable.java, codetoanalyze.java.nullsafe.ParameterNotNullable.testImmutableMapCopyOfNotNullArguments():void, 5, ERADICATE_PARAMETER_NOT_NULLABLE, no_bucket, WARNING, [`ImmutableMap.copyOf(...)`: parameter #1 is declared non-nullable (according to nullsafe internal models) but the argument `nullIterable` is `null`: null constant at line 177.]
codetoanalyze/java/nullsafe/ParameterNotNullable.java, codetoanalyze.java.nullsafe.ParameterNotNullable.testImmutableMapCopyOfNotNullArguments():void, 6, ERADICATE_PARAMETER_NOT_NULLABLE, no_bucket, WARNING, [`ImmutableMap.copyOf(...)`: parameter #1 is declared non-nullable (according to nullsafe internal models) but the argument `nullMap` is `null`: null constant at line 178.]
codetoanalyze/java/nullsafe/ParameterNotNullable.java, codetoanalyze.java.nullsafe.ParameterNotNullable.testImmutableMapOfnotNullArguments():void, 4, ERADICATE_PARAMETER_NOT_NULLABLE, no_bucket, WARNING, [`ImmutableMap.of(...)`: parameter #2 is declared non-nullable (according to nullsafe internal models) but the argument is `null`.]
codetoanalyze/java/nullsafe/ParameterNotNullable.java, codetoanalyze.java.nullsafe.ParameterNotNullable.testImmutableMapOfnotNullArguments():void, 4, ERADICATE_PARAMETER_NOT_NULLABLE, no_bucket, WARNING, [`ImmutableMap.of(...)`: parameter #1 is declared non-nullable (according to nullsafe internal models) but the argument is `null`.]
codetoanalyze/java/nullsafe/ParameterNotNullable.java, codetoanalyze.java.nullsafe.ParameterNotNullable.testImmutableMapOfnotNullArguments():void, 6, ERADICATE_PARAMETER_NOT_NULLABLE, no_bucket, WARNING, [`ImmutableMap.of(...)`: parameter #4 is declared non-nullable (according to nullsafe internal models) but the argument is `null`.]
codetoanalyze/java/nullsafe/ParameterNotNullable.java, codetoanalyze.java.nullsafe.ParameterNotNullable.testImmutableMapOfnotNullArguments():void, 6, ERADICATE_PARAMETER_NOT_NULLABLE, no_bucket, WARNING, [`ImmutableMap.of(...)`: parameter #2 is declared non-nullable (according to nullsafe internal models) but the argument is `null`.]
codetoanalyze/java/nullsafe/ParameterNotNullable.java, codetoanalyze.java.nullsafe.ParameterNotNullable.testImmutableSetCopyOfNotNullArguments():void, 6, ERADICATE_PARAMETER_NOT_NULLABLE, no_bucket, WARNING, [`ImmutableSet.copyOf(...)`: parameter #1 is declared non-nullable (according to nullsafe internal models) but the argument `nullIterable` is `null`: null constant at line 157.]
codetoanalyze/java/nullsafe/ParameterNotNullable.java, codetoanalyze.java.nullsafe.ParameterNotNullable.testImmutableSetCopyOfNotNullArguments():void, 7, ERADICATE_PARAMETER_NOT_NULLABLE, no_bucket, WARNING, [`ImmutableSet.copyOf(...)`: parameter #1 is declared non-nullable (according to nullsafe internal models) but the argument `nullIterator` is `null`: null constant at line 158.]
codetoanalyze/java/nullsafe/ParameterNotNullable.java, codetoanalyze.java.nullsafe.ParameterNotNullable.testImmutableSetCopyOfNotNullArguments():void, 8, ERADICATE_PARAMETER_NOT_NULLABLE, no_bucket, WARNING, [`ImmutableSet.copyOf(...)`: parameter #1 is declared non-nullable (according to nullsafe internal models) but the argument `nullCollection` is `null`: null constant at line 159.]
codetoanalyze/java/nullsafe/ParameterNotNullable.java, codetoanalyze.java.nullsafe.ParameterNotNullable.testImmutableSetOfnotNullArguments():void, 4, ERADICATE_PARAMETER_NOT_NULLABLE, no_bucket, WARNING, [`ImmutableSet.of(...)`: parameter #1 is declared non-nullable (according to nullsafe internal models) but the argument is `null`.]
codetoanalyze/java/nullsafe/ParameterNotNullable.java, codetoanalyze.java.nullsafe.ParameterNotNullable.testImmutableSetOfnotNullArguments():void, 5, ERADICATE_PARAMETER_NOT_NULLABLE, no_bucket, WARNING, [`ImmutableSet.of(...)`: parameter #2 is declared non-nullable (according to nullsafe internal models) but the argument is `null`.]
codetoanalyze/java/nullsafe/ParameterNotNullable.java, codetoanalyze.java.nullsafe.ParameterNotNullable.testImmutableSetOfnotNullArguments():void, 5, ERADICATE_PARAMETER_NOT_NULLABLE, no_bucket, WARNING, [`ImmutableSet.of(...)`: parameter #1 is declared non-nullable (according to nullsafe internal models) but the argument is `null`.]
codetoanalyze/java/nullsafe/ParameterNotNullable.java, codetoanalyze.java.nullsafe.ParameterNotNullable.testImmutableSetOfnotNullArguments():void, 7, ERADICATE_PARAMETER_NOT_NULLABLE, no_bucket, WARNING, [`ImmutableSet.of(...)`: parameter #2 is declared non-nullable (according to nullsafe internal models) but the argument is `null`.]
codetoanalyze/java/nullsafe/ParameterNotNullable.java, codetoanalyze.java.nullsafe.ParameterNotNullable.testImmutableSetOfnotNullArguments():void, 8, ERADICATE_PARAMETER_NOT_NULLABLE, no_bucket, WARNING, [`ImmutableSet.of(...)`: parameter #4 is declared non-nullable (according to nullsafe internal models) but the argument is `null`.]
codetoanalyze/java/nullsafe/ParameterNotNullable.java, codetoanalyze.java.nullsafe.ParameterNotNullable.testImmutableSetOfnotNullArguments():void, 8, ERADICATE_PARAMETER_NOT_NULLABLE, no_bucket, WARNING, [`ImmutableSet.of(...)`: parameter #2 is declared non-nullable (according to nullsafe internal models) but the argument is `null`.]
codetoanalyze/java/nullsafe/ParameterNotNullable.java, codetoanalyze.java.nullsafe.ParameterNotNullable.testParsingNullStringToNumber():void, 2, ERADICATE_PARAMETER_NOT_NULLABLE, no_bucket, WARNING, [`Long.parseLong(...)`: parameter #1 is declared non-nullable (according to nullsafe internal models) but the argument `ns` is `null`: null constant at line 185.]
codetoanalyze/java/nullsafe/ParameterNotNullable.java, codetoanalyze.java.nullsafe.ParameterNotNullable.testParsingNullStringToNumber():void, 3, ERADICATE_PARAMETER_NOT_NULLABLE, no_bucket, WARNING, [`Integer.parseInt(...)`: parameter #1 is declared non-nullable (according to nullsafe internal models) but the argument `ns` is `null`: null constant at line 185.]
codetoanalyze/java/nullsafe/ParameterNotNullable.java, codetoanalyze.java.nullsafe.ParameterNotNullable.testSystemGetPropertyArgument():java.lang.String, 1, ERADICATE_PARAMETER_NOT_NULLABLE, no_bucket, WARNING, [`System.getProperty(...)`: parameter #1 is declared non-nullable (according to nullsafe internal models) but the argument is `null`.]
codetoanalyze/java/nullsafe/ParameterNotNullable.java, codetoanalyze.java.nullsafe.ParameterNotNullable.testSystemGetenvBad():java.lang.String, 1, ERADICATE_PARAMETER_NOT_NULLABLE, no_bucket, WARNING, [`System.getenv(...)`: parameter #1 is declared non-nullable (according to nullsafe internal models) but the argument is `null`.]
codetoanalyze/java/nullsafe/ParameterNotNullable.java, codetoanalyze.java.nullsafe.ParameterNotNullable.testThreeParameters():void, 2, ERADICATE_PARAMETER_NOT_NULLABLE, no_bucket, WARNING, [`ParameterNotNullable.threeParameters(...)`: parameter #1(`s1`) is declared non-nullable but the argument is `null`.]
codetoanalyze/java/nullsafe/ParameterNotNullable.java, codetoanalyze.java.nullsafe.ParameterNotNullable.testThreeParameters():void, 3, ERADICATE_PARAMETER_NOT_NULLABLE, no_bucket, WARNING, [`ParameterNotNullable.threeParameters(...)`: parameter #2(`s2`) is declared non-nullable but the argument is `null`.]
codetoanalyze/java/nullsafe/ParameterNotNullable.java, codetoanalyze.java.nullsafe.ParameterNotNullable.testThreeParameters():void, 4, ERADICATE_PARAMETER_NOT_NULLABLE, no_bucket, WARNING, [`ParameterNotNullable.threeParameters(...)`: parameter #3(`s3`) is declared non-nullable but the argument is `null`.]
codetoanalyze/java/nullsafe/PropagatesNullable.java, Linters_dummy_method, 14, ERADICATE_META_CLASS_NEEDS_IMPROVEMENT, no_bucket, INFO, [], TestPropagatesNullable, codetoanalyze.java.nullsafe, issues: 20, curr_mode: "Default"
codetoanalyze/java/nullsafe/PropagatesNullable.java, codetoanalyze.java.nullsafe.TestPropagatesNullable$TestBothParams.testBothParamsShouldBeNonnull(java.lang.String,java.lang.String):void, 1, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`propagatesNullable(...)` is nullable and is not locally checked for null when calling `length()`: method parameter sNullable.]
codetoanalyze/java/nullsafe/PropagatesNullable.java, codetoanalyze.java.nullsafe.TestPropagatesNullable$TestBothParams.testBothParamsShouldBeNonnull(java.lang.String,java.lang.String):void, 2, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`propagatesNullable(...)` is nullable and is not locally checked for null when calling `length()`: method parameter sNullable.]
codetoanalyze/java/nullsafe/PropagatesNullable.java, codetoanalyze.java.nullsafe.TestPropagatesNullable$TestBothParams.testBothParamsShouldBeNonnull(java.lang.String,java.lang.String):void, 3, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`propagatesNullable(...)` is nullable and is not locally checked for null when calling `length()`: method parameter sNullable.]
codetoanalyze/java/nullsafe/PropagatesNullable.java, codetoanalyze.java.nullsafe.TestPropagatesNullable$TestOneParameter.test(java.lang.String,java.lang.String):void, 2, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [NullPointerException will be thrown at this line! `propagatesNullable(...)` is `null` and is dereferenced via calling `length()`: null constant at line 30.]
codetoanalyze/java/nullsafe/PropagatesNullable.java, codetoanalyze.java.nullsafe.TestPropagatesNullable$TestOneParameter.test(java.lang.String,java.lang.String):void, 3, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`nullable(...)` is nullable and is not locally checked for null when calling `length()`.]
codetoanalyze/java/nullsafe/PropagatesNullable.java, codetoanalyze.java.nullsafe.TestPropagatesNullable$TestOneParameter.test(java.lang.String,java.lang.String):void, 6, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`propagatesNullable(...)` is nullable and is not locally checked for null when calling `length()`: method parameter sNullable.]
codetoanalyze/java/nullsafe/PropagatesNullable.java, codetoanalyze.java.nullsafe.TestPropagatesNullable$TestOneParameter.test(java.lang.String,java.lang.String):void, 7, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`nullable(...)` is nullable and is not locally checked for null when calling `length()`.]
codetoanalyze/java/nullsafe/PropagatesNullable.java, codetoanalyze.java.nullsafe.TestPropagatesNullable$TestOneParameter.test(java.lang.String,java.lang.String):void, 11, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`nullable(...)` is nullable and is not locally checked for null when calling `length()`.]
codetoanalyze/java/nullsafe/PropagatesNullable.java, codetoanalyze.java.nullsafe.TestPropagatesNullable$TestOneParameter.test(java.lang.String,java.lang.String):void, 15, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`nullable(...)` is nullable and is not locally checked for null when calling `length()`.]
codetoanalyze/java/nullsafe/PropagatesNullable.java, codetoanalyze.java.nullsafe.TestPropagatesNullable$TestOneParameter.test(java.lang.String,java.lang.String):void, 21, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`propagatesNullable(...)` is nullable and is not locally checked for null when calling `length()`: method parameter sNullable.]
codetoanalyze/java/nullsafe/PropagatesNullable.java, codetoanalyze.java.nullsafe.TestPropagatesNullable$TestOneParameter.test(java.lang.String,java.lang.String):void, 22, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`nullable(...)` is nullable and is not locally checked for null when calling `length()`.]
codetoanalyze/java/nullsafe/PropagatesNullable.java, codetoanalyze.java.nullsafe.TestPropagatesNullable$TestReturnValueAnnotationIsAutomaticallyInferred.annotated_dereferencingAfterPassingNullableIsBAD(java.lang.String):void, 1, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`annotatedReturn(...)` is nullable and is not locally checked for null when calling `toString()`: method parameter s.]
codetoanalyze/java/nullsafe/PropagatesNullable.java, codetoanalyze.java.nullsafe.TestPropagatesNullable$TestReturnValueAnnotationIsAutomaticallyInferred.notAnnotated_dereferencingAfterPassingNullableIsBAD(java.lang.String):void, 1, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`notAnnotatedReturn(...)` is nullable and is not locally checked for null when calling `toString()`: method parameter s.]
codetoanalyze/java/nullsafe/PropagatesNullable.java, codetoanalyze.java.nullsafe.TestPropagatesNullable$TestReturnValueAnnotationIsAutomaticallyInferred.notAnnotatingReturnWhenThereAreNoPropagatesNullableIsBAD(java.lang.String):java.lang.String, 0, ERADICATE_RETURN_NOT_NULLABLE, no_bucket, WARNING, [`notAnnotatingReturnWhenThereAreNoPropagatesNullableIsBAD(...)`: return type is declared non-nullable but the method returns `null`: null constant at line 123.]
codetoanalyze/java/nullsafe/PropagatesNullable.java, codetoanalyze.java.nullsafe.TestPropagatesNullable$TestSecondParameter.test(java.lang.String,java.lang.String):void, 2, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`propagatesNullable(...)` is nullable and is not locally checked for null when calling `length()`: method parameter sNullable.]
codetoanalyze/java/nullsafe/PropagatesNullable.java, codetoanalyze.java.nullsafe.TestPropagatesNullable$TestSecondParameter.test(java.lang.String,java.lang.String):void, 3, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`nullable(...)` is nullable and is not locally checked for null when calling `length()`.]
codetoanalyze/java/nullsafe/PropagatesNullable.java, codetoanalyze.java.nullsafe.TestPropagatesNullable$TestSecondParameter.test(java.lang.String,java.lang.String):void, 6, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`propagatesNullable(...)` is nullable and is not locally checked for null when calling `length()`: method parameter sNullable.]
codetoanalyze/java/nullsafe/PropagatesNullable.java, codetoanalyze.java.nullsafe.TestPropagatesNullable$TestSecondParameter.test(java.lang.String,java.lang.String):void, 7, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`nullable(...)` is nullable and is not locally checked for null when calling `length()`.]
codetoanalyze/java/nullsafe/PropagatesNullable.java, codetoanalyze.java.nullsafe.TestPropagatesNullable$TestSecondParameter.test(java.lang.String,java.lang.String):void, 11, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`nullable(...)` is nullable and is not locally checked for null when calling `length()`.]
codetoanalyze/java/nullsafe/PropagatesNullable.java, codetoanalyze.java.nullsafe.TestPropagatesNullable$TestSecondParameter.test(java.lang.String,java.lang.String):void, 15, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`nullable(...)` is nullable and is not locally checked for null when calling `length()`.]
codetoanalyze/java/nullsafe/ReturnNotNullable.java, Linters_dummy_method, 23, ERADICATE_META_CLASS_NEEDS_IMPROVEMENT, no_bucket, INFO, [], ReturnNotNullable, codetoanalyze.java.nullsafe, issues: 9, curr_mode: "Default"
codetoanalyze/java/nullsafe/ReturnNotNullable.java, codetoanalyze.java.nullsafe.ReturnNotNullable$ConditionalAssignment.test(boolean):java.lang.Object, 0, ERADICATE_RETURN_NOT_NULLABLE, no_bucket, WARNING, [`test(...)`: return type is declared non-nullable but the method returns a nullable value: field f1 at line 203.]
codetoanalyze/java/nullsafe/ReturnNotNullable.java, codetoanalyze.java.nullsafe.ReturnNotNullable.constantToNullableIsOverannotated():java.lang.String, 0, ERADICATE_RETURN_OVER_ANNOTATED, no_bucket, ADVICE, [Method `constantToNullableIsOverannotated()` is annotated with `@Nullable` but never returns null.]
codetoanalyze/java/nullsafe/ReturnNotNullable.java, codetoanalyze.java.nullsafe.ReturnNotNullable.getResourceNullable(java.lang.Class,java.lang.String):java.net.URL, 0, ERADICATE_RETURN_NOT_NULLABLE, no_bucket, WARNING, [`getResourceNullable(...)`: return type is declared non-nullable but the method returns a nullable value: call to Class.getResource(...) at line 181 (nullable according to nullsafe internal models).]
codetoanalyze/java/nullsafe/ReturnNotNullable.java, codetoanalyze.java.nullsafe.ReturnNotNullable.nonNullToNullableIsOverannotated(java.lang.String):java.lang.String, 0, ERADICATE_RETURN_OVER_ANNOTATED, no_bucket, ADVICE, [Method `nonNullToNullableIsOverannotated(...)` is annotated with `@Nullable` but never returns null.]
codetoanalyze/java/nullsafe/ReturnNotNullable.java, codetoanalyze.java.nullsafe.ReturnNotNullable.notAnnotatedNullableIsOverannotated(java.lang.String):java.lang.String, 0, ERADICATE_RETURN_OVER_ANNOTATED, no_bucket, ADVICE, [Method `notAnnotatedNullableIsOverannotated(...)` is annotated with `@Nullable` but never returns null.]
codetoanalyze/java/nullsafe/ReturnNotNullable.java, codetoanalyze.java.nullsafe.ReturnNotNullable.nullToNonnullIsBad():java.lang.String, 0, ERADICATE_RETURN_NOT_NULLABLE, no_bucket, WARNING, [`nullToNonnullIsBad()`: return type is declared non-nullable but the method returns `null`: null constant at line 64.]
codetoanalyze/java/nullsafe/ReturnNotNullable.java, codetoanalyze.java.nullsafe.ReturnNotNullable.nullToNotAnnotatedIsBad():java.lang.String, 0, ERADICATE_RETURN_NOT_NULLABLE, no_bucket, WARNING, [`nullToNotAnnotatedIsBad()`: return type is declared non-nullable but the method returns `null`: null constant at line 39.]
codetoanalyze/java/nullsafe/ReturnNotNullable.java, codetoanalyze.java.nullsafe.ReturnNotNullable.nullableToNonnullIsBad(java.lang.String):java.lang.String, 0, ERADICATE_RETURN_NOT_NULLABLE, no_bucket, WARNING, [`nullableToNonnullIsBad(...)`: return type is declared non-nullable but the method returns a nullable value: method parameter s.]
codetoanalyze/java/nullsafe/ReturnNotNullable.java, codetoanalyze.java.nullsafe.ReturnNotNullable.nullableToNotAnnotatedIsBad(java.lang.String):java.lang.String, 0, ERADICATE_RETURN_NOT_NULLABLE, no_bucket, WARNING, [`nullableToNotAnnotatedIsBad(...)`: return type is declared non-nullable but the method returns a nullable value: method parameter s.]
codetoanalyze/java/nullsafe/ReturnNotNullable.java, codetoanalyze.java.nullsafe.ReturnNotNullable.return_null_in_catch():java.lang.String, 0, ERADICATE_RETURN_NOT_NULLABLE, no_bucket, WARNING, [`return_null_in_catch()`: return type is declared non-nullable but the method returns `null`: null constant at line 164.]
codetoanalyze/java/nullsafe/ReturnNotNullable.java, codetoanalyze.java.nullsafe.ReturnNotNullable.return_null_in_catch_after_throw():java.lang.String, 0, ERADICATE_RETURN_NOT_NULLABLE, no_bucket, WARNING, [`return_null_in_catch_after_throw()`: return type is declared non-nullable but the method returns `null`: null constant at line 176.]
codetoanalyze/java/nullsafe/ReturnNotNullable.java, codetoanalyze.java.nullsafe.ReturnNotNullable.tryWithResourcesReturnNullable(java.lang.String):java.lang.Object, 0, ERADICATE_RETURN_NOT_NULLABLE, no_bucket, WARNING, [`tryWithResourcesReturnNullable(...)`: return type is declared non-nullable but the method returns a nullable value: call to nullToNullableIsOK() at line 146.]
codetoanalyze/java/nullsafe/StrictMode.java, Linters_dummy_method, 15, ERADICATE_META_CLASS_NEEDS_IMPROVEMENT, no_bucket, INFO, [], Strict, codetoanalyze.java.nullsafe, issues: 17, curr_mode: "Strict"
codetoanalyze/java/nullsafe/StrictMode.java, Linters_dummy_method, 239, ERADICATE_META_CLASS_IS_NULLSAFE, no_bucket, INFO, [], OtherStrict, codetoanalyze.java.nullsafe, issues: 0, curr_mode: "Strict"
codetoanalyze/java/nullsafe/StrictMode.java, Linters_dummy_method, 260, ERADICATE_META_CLASS_CAN_BE_NULLSAFE, no_bucket, ADVICE, [Congrats! `NonStrict` is free of nullability issues. Mark it `@Nullsafe(Nullsafe.Mode.LOCAL)` to prevent regressions.], NonStrict, codetoanalyze.java.nullsafe, issues: 0, curr_mode: "Default", promote_mode: "LocalTrustAll"
codetoanalyze/java/nullsafe/StrictMode.java, Linters_dummy_method, 285, ERADICATE_META_CLASS_NEEDS_IMPROVEMENT, no_bucket, INFO, [], SomeEnum, codetoanalyze.java.nullsafe, issues: 0, curr_mode: "Default"
codetoanalyze/java/nullsafe/StrictMode.java, codetoanalyze.java.nullsafe.Strict.<init>(), 0, ERADICATE_FIELD_NOT_INITIALIZED, no_bucket, ERROR, [Field `notInitializedIsBAD` is declared non-nullable, so it should be initialized in the constructor or in an `@Initializer` method]
codetoanalyze/java/nullsafe/StrictMode.java, codetoanalyze.java.nullsafe.Strict.nonStrictClass_convertingNonnullToNonnullIsBad():java.lang.String, 2, ERADICATE_UNCHECKED_USAGE_IN_NULLSAFE, no_bucket, ERROR, [`NonStrict.getNonnull()`: `@NullsafeStrict` mode prohibits using values coming from non-strict classes without a check. Result of this call is used at line 179. Either add a local check for null or assertion, or make `NonStrict` nullsafe strict.]
codetoanalyze/java/nullsafe/StrictMode.java, codetoanalyze.java.nullsafe.Strict.nonStrictClass_convertingNonnullToNullableIsOK():java.lang.String, 0, ERADICATE_RETURN_OVER_ANNOTATED, no_bucket, ADVICE, [Method `nonStrictClass_convertingNonnullToNullableIsOK()` is annotated with `@Nullable` but never returns null.]
codetoanalyze/java/nullsafe/StrictMode.java, codetoanalyze.java.nullsafe.Strict.nonStrictClass_convertingNullableToNonnullIsBad():java.lang.String, 0, ERADICATE_RETURN_NOT_NULLABLE, no_bucket, ERROR, [`nonStrictClass_convertingNullableToNonnullIsBad()`: return type is declared non-nullable but the method returns a nullable value: call to getNullable() at line 137.]
codetoanalyze/java/nullsafe/StrictMode.java, codetoanalyze.java.nullsafe.Strict.nonStrictClass_dereferenceNonnullFieldAfterCheckIsOK():void, 2, ERADICATE_CONDITION_REDUNDANT, no_bucket, ADVICE, [The condition NonStrict.nonnull might be always true according to the existing annotations.]
codetoanalyze/java/nullsafe/StrictMode.java, codetoanalyze.java.nullsafe.Strict.nonStrictClass_dereferenceNonnullFieldIsBad():void, 2, ERADICATE_UNCHECKED_USAGE_IN_NULLSAFE, no_bucket, ERROR, [`NonStrict.nonnull`: `@NullsafeStrict` mode prohibits using values coming from non-strict classes without a check. This field is used at line 133. Either add a local check for null or assertion, or make `NonStrict` nullsafe strict.]
codetoanalyze/java/nullsafe/StrictMode.java, codetoanalyze.java.nullsafe.Strict.nonStrictClass_dereferenceNonnullMethodAfterCheckIsOK():void, 2, ERADICATE_CONDITION_REDUNDANT, no_bucket, ADVICE, [The condition lang.String(o) might be always true: `NonStrict.getNonnull()` is not annotated as `@Nullable`.]
codetoanalyze/java/nullsafe/StrictMode.java, codetoanalyze.java.nullsafe.Strict.nonStrictClass_dereferenceNonnullMethodIsBad():void, 2, ERADICATE_UNCHECKED_USAGE_IN_NULLSAFE, no_bucket, ERROR, [`NonStrict.getNonnull()`: `@NullsafeStrict` mode prohibits using values coming from non-strict classes without a check. Result of this call is used at line 115. Either add a local check for null or assertion, or make `NonStrict` nullsafe strict.]
codetoanalyze/java/nullsafe/StrictMode.java, codetoanalyze.java.nullsafe.Strict.nonStrictClass_dereferenceNonnullStaticMethodIsBad():void, 2, ERADICATE_UNCHECKED_USAGE_IN_NULLSAFE, no_bucket, ERROR, [`NonStrict.staticNonnull()`: `@NullsafeStrict` mode prohibits using values coming from non-strict classes without a check. Result of this call is used at line 124. Either add a local check for null or assertion, or make `NonStrict` nullsafe strict.]
codetoanalyze/java/nullsafe/StrictMode.java, codetoanalyze.java.nullsafe.Strict.nonStrictClass_dereferenceNullableFieldIsBad():void, 1, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, ERROR, [`__new(...).nullable` is nullable and is not locally checked for null when calling `toString()`.]
codetoanalyze/java/nullsafe/StrictMode.java, codetoanalyze.java.nullsafe.Strict.nonStrictClass_dereferenceNullableMethodIsBad():void, 1, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, ERROR, [`getNullable(...)` is nullable and is not locally checked for null when calling `toString()`: call to getNullable() at line 110.]
codetoanalyze/java/nullsafe/StrictMode.java, codetoanalyze.java.nullsafe.Strict.nonStrictClass_dereferenceNullableStaticMethodIsBad():void, 1, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, ERROR, [`staticNullable()` is nullable and is not locally checked for null when calling `toString()`.]
codetoanalyze/java/nullsafe/StrictMode.java, codetoanalyze.java.nullsafe.Strict.sameClass_convertingNullableToNonnullIsBad():java.lang.String, 0, ERADICATE_RETURN_NOT_NULLABLE, no_bucket, ERROR, [`sameClass_convertingNullableToNonnullIsBad()`: return type is declared non-nullable but the method returns a nullable value: call to getNullable() at line 65.]
codetoanalyze/java/nullsafe/StrictMode.java, codetoanalyze.java.nullsafe.Strict.sameClass_dereferenceNullableFieldIsBad():void, 1, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, ERROR, [`Strict.nullable` is nullable and is not locally checked for null when calling `toString()`.]
codetoanalyze/java/nullsafe/StrictMode.java, codetoanalyze.java.nullsafe.Strict.sameClass_dereferenceNullableMethodIsBad():void, 1, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, ERROR, [`getNullable()` is nullable and is not locally checked for null when calling `toString()`.]
codetoanalyze/java/nullsafe/StrictMode.java, codetoanalyze.java.nullsafe.Strict.sameClass_dereferenceNullableStaticMethodIsBad():void, 1, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, ERROR, [`staticNullable()` is nullable and is not locally checked for null when calling `toString()`.]
codetoanalyze/java/nullsafe/StrictMode.java, codetoanalyze.java.nullsafe.Strict.strictClass_convertingNullableToNonnullIsBad():java.lang.String, 0, ERADICATE_RETURN_NOT_NULLABLE, no_bucket, ERROR, [`strictClass_convertingNullableToNonnullIsBad()`: return type is declared non-nullable but the method returns a nullable value: call to getNullable() at line 99.]
codetoanalyze/java/nullsafe/StrictMode.java, codetoanalyze.java.nullsafe.Strict.strictClass_dereferenceNullableFieldIsBad():void, 1, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, ERROR, [`__new(...).nullable` is nullable and is not locally checked for null when calling `toString()`.]
codetoanalyze/java/nullsafe/StrictMode.java, codetoanalyze.java.nullsafe.Strict.strictClass_dereferenceNullableMethodIsBad():void, 1, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, ERROR, [`getNullable(...)` is nullable and is not locally checked for null when calling `toString()`: call to getNullable() at line 75.]
codetoanalyze/java/nullsafe/StrictMode.java, codetoanalyze.java.nullsafe.Strict.strictClass_dereferenceNullableStaticMethodIsBad():void, 1, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, ERROR, [`staticNullable()` is nullable and is not locally checked for null when calling `toString()`.]
codetoanalyze/java/nullsafe/StrictModeForThirdParty.java, Linters_dummy_method, 19, ERADICATE_META_CLASS_NEEDS_IMPROVEMENT, no_bucket, INFO, [], StrictModeForThirdParty, codetoanalyze.java.nullsafe, issues: 5, curr_mode: "Strict"
codetoanalyze/java/nullsafe/StrictModeForThirdParty.java, codetoanalyze.java.nullsafe.StrictModeForThirdParty.dereferenceFieldIsBAD():void, 1, ERADICATE_UNVETTED_THIRD_PARTY_IN_NULLSAFE, no_bucket, ERROR, [`ThirdPartyTestClass.nonNullableField`: `@NullsafeStrict` mode prohibits using values coming from third-party classes without a check. This field is used at line 49. Either add a local check for null or assertion, or access `nonNullableField` via a nullsafe strict getter.]
codetoanalyze/java/nullsafe/StrictModeForThirdParty.java, codetoanalyze.java.nullsafe.StrictModeForThirdParty.dereferenceSpecifiedAsNullableIsBAD():void, 1, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, ERROR, [`StrictModeForThirdParty.obj.returnSpecifiedAsNullable()` is nullable and is not locally checked for null when calling `toString()`: call to ThirdPartyTestClass.returnSpecifiedAsNullable() at line 45 (declared nullable in nullsafe/third-party-signatures/some.test.pckg.sig at line 2).]
codetoanalyze/java/nullsafe/StrictModeForThirdParty.java, codetoanalyze.java.nullsafe.StrictModeForThirdParty.dereferenceUnspecifiedIsBAD():void, 1, ERADICATE_UNVETTED_THIRD_PARTY_IN_NULLSAFE, no_bucket, ERROR, [`ThirdPartyTestClass.returnUnspecified()`: `@NullsafeStrict` mode prohibits using values coming from not vetted third party methods without a check. Result of this call is used at line 41. Either add a local check for null or assertion, or add the correct signature to nullsafe/third-party-signatures/some.test.pckg.sig.]
codetoanalyze/java/nullsafe/StrictModeForThirdParty.java, codetoanalyze.java.nullsafe.StrictModeForThirdParty.passingNullableParamToUnspecifiedIsBAD():void, 1, ERADICATE_PARAMETER_NOT_NULLABLE, no_bucket, ERROR, [Third-party `ThirdPartyTestClass.paramUnspecified(...)` is missing a signature that would allow passing a nullable to param #1(`param`). Actual argument `getNullable()` is nullable. Consider adding the correct signature of `ThirdPartyTestClass.paramUnspecified(...)` to nullsafe/third-party-signatures/some.test.pckg.sig.]
codetoanalyze/java/nullsafe/StrictModeForThirdParty.java, codetoanalyze.java.nullsafe.StrictModeForThirdParty.passingNullableToParamSpecifiedAsNonnullIsBAD():void, 1, ERADICATE_PARAMETER_NOT_NULLABLE, no_bucket, ERROR, [`ThirdPartyTestClass.secondParamSpecifiedAsNonnull(...)`: parameter #2(`specifiedAsNonnull`) is declared non-nullable (see nullsafe/third-party-signatures/some.test.pckg.sig at line 3) but the argument `getNullable()` is nullable.]
codetoanalyze/java/nullsafe/SwitchCase.java, Linters_dummy_method, 12, ERADICATE_META_CLASS_NEEDS_IMPROVEMENT, no_bucket, INFO, [], SwitchCase, codetoanalyze.java.nullsafe, issues: 2, curr_mode: "Default"
codetoanalyze/java/nullsafe/SwitchCase.java, Linters_dummy_method, 63, ERADICATE_META_CLASS_NEEDS_IMPROVEMENT, no_bucket, INFO, [], Color, codetoanalyze.java.nullsafe, issues: 0, curr_mode: "Default"
codetoanalyze/java/nullsafe/SwitchCase.java, codetoanalyze.java.nullsafe.SwitchCase.getNullableColor():codetoanalyze.java.nullsafe.Color, 0, ERADICATE_RETURN_OVER_ANNOTATED, no_bucket, ADVICE, [Method `getNullableColor()` is annotated with `@Nullable` but never returns null.]
codetoanalyze/java/nullsafe/SwitchCase.java, codetoanalyze.java.nullsafe.SwitchCase.switchOnNullIsBad():java.lang.String, 2, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [NullPointerException will be thrown at this line! `color` is `null` and is dereferenced via calling `ordinal()`: null constant at line 14.]
codetoanalyze/java/nullsafe/SwitchCase.java, codetoanalyze.java.nullsafe.SwitchCase.switchOnNullableIsBad():java.lang.String, 2, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`color` is nullable and is not locally checked for null when calling `ordinal()`: call to getNullableColor() at line 28.]
codetoanalyze/java/nullsafe/SyntheticErrorSuppressions.java, Linters_dummy_method, 13, ERADICATE_META_CLASS_NEEDS_IMPROVEMENT, no_bucket, INFO, [], SyntheticErrorSuppressions, codetoanalyze.java.nullsafe, issues: 3, curr_mode: "Default"
codetoanalyze/java/nullsafe/SyntheticErrorSuppressions.java, codetoanalyze.java.nullsafe.SyntheticErrorSuppressions$ClassWithSyntheticCode.dereferencingNullableSyntheticMethodCall_OK_FP():java.lang.String, 1, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`$ul_iAmNullableAutogen(...)` is nullable and is not locally checked for null when calling `toString()`: call to $ul_iAmNullableAutogen() at line 60.]
codetoanalyze/java/nullsafe/SyntheticErrorSuppressions.java, codetoanalyze.java.nullsafe.SyntheticErrorSuppressions$ClassWithSyntheticCode.dereferencingSyntheticNullableField_OK_FP():java.lang.String, 1, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`SyntheticErrorSuppressions$ClassWithSyntheticCode.$ul_fieldNullable` is nullable and is not locally checked for null when calling `toString()`.]
codetoanalyze/java/nullsafe/SyntheticErrorSuppressions.java, codetoanalyze.java.nullsafe.SyntheticErrorSuppressions$ClassWithSyntheticCode.passingSyntheticParamToAnyMethod_OK_FP():void, 1, ERADICATE_PARAMETER_NOT_NULLABLE, no_bucket, WARNING, [`SyntheticErrorSuppressions$Fragment.setContext(...)`: parameter #1(`context`) is declared non-nullable but the argument `SyntheticErrorSuppressions$ClassWithSyntheticCode.$ul_fieldNullable` is nullable.]
codetoanalyze/java/nullsafe/TrueFalseOnNull.java, Linters_dummy_method, 17, ERADICATE_META_CLASS_NEEDS_IMPROVEMENT, no_bucket, INFO, [], TrueFalseOnNull, codetoanalyze.java.nullsafe, issues: 17, curr_mode: "Default"
codetoanalyze/java/nullsafe/TrueFalseOnNull.java, codetoanalyze.java.nullsafe.TrueFalseOnNull$EarlyReturn.testEarlyReturn(java.lang.CharSequence,java.lang.CharSequence):void, 6, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`s2` is nullable and is not locally checked for null when calling `toString()`.]
codetoanalyze/java/nullsafe/TrueFalseOnNull.java, codetoanalyze.java.nullsafe.TrueFalseOnNull$TestNonStaticOneParam.falseOnNullNegativeBranchIsBAD(java.lang.String):void, 2, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`s` is nullable and is not locally checked for null when calling `toString()`.]
codetoanalyze/java/nullsafe/TrueFalseOnNull.java, codetoanalyze.java.nullsafe.TrueFalseOnNull$TestNonStaticOneParam.notAnnotatedNegativeBranchIsBAD(java.lang.String):void, 2, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`s` is nullable and is not locally checked for null when calling `toString()`.]
codetoanalyze/java/nullsafe/TrueFalseOnNull.java, codetoanalyze.java.nullsafe.TrueFalseOnNull$TestNonStaticOneParam.notAnnotatedPositiveBranchIsBAD(java.lang.String):void, 2, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`s` is nullable and is not locally checked for null when calling `toString()`.]
codetoanalyze/java/nullsafe/TrueFalseOnNull.java, codetoanalyze.java.nullsafe.TrueFalseOnNull$TestNonStaticOneParam.trueOnNullPositiveBranchIsBAD(java.lang.String):void, 2, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`s` is nullable and is not locally checked for null when calling `toString()`.]
codetoanalyze/java/nullsafe/TrueFalseOnNull.java, codetoanalyze.java.nullsafe.TrueFalseOnNull$TestNonStaticSeveralParams.falseOnNullNegativeBranchIsBAD(java.lang.String,java.lang.String):void, 2, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`s1` is nullable and is not locally checked for null when calling `toString()`.]
codetoanalyze/java/nullsafe/TrueFalseOnNull.java, codetoanalyze.java.nullsafe.TrueFalseOnNull$TestNonStaticSeveralParams.falseOnNullNegativeBranchIsBAD(java.lang.String,java.lang.String):void, 3, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`s2` is nullable and is not locally checked for null when calling `toString()`.]
codetoanalyze/java/nullsafe/TrueFalseOnNull.java, codetoanalyze.java.nullsafe.TrueFalseOnNull$TestNonStaticSeveralParams.notAnnotatedNegativeBranchIsBAD(java.lang.String,java.lang.String):void, 2, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`s1` is nullable and is not locally checked for null when calling `toString()`.]
codetoanalyze/java/nullsafe/TrueFalseOnNull.java, codetoanalyze.java.nullsafe.TrueFalseOnNull$TestNonStaticSeveralParams.notAnnotatedNegativeBranchIsBAD(java.lang.String,java.lang.String):void, 3, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`s2` is nullable and is not locally checked for null when calling `toString()`.]
codetoanalyze/java/nullsafe/TrueFalseOnNull.java, codetoanalyze.java.nullsafe.TrueFalseOnNull$TestNonStaticSeveralParams.notAnnotatedPositiveBranchIsBAD(java.lang.String,java.lang.String):void, 2, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`s1` is nullable and is not locally checked for null when calling `toString()`.]
codetoanalyze/java/nullsafe/TrueFalseOnNull.java, codetoanalyze.java.nullsafe.TrueFalseOnNull$TestNonStaticSeveralParams.notAnnotatedPositiveBranchIsBAD(java.lang.String,java.lang.String):void, 3, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`s2` is nullable and is not locally checked for null when calling `toString()`.]
codetoanalyze/java/nullsafe/TrueFalseOnNull.java, codetoanalyze.java.nullsafe.TrueFalseOnNull$TestNonStaticSeveralParams.trueOnNullPositiveBranchIsBAD(java.lang.String,java.lang.String):void, 2, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`s1` is nullable and is not locally checked for null when calling `toString()`.]
codetoanalyze/java/nullsafe/TrueFalseOnNull.java, codetoanalyze.java.nullsafe.TrueFalseOnNull$TestNonStaticSeveralParams.trueOnNullPositiveBranchIsBAD(java.lang.String,java.lang.String):void, 3, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`s2` is nullable and is not locally checked for null when calling `toString()`.]
codetoanalyze/java/nullsafe/TrueFalseOnNull.java, codetoanalyze.java.nullsafe.TrueFalseOnNull$TestStaticOneParam.falseOnNullNegativeBranchIsBAD(java.lang.String):void, 2, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`s` is nullable and is not locally checked for null when calling `toString()`.]
codetoanalyze/java/nullsafe/TrueFalseOnNull.java, codetoanalyze.java.nullsafe.TrueFalseOnNull$TestStaticOneParam.notAnnotatedNegativeBranchIsBAD(java.lang.String):void, 2, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`s` is nullable and is not locally checked for null when calling `toString()`.]
codetoanalyze/java/nullsafe/TrueFalseOnNull.java, codetoanalyze.java.nullsafe.TrueFalseOnNull$TestStaticOneParam.notAnnotatedPositiveBranchIsBAD(java.lang.String):void, 2, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`s` is nullable and is not locally checked for null when calling `toString()`.]
codetoanalyze/java/nullsafe/TrueFalseOnNull.java, codetoanalyze.java.nullsafe.TrueFalseOnNull$TestStaticOneParam.trueOnNullPositiveBranchIsBAD(java.lang.String):void, 2, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [`s` is nullable and is not locally checked for null when calling `toString()`.]
codetoanalyze/java/nullsafe/TryWithResource.java, Linters_dummy_method, 13, ERADICATE_META_CLASS_NEEDS_IMPROVEMENT, no_bucket, INFO, [], TryWithResource, codetoanalyze.java.nullsafe, issues: 1, curr_mode: "Default"
codetoanalyze/java/nullsafe/TryWithResource.java, codetoanalyze.java.nullsafe.TryWithResource.FP_OK_StringWriterInTWRBlock():void, 8, ERADICATE_NULLABLE_DEREFERENCE, no_bucket, WARNING, [NullPointerException will be thrown at this line! Object is `null` and is dereferenced via calling `addSuppressed(...)`: null constant at line 22.]
