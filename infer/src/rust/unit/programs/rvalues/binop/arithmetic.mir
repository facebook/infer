# Final ULLBC before control-flow reconstruction:

// Full name: core::num::{u128}::MAX
pub const MAX: u128 = MAX()

// Full name: core::num::{i128}::MIN
pub const MIN: i128 = MIN()

// Full name: arithmetic::plus_minus_mult
fn plus_minus_mult()
{
    let @0: (); // return
    let a@1: i32; // local
    let b@2: i32; // local
    let @3: i32; // anonymous local
    let @4: i32; // anonymous local
    let @5: i32; // anonymous local
    let @6: i32; // anonymous local
    let @7: i32; // anonymous local
    let @8: i32; // anonymous local
    let @9: i32; // anonymous local
    let @10: i32; // anonymous local
    let @11: i32; // anonymous local
    let @12: i32; // anonymous local
    let @13: i32; // anonymous local
    let @14: i32; // anonymous local
    let x@15: u32; // local
    let y@16: u32; // local
    let @17: u32; // anonymous local
    let @18: u32; // anonymous local
    let @19: u32; // anonymous local
    let @20: u32; // anonymous local
    let @21: u32; // anonymous local
    let @22: u32; // anonymous local
    let @23: u32; // anonymous local
    let @24: u32; // anonymous local
    let @25: u32; // anonymous local
    let @26: u32; // anonymous local
    let @27: u32; // anonymous local
    let @28: u32; // anonymous local
    let @29: (); // anonymous local

    bb0: {
        storage_live(a@1);
        a@1 := const (-7 : i32);
        storage_live(b@2);
        b@2 := const (3 : i32);
        storage_live(@3);
        storage_live(@4);
        @4 := copy (a@1);
        storage_live(@5);
        @5 := copy (b@2);
        @6 := copy (@4) panic.+ copy (@5);
        nop;
        @3 := move (@6);
        storage_dead(@5);
        storage_dead(@4);
        storage_dead(@3);
        storage_live(@7);
        storage_live(@8);
        @8 := copy (a@1);
        storage_live(@9);
        @9 := copy (b@2);
        @10 := copy (@8) panic.- copy (@9);
        nop;
        @7 := move (@10);
        storage_dead(@9);
        storage_dead(@8);
        storage_dead(@7);
        storage_live(@11);
        storage_live(@12);
        @12 := copy (a@1);
        storage_live(@13);
        @13 := copy (b@2);
        @14 := copy (@12) panic.* copy (@13);
        nop;
        @11 := move (@14);
        storage_dead(@13);
        storage_dead(@12);
        storage_dead(@11);
        storage_live(x@15);
        x@15 := const (2 : u32);
        storage_live(y@16);
        y@16 := const (5 : u32);
        storage_live(@17);
        storage_live(@18);
        @18 := copy (x@15);
        storage_live(@19);
        @19 := copy (y@16);
        @20 := copy (@18) panic.+ copy (@19);
        nop;
        @17 := move (@20);
        storage_dead(@19);
        storage_dead(@18);
        storage_dead(@17);
        storage_live(@21);
        storage_live(@22);
        @22 := copy (y@16);
        storage_live(@23);
        @23 := copy (x@15);
        @24 := copy (@22) panic.- copy (@23);
        nop;
        @21 := move (@24);
        storage_dead(@23);
        storage_dead(@22);
        storage_dead(@21);
        storage_live(@25);
        storage_live(@26);
        @26 := copy (x@15);
        storage_live(@27);
        @27 := copy (y@16);
        @28 := copy (@26) panic.* copy (@27);
        nop;
        @25 := move (@28);
        storage_dead(@27);
        storage_dead(@26);
        storage_dead(@25);
        nop;
        @0 := ();
        storage_dead(y@16);
        storage_dead(x@15);
        storage_dead(b@2);
        storage_dead(a@1);
        @0 := ();
        return;
    }
}

// Full name: arithmetic::arithmetic_edges_i128_u128
fn arithmetic_edges_i128_u128()
{
    let @0: (); // return
    let max_u128@1: u128; // local
    let @2: u128; // anonymous local
    let @3: u128; // anonymous local
    let min_i128@4: i128; // local
    let @5: i128; // anonymous local
    let @6: i128; // anonymous local
    let @7: (); // anonymous local

    bb0: {
        storage_live(max_u128@1);
        max_u128@1 := copy (MAX);
        storage_live(@2);
        storage_live(@3);
        @3 := copy (max_u128@1);
        @2 := wrapping_add(move (@3), const (1 : u128)) -> bb1 (unwind: bb2);
    }

    bb1: {
        storage_dead(@3);
        storage_dead(@2);
        storage_live(min_i128@4);
        min_i128@4 := copy (MIN);
        storage_live(@5);
        storage_live(@6);
        @6 := copy (min_i128@4);
        @5 := wrapping_sub(move (@6), const (1 : i128)) -> bb3 (unwind: bb2);
    }

    bb2: {
        unwind_continue;
    }

    bb3: {
        storage_dead(@6);
        storage_dead(@5);
        nop;
        @0 := ();
        storage_dead(min_i128@4);
        storage_dead(max_u128@1);
        @0 := ();
        return;
    }
}

// Full name: arithmetic::main
fn main()
{
    let @0: (); // return
    let @1: (); // anonymous local
    let @2: (); // anonymous local
    let @3: (); // anonymous local

    bb0: {
        storage_live(@1);
        @1 := plus_minus_mult() -> bb1 (unwind: bb2);
    }

    bb1: {
        storage_dead(@1);
        storage_live(@2);
        @2 := arithmetic_edges_i128_u128() -> bb3 (unwind: bb2);
    }

    bb2: {
        unwind_continue;
    }

    bb3: {
        storage_dead(@2);
        nop;
        @0 := ();
        @0 := ();
        return;
    }
}

// Full name: core::num::{u128}::wrapping_add
pub fn wrapping_add(@1: u128, @2: u128) -> u128

// Full name: core::num::{i128}::wrapping_sub
pub fn wrapping_sub(@1: i128, @2: i128) -> i128

// Full name: core::num::{i128}::MIN
pub fn MIN() -> i128

// Full name: core::num::{u128}::MAX
pub fn MAX() -> u128