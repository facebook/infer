<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>InferModules__CTL (infer.InferModules__CTL)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="generator" content="doc-ock-html v1.0.0-1-g1fc9bf0"/></head><body><nav id="top"><a href="../index.html">Up</a> &mdash; <span class="package">package <a href="../index.html">infer</a></span></nav><header><h1><span class="keyword">Module</span> <span class="module-path">InferModules__CTL</span></h1></header><div class="spec type" id="type-transitions"><a href="#type-transitions" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>transitions</code><code></code><code><span class="keyword"> = </span></code><table class="variant"><tr id="type-transitions.AccessorForProperty" class="anchored"><td class="def constructor"><a href="#type-transitions.AccessorForProperty" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">AccessorForProperty</span><span class="keyword"> of </span><a href="../InferModules/ALVar/index.html#type-alexp">InferModules.ALVar.alexp</a></code></td><td class="doc"><p>(** decl to decl *)</p></td></tr><tr id="type-transitions.Body" class="anchored"><td class="def constructor"><a href="#type-transitions.Body" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Body</span></code></td><td class="doc"><p>(** decl to stmt *)</p></td></tr><tr id="type-transitions.FieldName" class="anchored"><td class="def constructor"><a href="#type-transitions.FieldName" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">FieldName</span><span class="keyword"> of </span><a href="../InferModules/ALVar/index.html#type-alexp">InferModules.ALVar.alexp</a></code></td><td class="doc"><p>(** stmt to stmt, decl to decl *)</p></td></tr><tr id="type-transitions.Fields" class="anchored"><td class="def constructor"><a href="#type-transitions.Fields" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Fields</span></code></td><td class="doc"><p>(** stmt to stmt, decl to decl *)</p></td></tr><tr id="type-transitions.InitExpr" class="anchored"><td class="def constructor"><a href="#type-transitions.InitExpr" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">InitExpr</span></code></td><td class="doc"><p>(** decl to stmt *)</p></td></tr><tr id="type-transitions.Super" class="anchored"><td class="def constructor"><a href="#type-transitions.Super" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Super</span></code></td><td class="doc"><p>(** decl to decl *)</p></td></tr><tr id="type-transitions.ParameterName" class="anchored"><td class="def constructor"><a href="#type-transitions.ParameterName" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">ParameterName</span><span class="keyword"> of </span><a href="../InferModules/ALVar/index.html#type-alexp">InferModules.ALVar.alexp</a></code></td><td class="doc"><p>(** stmt to stmt, decl to decl *)</p></td></tr><tr id="type-transitions.ParameterPos" class="anchored"><td class="def constructor"><a href="#type-transitions.ParameterPos" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">ParameterPos</span><span class="keyword"> of </span><a href="../InferModules/ALVar/index.html#type-alexp">InferModules.ALVar.alexp</a></code></td><td class="doc"><p>(** stmt to stmt, decl to decl *)</p></td></tr><tr id="type-transitions.Parameters" class="anchored"><td class="def constructor"><a href="#type-transitions.Parameters" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Parameters</span></code></td><td class="doc"><p>(** stmt to stmt, decl to decl *)</p></td></tr><tr id="type-transitions.Cond" class="anchored"><td class="def constructor"><a href="#type-transitions.Cond" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Cond</span></code></td></tr><tr id="type-transitions.PointerToDecl" class="anchored"><td class="def constructor"><a href="#type-transitions.PointerToDecl" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">PointerToDecl</span></code></td><td class="doc"><p>(** stmt to decl *)</p></td></tr><tr id="type-transitions.Protocol" class="anchored"><td class="def constructor"><a href="#type-transitions.Protocol" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Protocol</span></code></td><td class="doc"><p>(** decl to decl *)</p></td></tr></table><code></code></div><div class="doc"><p>Transition labels used for example to switch from decl to stmt</p></div></div><div class="spec include"><div class="doc"></div><details open="open"><summary><span class="def"><code><span class="keyword">include </span><span class="keyword">sig</span> ... <span class="keyword">end</span></code></span></summary><div class="spec val" id="val-compare_transitions"><a href="#val-compare_transitions" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>compare_transitions : <a href="index.html#type-transitions">transitions</a> <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-transitions">transitions</a> <span class="keyword">&#8209;&gt;</span> int</code></div><div class="doc"></div></div></details></div><div class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>t</code><code></code><code><span class="keyword"> = </span></code><table class="variant"><tr id="type-t.True" class="anchored"><td class="def constructor"><a href="#type-t.True" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">True</span></code></td></tr><tr id="type-t.False" class="anchored"><td class="def constructor"><a href="#type-t.False" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">False</span></code></td></tr><tr id="type-t.Atomic" class="anchored"><td class="def constructor"><a href="#type-t.Atomic" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Atomic</span><span class="keyword"> of </span><a href="../InferModules/CPredicates/index.html#type-t">InferModules.CPredicates.t</a></code></td><td class="doc"><p>(** Atomic formula *)</p></td></tr><tr id="type-t.Not" class="anchored"><td class="def constructor"><a href="#type-t.Not" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Not</span><span class="keyword"> of </span><a href="index.html#type-t">t</a></code></td></tr><tr id="type-t.And" class="anchored"><td class="def constructor"><a href="#type-t.And" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">And</span><span class="keyword"> of </span><a href="index.html#type-t">t</a><span class="keyword"> * </span><a href="index.html#type-t">t</a></code></td></tr><tr id="type-t.Or" class="anchored"><td class="def constructor"><a href="#type-t.Or" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Or</span><span class="keyword"> of </span><a href="index.html#type-t">t</a><span class="keyword"> * </span><a href="index.html#type-t">t</a></code></td></tr><tr id="type-t.Implies" class="anchored"><td class="def constructor"><a href="#type-t.Implies" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Implies</span><span class="keyword"> of </span><a href="index.html#type-t">t</a><span class="keyword"> * </span><a href="index.html#type-t">t</a></code></td></tr><tr id="type-t.InNode" class="anchored"><td class="def constructor"><a href="#type-t.InNode" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">InNode</span><span class="keyword"> of </span><a href="../InferModules/ALVar/index.html#type-alexp">InferModules.ALVar.alexp</a> list<span class="keyword"> * </span><a href="index.html#type-t">t</a></code></td></tr><tr id="type-t.AX" class="anchored"><td class="def constructor"><a href="#type-t.AX" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">AX</span><span class="keyword"> of </span><a href="index.html#type-transitions">transitions</a> option<span class="keyword"> * </span><a href="index.html#type-t">t</a></code></td><td class="doc"><p>(** AX phi &lt;=&gt; for all children of the current node phi holds *)</p></td></tr><tr id="type-t.EX" class="anchored"><td class="def constructor"><a href="#type-t.EX" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">EX</span><span class="keyword"> of </span><a href="index.html#type-transitions">transitions</a> option<span class="keyword"> * </span><a href="index.html#type-t">t</a></code></td><td class="doc"><p>(** EX phi &lt;=&gt; exist a child of the current node such that phi holds *)</p></td></tr><tr id="type-t.AF" class="anchored"><td class="def constructor"><a href="#type-t.AF" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">AF</span><span class="keyword"> of </span><a href="index.html#type-transitions">transitions</a> option<span class="keyword"> * </span><a href="index.html#type-t">t</a></code></td><td class="doc"><p>(** AF phi &lt;=&gt; for all path from the current node there is a descendant where phi holds *)</p></td></tr><tr id="type-t.EF" class="anchored"><td class="def constructor"><a href="#type-t.EF" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">EF</span><span class="keyword"> of </span><a href="index.html#type-transitions">transitions</a> option<span class="keyword"> * </span><a href="index.html#type-t">t</a></code></td><td class="doc"><p>(** EF phi &lt;=&gt; there exits a a path from the current node with a descendant where phi hold *)</p></td></tr><tr id="type-t.AG" class="anchored"><td class="def constructor"><a href="#type-t.AG" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">AG</span><span class="keyword"> of </span><a href="index.html#type-transitions">transitions</a> option<span class="keyword"> * </span><a href="index.html#type-t">t</a></code></td><td class="doc"><p>(** AG phi &lt;=&gt; for all discendant of the current node phi hold *)</p></td></tr><tr id="type-t.EG" class="anchored"><td class="def constructor"><a href="#type-t.EG" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">EG</span><span class="keyword"> of </span><a href="index.html#type-transitions">transitions</a> option<span class="keyword"> * </span><a href="index.html#type-t">t</a></code></td><td class="doc"><p>(** EG phi &lt;=&gt;
there exists a path (of descendants) from the current node where phi hold at each node of the path *)</p></td></tr><tr id="type-t.AU" class="anchored"><td class="def constructor"><a href="#type-t.AU" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">AU</span><span class="keyword"> of </span><a href="index.html#type-transitions">transitions</a> option<span class="keyword"> * </span><a href="index.html#type-t">t</a><span class="keyword"> * </span><a href="index.html#type-t">t</a></code></td><td class="doc"><p>(** AU(phi1, phi2) &lt;=&gt;
for all paths from the current node phi1 holds in every node until ph2 holds *)</p></td></tr><tr id="type-t.EU" class="anchored"><td class="def constructor"><a href="#type-t.EU" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">EU</span><span class="keyword"> of </span><a href="index.html#type-transitions">transitions</a> option<span class="keyword"> * </span><a href="index.html#type-t">t</a><span class="keyword"> * </span><a href="index.html#type-t">t</a></code></td><td class="doc"><p>(** EU(phi1, phi2) &lt;=&gt;
there exists a path from the current node such that phi1 holds until phi2 holds *)</p></td></tr><tr id="type-t.EH" class="anchored"><td class="def constructor"><a href="#type-t.EH" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">EH</span><span class="keyword"> of </span><a href="../InferModules/ALVar/index.html#type-alexp">InferModules.ALVar.alexp</a> list<span class="keyword"> * </span><a href="index.html#type-t">t</a></code></td><td class="doc"><p>(** EH<code class="code">classes</code>phi &lt;=&gt;
there exists a node defining a super class in the hierarchy of the class
defined by the current node (if any) where phi holds *)</p></td></tr><tr id="type-t.ET" class="anchored"><td class="def constructor"><a href="#type-t.ET" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">ET</span><span class="keyword"> of </span><a href="../InferModules/ALVar/index.html#type-alexp">InferModules.ALVar.alexp</a> list<span class="keyword"> * </span><a href="index.html#type-transitions">transitions</a> option<span class="keyword"> * </span><a href="index.html#type-t">t</a></code></td><td class="doc"><p>(** ET<code class="code">T</code><code class="code">l</code> phi &lt;=&gt; there exists a descentant an of the current node such that an is of type in set T
making a transition to a node an' via label l, such that in an phi holds. *)</p></td></tr></table><code></code></div><div class="doc"><p>A ctl formula</p></div></div><div class="spec include"><div class="doc"></div><details open="open"><summary><span class="def"><code><span class="keyword">include </span><span class="keyword">sig</span> ... <span class="keyword">end</span></code></span></summary><div class="spec val" id="val-compare"><a href="#val-compare" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>compare : <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> int</code></div><div class="doc"></div></div></details></div><div class="spec val" id="val-equal"><a href="#val-equal" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>equal : <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> bool</code></div><div class="doc"></div></div><div class="spec type" id="type-clause"><a href="#type-clause" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>clause</code><code></code><code><span class="keyword"> = </span></code><table class="variant"><tr id="type-clause.CLet" class="anchored"><td class="def constructor"><a href="#type-clause.CLet" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">CLet</span><span class="keyword"> of </span><a href="../InferModules/ALVar/index.html#type-formula_id">InferModules.ALVar.formula_id</a><span class="keyword"> * </span><a href="../InferModules/ALVar/index.html#type-t">InferModules.ALVar.t</a> list<span class="keyword"> * </span><a href="index.html#type-t">t</a></code></td></tr><tr id="type-clause.CSet" class="anchored"><td class="def constructor"><a href="#type-clause.CSet" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">CSet</span><span class="keyword"> of </span><a href="../InferModules/ALVar/index.html#type-keyword">InferModules.ALVar.keyword</a><span class="keyword"> * </span><a href="index.html#type-t">t</a></code></td></tr><tr id="type-clause.CDesc" class="anchored"><td class="def constructor"><a href="#type-clause.CDesc" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">CDesc</span><span class="keyword"> of </span><a href="../InferModules/ALVar/index.html#type-keyword">InferModules.ALVar.keyword</a><span class="keyword"> * </span>string</code></td></tr><tr id="type-clause.CPath" class="anchored"><td class="def constructor"><a href="#type-clause.CPath" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">CPath</span><span class="keyword"> of </span>[ `WhitelistPath | `BlacklistPath ]<span class="keyword"> * </span><a href="../InferModules/ALVar/index.html#type-t">InferModules.ALVar.t</a> list</code></td></tr></table><code></code></div><div class="doc"></div></div><div class="spec type" id="type-ctl_checker"><a href="#type-ctl_checker" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>ctl_checker</code><code></code><code><span class="keyword"> = </span></code><code>{</code><table class="record"><tr id="type-ctl_checker.id" class="anchored"><td class="def field"><a href="#type-ctl_checker.id" class="anchor"></a><code>id : string;</code></td></tr><tr id="type-ctl_checker.definitions" class="anchored"><td class="def field"><a href="#type-ctl_checker.definitions" class="anchor"></a><code>definitions : <a href="index.html#type-clause">clause</a> list;</code></td></tr></table><code>}</code><code></code></div><div class="doc"></div></div><div class="spec type" id="type-al_file"><a href="#type-al_file" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>al_file</code><code></code><code><span class="keyword"> = </span></code><code>{</code><table class="record"><tr id="type-al_file.import_files" class="anchored"><td class="def field"><a href="#type-al_file.import_files" class="anchor"></a><code>import_files : string list;</code></td></tr><tr id="type-al_file.global_macros" class="anchored"><td class="def field"><a href="#type-al_file.global_macros" class="anchor"></a><code>global_macros : <a href="index.html#type-clause">clause</a> list;</code></td></tr><tr id="type-al_file.global_paths" class="anchored"><td class="def field"><a href="#type-al_file.global_paths" class="anchor"></a><code>global_paths : (string<span class="keyword"> * </span><a href="../InferModules/ALVar/index.html#type-alexp">InferModules.ALVar.alexp</a> list) list;</code></td></tr><tr id="type-al_file.checkers" class="anchored"><td class="def field"><a href="#type-al_file.checkers" class="anchor"></a><code>checkers : <a href="index.html#type-ctl_checker">ctl_checker</a> list;</code></td></tr></table><code>}</code><code></code></div><div class="doc"></div></div><div class="spec val" id="val-print_checker"><a href="#val-print_checker" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>print_checker : <a href="index.html#type-ctl_checker">ctl_checker</a> <span class="keyword">&#8209;&gt;</span> unit</code></div><div class="doc"></div></div><div class="spec val" id="val-eval_formula"><a href="#val-eval_formula" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>eval_formula : <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> <a href="../InferModules/Ctl_parser_types/index.html#type-ast_node">InferModules.Ctl_parser_types.ast_node</a> <span class="keyword">&#8209;&gt;</span> <a href="../InferModules/CLintersContext/index.html#type-context">InferModules.CLintersContext.context</a> <span class="keyword">&#8209;&gt;</span> <a href="../InferModules/Ctl_parser_types/index.html#type-ast_node">InferModules.Ctl_parser_types.ast_node</a> option</code></div><div class="doc"><p>return the evaluation of the formula and a witness</p></div></div><div class="spec val" id="val-save_dotty_when_in_debug_mode"><a href="#val-save_dotty_when_in_debug_mode" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>save_dotty_when_in_debug_mode : <a href="../../InferBase/InferBase/SourceFile/index.html#type-t">InferBase.SourceFile.t</a> <span class="keyword">&#8209;&gt;</span> unit</code></div><div class="doc"></div></div><div class="spec val" id="val-next_state_via_transition"><a href="#val-next_state_via_transition" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>next_state_via_transition : <a href="../InferModules/Ctl_parser_types/index.html#type-ast_node">InferModules.Ctl_parser_types.ast_node</a> <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-transitions">transitions</a> <span class="keyword">&#8209;&gt;</span> <a href="../InferModules/Ctl_parser_types/index.html#type-ast_node">InferModules.Ctl_parser_types.ast_node</a> list</code></div><div class="doc"></div></div><div class="spec val" id="val-create_ctl_evaluation_tracker"><a href="#val-create_ctl_evaluation_tracker" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>create_ctl_evaluation_tracker : <a href="../../InferBase/InferBase/SourceFile/index.html#type-t">InferBase.SourceFile.t</a> <span class="keyword">&#8209;&gt;</span> unit</code></div><div class="doc"></div></div><div class="spec module" id="module-Debug"><a href="#module-Debug" class="anchor"></a><div class="def module"><code><span class="keyword">module </span><a href="Debug/index.html">Debug</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="doc"></div></div></body></html>